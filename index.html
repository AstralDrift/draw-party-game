<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! üé®</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Tailwind CSS (for development only) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind production warning for development
        if (typeof tailwind !== 'undefined') {
            tailwind.config = { ...tailwind.config, mode: 'jit' };
        }
    </script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2c2a4a">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        :root {
            --font-display: 'Nunito', sans-serif;
            --font-body: 'Inter', sans-serif;
            --color-bg: #1a1836;
            --color-surface: #2c2a4a;
            --color-primary: #8a5cf6;
            --color-primary-hover: #7c3aed;
            --color-secondary: #34d399;
            --color-secondary-hover: #059669;
            --color-accent: #22d3ee;
            --color-text: #e5e7eb;
            --color-text-muted: #9ca3af;
            --color-border: #4b5563;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-display);
            font-weight: 800;
        }

        .btn {
            font-family: var(--font-display);
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }
        .btn-secondary {
            background-color: var(--color-secondary);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--color-secondary-hover);
        }

        .input-field {
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s;
            font-family: var(--font-body);
        }
        .input-field:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            max-width: min(90vw, 90vh, 500px);
            aspect-ratio: 4/3;
            margin: 0 auto;
        }
        
        .drawing-canvas {
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
            font-family: var(--font-display);
            font-weight: 700;
            border-radius: 0.5rem;
        }
        
        .fade-in { animation: fadeIn 0.5s ease-in; }
        .bounce { animation: bounce 0.6s ease-in-out; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        * { touch-action: manipulation; }
    </style>
</head>
<body class="min-h-screen">
    <div id="app" class="min-h-screen flex flex-col p-4">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">üé®</div>
                <h1 class="text-4xl mb-2">Draw Party!</h1>
                <div class="text-lg text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-6 py-3 shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col items-center justify-center max-w-4xl w-full mx-auto">
            
            <!-- Welcome Screen -->
            <div id="welcome-screen" class="text-center w-full max-w-md">
                <div class="text-8xl mb-6">üé®</div>
                <h1 class="text-5xl mb-4">Welcome to Draw Party!</h1>
                <p class="text-xl text-gray-400 mb-10">The easiest multiplayer drawing game ever.</p>
                
                <div class="space-y-4">
                    <button id="create-room" class="w-full btn btn-primary text-xl">
                        üéÆ Create New Game
                    </button>
                    <div class="text-gray-500 font-bold">OR</div>
                    <div class="flex gap-3">
                        <input id="join-code" type="text" placeholder="ENTER CODE" 
                               class="flex-1 input-field text-center uppercase tracking-widest font-bold text-lg" 
                               maxlength="4">
                        <button id="join-room" class="btn btn-secondary">
                            Join
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Lobby Screen -->
            <div id="lobby-screen" class="hidden w-full max-w-md">
                <div class="text-center mb-8">
                    <h2 class="text-4xl mb-4">Game Lobby</h2>
                    <div class="card mb-6">
                        <div class="text-lg text-gray-400">Room Code</div>
                        <div id="current-room-code" class="text-5xl font-mono font-bold text-white tracking-widest"></div>
                    </div>
                    
                    <button id="share-game" class="w-full btn btn-primary">
                        üì± Share Game Link
                    </button>
                </div>
                
                <div class="card mb-6">
                    <h3 class="text-2xl font-bold mb-4 text-center">Players</h3>
                    <div id="players-list" class="space-y-3"></div>
                    <div id="waiting-message" class="text-gray-400 text-center mt-4">
                        Waiting for more players... (need at least 2)
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="flex gap-3">
                        <input id="player-name" type="text" placeholder="Enter your name" 
                               class="flex-1 input-field">
                        <button id="submit-name" class="btn btn-primary">
                            Set
                        </button>
                    </div>
                    <button id="start-game" class="w-full btn btn-secondary text-xl" disabled>
                        üé® Start Drawing!
                    </button>
                </div>
            </div>
            
            <!-- Drawing Screen -->
            <div id="drawing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <div id="drawing-prompt" class="text-2xl font-bold mb-2 card inline-block"></div>
                    <div id="drawing-timer" class="text-4xl font-mono text-accent"></div>
                </div>
                
                <div class="canvas-container mx-auto mb-4" id="canvas-container">
                    <canvas id="drawing-canvas" class="drawing-canvas w-full"></canvas>
                </div>
                
                <div class="flex flex-wrap gap-4 justify-center items-center mb-4" id="drawing-tools">
                    <div class="flex gap-2 card p-2" id="color-palette">
                        <!-- Player colors will be populated here -->
                    </div>
                    
                    <div class="flex gap-2 card p-2" id="tool-palette">
                        <button id="undo-btn" class="tool-btn btn">‚Ü©Ô∏è</button>
                        <button id="redo-btn" class="tool-btn btn">‚Ü™Ô∏è</button>
                        <button id="brush-small" class="tool-btn btn">S</button>
                        <button id="brush-medium" class="tool-btn btn btn-primary">M</button>
                        <button id="brush-large" class="tool-btn btn">L</button>
                        <button id="eraser" class="tool-btn btn">üóëÔ∏è</button>
                        <button id="clear-canvas" class="tool-btn btn bg-red-600 hover:bg-red-700">‚úñÔ∏è</button>
                    </div>
                </div>
                
                <div class="text-center">
                    <div class="text-sm text-gray-400 mb-2">‚ö†Ô∏è No letters or words allowed!</div>
                    <div id="other-players-status" class="text-gray-400"></div>
                </div>
            </div>
            
            <!-- Guessing Screen -->
            <div id="guessing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">What is this masterpiece?</h2>
                    <div id="guessing-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="guess-canvas" class="drawing-canvas"></canvas>
                    </div>
                    <div class="text-center mt-2 text-lg text-gray-400" id="artist-name"></div>
                </div>
                
                <div class="max-w-md mx-auto">
                    <input id="guess-input" type="text" placeholder="Write your guess..." 
                           class="w-full input-field text-lg mb-4">
                    <button id="submit-guess" class="w-full btn btn-secondary text-lg">
                        Submit Answer
                    </button>
                </div>
            </div>
            
            <!-- Voting Screen -->
            <div id="voting-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">Which is the REAL answer?</h2>
                    <div id="voting-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="vote-canvas" class="drawing-canvas"></canvas>
                    </div>
                </div>
                
                <div id="voting-options" class="grid grid-cols-1 md:grid-cols-2 gap-3 max-w-2xl mx-auto">
                    <!-- Voting options will be populated here -->
                </div>
            </div>
            
            <!-- Results Screen -->
            <div id="results-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">üéâ Round Results!</h2>
                </div>
                
                <div id="results-content" class="space-y-4">
                    <!-- Results will be populated here -->
                </div>
                
                <div class="text-center mt-8">
                    <button id="next-round" class="btn btn-primary text-xl">
                        Next Round üé®
                    </button>
                </div>
            </div>
            
            <!-- Final Scores Screen -->
            <div id="final-scores-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">üèÜ Final Results!</h2>
                </div>
                
                <div id="final-scores-content" class="space-y-4">
                    <!-- Final scores will be populated here -->
                </div>
                
                <div class="text-center mt-8 space-y-4">
                    <button id="play-again" class="w-full btn btn-secondary text-xl">
                        üéÆ Play Again!
                    </button>
                    <button id="new-game" class="w-full btn btn-primary text-xl">
                        üé® New Game
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DEBUG_MODE = false; // Set to true for development logging
        const debugLog = (...args) => {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        };

        class DrawingHistory {
            constructor(maxSteps = 20) {
                this.history = [];
                this.currentStep = -1;
                this.maxSteps = maxSteps;
            }

            saveState(canvas) {
                if (this.currentStep < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentStep + 1);
                }

                if (this.history.length >= this.maxSteps) {
                    this.history.shift();
                }

                this.history.push(canvas.toDataURL());
                this.currentStep = this.history.length - 1;
            }

            undo(canvas, ctx) {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.restoreState(canvas, ctx);
                }
            }

            redo(canvas, ctx) {
                if (this.currentStep < this.history.length - 1) {
                    this.currentStep++;
                    this.restoreState(canvas, ctx);
                }
            }

            restoreState(canvas, ctx) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
                };
                img.src = this.history[this.currentStep];
            }

            clear() {
                this.history = [];
                this.currentStep = -1;
            }
        }

        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5,
                    playerDrawings: new Map(), // Each player's drawing
                    playerPrompts: new Map(),  // Each player's unique prompt
                    currentViewingPlayer: null, // Whose drawing we're viewing
                    currentViewingDrawing: null,
                    currentViewingPrompt: '',
                    guesses: new Map(), // Player guesses for current drawing
                    votes: new Map(),   // Player votes for which guess is correct
                    scores: new Map(),
                    drawingsCompleted: new Set(), // Track who finished drawing
                    roundOrder: [], // Order of drawings to show
                    votingOptions: [] // Options for voting
                };
                
                this.isDrawing = false;
                this.currentColor = '#FFFFFF'; // Start with white
                this.currentSize = 5;
                this.currentTool = 'brush';
                this.drawingHistory = new DrawingHistory();

                // Performance optimizations
                this.drawingBuffer = [];
                this.lastNetworkUpdate = 0;
                this.networkUpdateInterval = 50; // Update network every 50ms max
                this.animationFrameId = null;
                this.isProcessingDrawing = false;
                
                // Performance monitoring
                this.performanceMetrics = {
                    fps: 60,
                    drawLatency: 0,
                    networkLatency: 0,
                    lastFrameTime: performance.now()
                };

                this.playerColors = [
                    '#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93', '#ff924c', '#22d3ee', '#f957a8'
                ];
                
                this.gameConfig = {
                    timers: { drawing: 90, guessing: 45, voting: 30 },
                    gameplay: { minPlayers: 2, maxPlayers: 8, totalRounds: 5 }
                };
                
                // Timer system
                this.currentTimer = null;
                this.timerDisplay = null;
                
                // Prompt system
                this.prompts = [
                    'Cat', 'Dog', 'House', 'Car', 'Tree', 'Sun', 'Moon', 'Fish', 'Bird', 'Flower',
                    'Pizza', 'Burger', 'Ice Cream', 'Cake', 'Apple', 'Banana', 'Guitar', 'Piano', 'Book', 'Phone',
                    'Computer', 'TV', 'Chair', 'Table', 'Bed', 'Door', 'Window', 'Shoe', 'Hat', 'Glasses',
                    'Bicycle', 'Bus', 'Train', 'Airplane', 'Boat', 'Mountain', 'Beach', 'Forest', 'River', 'Cloud',
                    'Star', 'Heart', 'Smile', 'Rainbow', 'Snowman', 'Castle', 'Robot', 'Alien', 'Dragon', 'Unicorn'
                ];
                
                this.gameState.totalRounds = this.gameConfig.gameplay.totalRounds;
                
                this.init();
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas(); 
                this.checkForRoomInURL();
                this.populateColorPalette();
                
                // Test device performance
                this.testDevicePerformance();
            }
            
            // Test device performance and adjust settings accordingly
            testDevicePerformance() {
                const testCanvas = document.createElement('canvas');
                testCanvas.width = 500;
                testCanvas.height = 500;
                const testCtx = testCanvas.getContext('2d');
                
                const startTime = performance.now();
                
                // Perform drawing operations to test performance
                for (let i = 0; i < 100; i++) {
                    testCtx.beginPath();
                    testCtx.arc(
                        Math.random() * 500,
                        Math.random() * 500,
                        Math.random() * 50,
                        0,
                        2 * Math.PI
                    );
                    testCtx.fillStyle = `hsl(${Math.random() * 360}, 50%, 50%)`;
                    testCtx.fill();
                }
                
                const duration = performance.now() - startTime;
                
                // Adjust settings based on performance
                if (duration > 50) {
                    // Slow device - reduce network update frequency
                    this.networkUpdateInterval = 100;
                    debugLog('‚ö†Ô∏è Slow device detected, adjusting performance settings');
                } else if (duration < 20) {
                    // Fast device - increase network update frequency for better responsiveness
                    this.networkUpdateInterval = 30;
                    debugLog('‚ö° Fast device detected, optimizing for best quality');
                }
                
                debugLog(`üìä Device performance test: ${duration.toFixed(2)}ms`);
            }

            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 500);
            }

            populateColorPalette() {
                const palette = document.getElementById('color-palette');
                palette.innerHTML = '';
                this.playerColors.forEach((color, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'color-btn w-10 h-10 rounded-full transition-transform transform hover:scale-110';
                    btn.style.backgroundColor = color;
                    btn.dataset.color = color;
                    if (index === 0) {
                        btn.classList.add('ring-2', 'ring-white');
                        this.currentColor = color;
                    }
                    btn.addEventListener('click', () => this.selectColor(color));
                    palette.appendChild(btn);
                });
            }
            
            selectColor(color) {
                this.currentColor = color;
                this.currentTool = 'brush';
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('ring-2', 'ring-white'));
                document.querySelector(`[data-color="${color}"]`).classList.add('ring-2', 'ring-white');
            }
            
            selectBrush(size) {
                this.currentSize = size;
                this.currentTool = 'brush';
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('btn-primary'));
                if (size === 2) document.getElementById('brush-small').classList.add('btn-primary');
                if (size === 5) document.getElementById('brush-medium').classList.add('btn-primary');
                if (size === 10) document.getElementById('brush-large').classList.add('btn-primary');
            }
            
            selectEraser() {
                this.currentTool = 'eraser';
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('btn-primary'));
                document.getElementById('eraser').classList.add('btn-primary');
            }
            
            // Optimized canvas clearing
            clearCanvas(broadcast = true) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                
                // Use clearRect for performance
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Fill with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Clear drawing buffer
                this.drawingBuffer = [];
                
                // Reset drawing history
                this.drawingHistory.clear();
                this.drawingHistory.saveState(canvas);
                
                // In the new game mode, we don't broadcast individual drawing actions
                // Each player draws independently
            }
            
            undo() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                this.drawingHistory.undo(canvas, ctx);
            }
            
            redo() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                this.drawingHistory.redo(canvas, ctx);
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                let roomCode = null;
                if (path.includes('/draw-party-game/')) {
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) roomCode = parts[1];
                } else {
                    const parts = path.slice(1);
                    if (parts.length === 4) roomCode = parts;
                }
                if (roomCode) {
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                document.getElementById('join-code').addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                
                const submitName = () => {
                    this.playerName = document.getElementById('player-name').value.trim();
                    if (!this.playerName) return;
                    this.gameState.players.set(this.playerId, { id: this.playerId, name: this.playerName, score: 0 });
                    this.broadcastMessage({ type: 'PLAYER_UPDATE', playerId: this.playerId, playerName: this.playerName });
                    this.updatePlayersDisplay();
                    this.showToast(`Name set to: ${this.playerName}`, 'success');
                };
                document.getElementById('submit-name').addEventListener('click', submitName);
                document.getElementById('player-name').addEventListener('keypress', (e) => { if (e.key === 'Enter') submitName(); });

                document.getElementById('undo-btn').addEventListener('click', () => this.undo());
                document.getElementById('redo-btn').addEventListener('click', () => this.redo());
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(2));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(5));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(10));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            createRoom() {
                debugLog('CREATE_ROOM', 'Starting room creation', 'out');
                
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                debugLog('ROOM_CODE', `Generated: ${this.roomCode}`, 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('HOST_SETUP', 'Becoming host, creating peer', 'out');
                
                this.createHostPeer();
                this.showLobby();
                
                debugLog('ROOM_READY', 'Room created successfully', 'out');
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('üëë Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('üéØ Host peer opened with ID:', id);
                    debugLog('üåê Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    debugLog('‚ûï Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('üìû Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('error', (err) => {
                    console.error('‚ùå Host peer error:', err);
                    debugLog('üîÑ Attempting to recover host connection...');
                    this.updateConnectionStatus('Connection error - recovering...');
                    
                    setTimeout(() => {
                        if (this.peer && this.peer.destroyed) {
                            debugLog('üîÑ Recreating host peer after error');
                            this.createHostPeer();
                        } else if (this.peer && this.peer.disconnected) {
                            debugLog('üîÑ Reconnecting host peer');
                            this.peer.reconnect();
                        }
                    }, 2000);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('üîå Host peer disconnected from server');
                    this.updateConnectionStatus('Disconnected - reconnecting...');
                    
                    setTimeout(() => {
                        if (this.peer && !this.peer.destroyed) {
                            debugLog('üîÑ Attempting to reconnect host peer');
                            this.peer.reconnect();
                        }
                    }, 1000);
                });
                
                this.peer.on('close', () => {
                    debugLog('üîå Host peer connection closed');
                });
            }
            
            joinRoom(code) {
                debugLog('JOIN_ROOM', `Attempting to join: ${code}`, 'out');
                
                this.roomCode = code;
                this.isHost = false;
                
                debugLog('PLAYER_SETUP', 'Set as player, looking for host', 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('PEER_INIT', 'Initializing peer connection', 'out');
                this.initializePeer();
                this.showLobby();
                
                debugLog('JOIN_COMPLETE', 'Join room setup complete', 'out');
            }
            
            initializePeer() {
                // Always attempt P2P connection
                if (!this.isHost) {
                    this.createPlayerPeer();
                }
            }
            
            createPlayerPeer() {
                debugLog('üé≠ Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('üéØ Player peer opened with ID:', id);
                    debugLog('üåê Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.error('‚ùå Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    // Fallback to becoming host if connection fails
                    this.becomeHost();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('üìû Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('üîå Player peer disconnected');
                });
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('üîå Attempting to connect to host:', hostId);
                
                const connectionTimeout = setTimeout(() => {
                    debugLog('‚è∞ Connection timeout - no host found, becoming host');
                    this.becomeHost();
                }, 8000);
                
                try {
                    debugLog('üìû Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        debugLog('‚úÖ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.error('‚ùå Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.becomeHost();
                    });
                    
                    conn.on('close', () => {
                        debugLog('üîå Connection to host closed');
                    });
                    
                    conn.on('data', (data) => {
                        debugLog('üì• Data from host:', data);
                    });
                    
                } catch (error) {
                    console.error('üí• Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.becomeHost();
                }
            }
            
            becomeHost() {
                if (this.isHost) return;
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                if (this.peer) {
                    this.peer.destroy();
                }
                
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    debugLog('üéØ becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    debugLog('‚ûï becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    debugLog('üîó Connection established with:', conn.peer);
                    debugLog('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    if (this.isHost) {
                        debugLog('üì° Host sending ROOM_JOINED to:', conn.peer);
                        this.sendToPlayer(conn.peer, { type: 'ROOM_JOINED', roomCode: this.roomCode });
                        setTimeout(() => {
                            debugLog('üì° Host also sending current game state to new player');
                            this.broadcastGameState();
                        }, 100);
                    } else {
                        debugLog('üì° Player sending PLAYER_JOIN to host:', conn.peer);
                        debugLog('üè∑Ô∏è Player name at join time:', this.playerName, '(empty is normal)');
                        this.sendToPlayer(conn.peer, { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName || 'Player' });
                    }
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer, conn);
                });
                
                conn.on('close', () => {
                    debugLog('üîå Connection closed with:', conn.peer);
                    this.connections.delete(conn.peer);
                    
                    if (this.isHost && this.gameState.players.has(conn.peer)) {
                        debugLog('‚ûñ Removing disconnected player:', conn.peer);
                        this.gameState.players.delete(conn.peer);
                        this.broadcastGameState();
                    }
                    
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('‚ùå Connection error with', conn.peer, ':', err);
                    this.connections.delete(conn.peer);
                    this.updatePlayersDisplay();
                });
            }
            
            handleMessage(message, fromPeer, connection = null) {
                debugLog('üì® Received message:', message.type, 'from:', fromPeer);
                debugLog('üì® Message details:', message);
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        debugLog('üéØ Handling PLAYER_JOIN. I am host?', this.isHost);
                        debugLog('üéØ Player joining:', message.playerId, 'Name:', message.playerName);
                        debugLog('üéØ Current players before adding:', this.gameState.players.size);
                        if (this.isHost) {
                            debugLog('‚ûï Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true,
                                likes: 0
                            });
                            debugLog('‚úÖ Player added! New player count:', this.gameState.players.size);
                            debugLog('üìã All players now:', Array.from(this.gameState.players.entries()));
                            debugLog('üì° Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            debugLog('üë§ Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                        }
                        this.updatePlayersDisplay();
                        if (this.isHost) {
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'ROOM_JOINED':
                        debugLog('üéØ Received ROOM_JOINED from host - sending PLAYER_JOIN back');
                        if (!this.isHost) {
                            const playerJoinMessage = {
                                type: 'PLAYER_JOIN',
                                playerId: this.playerId,
                                playerName: this.playerName || 'Player'
                            };
                            debugLog('üì° Sending PLAYER_JOIN to host:', playerJoinMessage);
                            if (connection && connection.open) {
                                try {
                                    connection.send(playerJoinMessage);
                                    debugLog('‚úÖ PLAYER_JOIN sent successfully via direct connection');
                                } catch (error) {
                                    console.error('‚ùå Failed to send PLAYER_JOIN:', error);
                                    this.sendToPlayer(fromPeer, playerJoinMessage);
                                }
                            } else {
                                debugLog('üîÑ Using sendToPlayer fallback');
                                this.sendToPlayer(fromPeer, playerJoinMessage);
                            }
                        }
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        debugLog('üì• Received GAME_STATE_UPDATE:', message.gameState);
                        debugLog('üîç Before update - players.size:', this.gameState.players.size);
                        
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            debugLog('üîÑ Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                debugLog('‚ûï Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            debugLog('‚úÖ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        if (message.gameState.playerDrawings && Array.isArray(message.gameState.playerDrawings)) {
                            this.gameState.playerDrawings.clear();
                            message.gameState.playerDrawings.forEach(([id, drawing]) => this.gameState.playerDrawings.set(id, drawing));
                        }
                        
                        if (message.gameState.drawingsCompleted && Array.isArray(message.gameState.drawingsCompleted)) {
                            this.gameState.drawingsCompleted = new Set(message.gameState.drawingsCompleted);
                        }
                        
                        const { players, guesses, votes, scores, playerPrompts, playerDrawings, drawingsCompleted, ...scalarState } = message.gameState;
                        Object.assign(this.gameState, scalarState);
                        
                        debugLog('üìä Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        if (message.clear) {
                            // Handle clear command
                            this.clearCanvas(false);
                        } else if (message.drawingData) {
                            // Handle compressed drawing data (more efficient)
                            this.updateCanvasFromData(message.drawingData);
                        } else if (message.imageData || message.canvasData) {
                            // Handle full canvas data (fallback)
                            this.updateCanvas(message.imageData || message.canvasData);
                        }
                        
                        // Track network latency
                        if (message.timestamp) {
                            this.performanceMetrics.networkLatency = performance.now() - message.timestamp;
                        }
                        break;
                        
                    case 'DRAWING_SUBMITTED':
                        if (this.isHost) {
                            console.log('Host received drawing from:', message.playerId);
                            this.gameState.playerDrawings.set(message.playerId, message.drawing);
                            this.gameState.drawingsCompleted.add(message.playerId);
                            
                            console.log('Drawings completed:', this.gameState.drawingsCompleted.size, '/', this.gameState.players.size);
                            console.log('Completed by:', Array.from(this.gameState.drawingsCompleted));
                            
                            // Update UI for all players
                            this.broadcastGameState();
                            
                            // Check if all drawings are submitted
                            if (this.gameState.drawingsCompleted.size >= this.gameState.players.size) {
                                console.log('All drawings submitted! Moving to guessing phase...');
                                this.endDrawingPhase();
                            }
                        }
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'LIKE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.likes.set(message.playerId, {
                                targetPlayerId: message.targetPlayerId,
                                guessText: message.guessText
                            });
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'HEARTBEAT':
                        debugLog(`üíì Heartbeat received from ${fromPeer}`);
                        if (this.isHost) {
                            this.sendToPlayer(fromPeer, {
                                type: 'HEARTBEAT_ACK',
                                timestamp: Date.now()
                            }, { waitForReady: false, retries: 0 });
                        }
                        break;
                        
                    case 'HEARTBEAT_ACK':
                        debugLog(`üíì Heartbeat ACK received from ${fromPeer}`);
                        break;
                }
            }
            
            sendToPlayer(playerId, message, options = {}) {
                const {
                    timeout = 5000,
                    retries = 2,
                    retryDelay = 1000,
                    waitForReady = true
                } = options;
                
                const startTime = Date.now();
                
                const createStatus = (success, details = {}) => ({
                    success,
                    playerId,
                    messageType: message.type,
                    timestamp: Date.now(),
                    duration: Date.now() - startTime,
                    ...details
                });
                
                const conn = this.connections.get(playerId);
                if (!conn) {
                    console.warn(`‚ö†Ô∏è No connection found for player: ${playerId}`);
                    return createStatus(false, { 
                        error: 'No connection found',
                        connectionExists: false
                    });
                }
                
                const validateConnection = () => {
                    if (!conn) return { valid: false, reason: 'Connection is null' };
                    if (conn.destroyed) return { valid: false, reason: 'Connection destroyed' };
                    if (!conn.open) return { valid: false, reason: 'Connection not open' };
                    return { valid: true };
                };
                
                const attemptSend = async (attempt = 0) => {
                    const validation = validateConnection();
                    
                    if (!validation.valid) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} invalid: ${validation.reason}`);
                        
                        if (waitForReady && attempt < retries && validation.reason.includes('state')) {
                            debugLog(`üîÑ Waiting for connection to be ready (attempt ${attempt + 1}/${retries + 1})`);
                            
                            const readyPromise = new Promise((resolve) => {
                                const checkReady = () => {
                                    const newValidation = validateConnection();
                                    if (newValidation.valid) {
                                        resolve(true);
                                    } else if (Date.now() - startTime > timeout) {
                                        resolve(false);
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                setTimeout(checkReady, retryDelay);
                            });
                            
                            const isReady = await readyPromise;
                            if (isReady) {
                                return attemptSend(attempt + 1);
                            }
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`üì§ Message sent to ${playerId}:`, message.type);
                        
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            attemptsUsed: attempt + 1,
                            method: 'peerjs'
                        });
                        
                    } catch (error) {
                        console.error(`‚ùå Send attempt ${attempt + 1} failed to ${playerId}:`, error);
                        
                        if (attempt < retries) {
                            debugLog(`üîÑ Retrying send to ${playerId} in ${retryDelay}ms`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return attemptSend(attempt + 1);
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                };
                
                if (waitForReady || retries > 0) {
                    return attemptSend();
                } else {
                    const validation = validateConnection();
                    if (!validation.valid) {
                        this.connections.delete(playerId);
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`üì§ Message sent to ${playerId}:`, message.type);
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            method: 'peerjs'
                        });
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        this.connections.delete(playerId);
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                }
            }
            
            async sendReliably(playerId, message, options = {}) {
                const defaultOptions = {
                    waitForReady: true,
                    retries: 2,
                    retryDelay: 500,
                    ...options
                };
                
                try {
                    const result = await this.sendToPlayer(playerId, message, defaultOptions);
                    
                    if (result.success) {
                        debugLog(`‚úÖ Reliable send success to ${playerId}:`, result);
                        return result;
                    } else {
                        console.warn(`‚ö†Ô∏è Reliable send failed to ${playerId}:`, result);
                        if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                            this.showToast(`Failed to send ${message.type.toLowerCase()} - connection issue`, 'warning');
                        }
                        return result;
                    }
                } catch (error) {
                    console.error(`‚ùå Reliable send error to ${playerId}:`, error);
                    const errorResult = {
                        success: false,
                        error: error.message,
                        playerId,
                        messageType: message.type,
                        timestamp: Date.now()
                    };
                    
                    if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                        this.showToast(`Network error sending ${message.type.toLowerCase()}`, 'error');
                    }
                    return errorResult;
                }
            }
            
            attemptReconnection(playerId, oldConn) {
                console.warn(`Attempting to reconnect to ${playerId}...`);
                if (oldConn) {
                    try { oldConn.close(); } catch (e) { console.error("Error closing old connection:", e); }
                    try { oldConn.destroy(); } catch (e) { console.error("Error destroying old connection:", e); }
                }
                
                if (this.isHost) {
                    // Host doesn't actively reconnect to players, players reconnect to host
                    // Just remove the player from the game state
                    if (this.gameState.players.has(playerId)) {
                        this.gameState.players.delete(playerId);
                        this.broadcastGameState();
                        this.updatePlayersDisplay();
                    }
                } else {
                    // Player tries to reconnect to host
                    this.updateConnectionStatus('Reconnecting to host...');
                    setTimeout(() => this.connectToHost(), 3000);
                }
            }
            
            broadcastMessage(message) {
                if (this.isHost) {
                    this.connections.forEach((conn, peerId) => {
                        if (peerId !== this.playerId) { // Don't send to self
                            this.sendToPlayer(peerId, message);
                        }
                    });
                } else {
                    // Players send messages to the host
                    const hostConn = this.connections.get(`${this.roomCode}_HOST`);
                    if (hostConn) {
                        this.sendToPlayer(`${this.roomCode}_HOST`, message);
                    } else {
                        console.warn('No host connection found to broadcast message.');
                    }
                }
            }
            
            broadcastGameState() {
                if (!this.isHost) return;
                
                const stateToBroadcast = {
                    ...this.gameState,
                    players: Array.from(this.gameState.players.entries()),
                    playerDrawings: Array.from(this.gameState.playerDrawings.entries()),
                    playerPrompts: Array.from(this.gameState.playerPrompts.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                    drawingsCompleted: Array.from(this.gameState.drawingsCompleted),
                };
                
                this.connections.forEach((conn, peerId) => {
                    if (peerId !== this.playerId) { // Don't send to self
                        this.sendToPlayer(peerId, { type: 'GAME_STATE_UPDATE', gameState: stateToBroadcast });
                    }
                });
            }

            updateConnectionStatus(status) {
                // Check if connection status element exists, if not create it
                let statusElement = document.getElementById('connection-status');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'connection-status';
                    statusElement.className = 'text-sm text-gray-400 text-center mt-2';
                    const lobbyScreen = document.getElementById('lobby-screen');
                    if (lobbyScreen) {
                        lobbyScreen.appendChild(statusElement);
                    }
                }
                statusElement.textContent = status;
            }
            
            updateUI() {
                // Update UI based on current game state
                switch (this.gameState.phase) {
                    case 'LOBBY':
                        this.showLobby();
                        break;
                    case 'DRAWING':
                        this.showScreen('drawing-screen');
                        this.updateDrawingUI();
                        break;
                    case 'GUESSING':
                        this.startGuessingPhase();
                        break;
                    case 'VOTING':
                        this.startVotingPhase();
                        break;
                    case 'RESULTS':
                        this.showResults();
                        break;
                }
            }

            showScreen(screenId) {
                ['welcome-screen', 'lobby-screen', 'drawing-screen', 'guessing-screen', 'voting-screen', 'results-screen', 'final-scores-screen'].forEach(id => {
                    document.getElementById(id).classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            }

            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                this.updatePlayersDisplay();
            }

            updatePlayersDisplay() {
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                this.gameState.players.forEach(player => {
                    const playerEl = document.createElement('div');
                    playerEl.className = 'flex items-center justify-between p-3 bg-gray-800 rounded-lg';
                    playerEl.innerHTML = `<span class="font-bold text-lg">${player.name}</span><span class="text-gray-400">${player.score} pts</span>`;
                    playersList.appendChild(playerEl);
                });
                document.getElementById('start-game').disabled = this.gameState.players.size < this.gameConfig.gameplay.minPlayers;
            }
            
            shareGame() {
                const shareUrl = window.location.href;
                if (navigator.share) {
                    navigator.share({
                        title: 'Draw Party!',
                        text: 'Join my Draw Party game!',
                        url: shareUrl,
                    }).then(() => debugLog('Successful share')).catch((error) => console.error('Error sharing', error));
                } else {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        this.showToast('Game link copied to clipboard!', 'success');
                    }).catch(err => {
                        console.error('Could not copy text: ', err);
                        this.showToast('Failed to copy link.', 'error');
                    });
                }
            }

            startGame() {
                if (!this.isHost) return;
                if (this.gameState.players.size < this.gameConfig.gameplay.minPlayers) {
                    this.showToast(`Need at least ${this.gameConfig.gameplay.minPlayers} players to start!`, 'warning');
                    return;
                }
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.broadcastMessage({ type: 'START_GAME' });
                this.startDrawingPhase();
            }
            
            handleStartGame() {
                // Called when receiving START_GAME message
                this.gameState.phase = 'DRAWING';
                this.startDrawingPhase();
            }
            
            submitDrawing() {
                // Check if already submitted
                if (this.gameState.drawingsCompleted.has(this.playerId)) {
                    console.log('Drawing already submitted');
                    return;
                }
                
                // Save the drawing
                const canvas = document.getElementById('drawing-canvas');
                const drawingData = canvas.toDataURL('image/webp', 0.8);
                
                console.log('Submitting drawing for player:', this.playerId);
                console.log('Current completed drawings:', this.gameState.drawingsCompleted);
                
                // Send drawing to host
                this.broadcastMessage({
                    type: 'DRAWING_SUBMITTED',
                    playerId: this.playerId,
                    drawing: drawingData
                });
                
                // Mark as completed locally (will be synced by host)
                this.gameState.drawingsCompleted.add(this.playerId);
                
                // Update UI
                this.updateDrawingUI();
                
                // Disable drawing tools
                const toolsElement = document.getElementById('drawing-tools');
                const submitButton = document.getElementById('submit-drawing');
                
                if (toolsElement) toolsElement.style.display = 'none';
                if (submitButton) {
                    submitButton.disabled = true;
                    submitButton.textContent = 'Drawing Submitted!';
                    submitButton.classList.add('bg-green-600');
                }
                
                this.showToast('Drawing submitted!', 'success');
            }
            
            endDrawingPhase() {
                debugLog('üé® Drawing phase ended');
                
                // Auto-submit drawing if not already submitted
                if (!this.gameState.drawingsCompleted.has(this.playerId)) {
                    console.log('Auto-submitting drawing for player:', this.playerId);
                    this.submitDrawing();
                }
                
                if (this.isHost) {
                    // Wait a bit for final submissions, then start guessing rounds
                    setTimeout(() => {
                        console.log('Host starting guessing rounds...');
                        console.log('Total drawings completed:', this.gameState.drawingsCompleted.size);
                        console.log('Total players:', this.gameState.players.size);
                        this.startGuessingRounds();
                    }, 3000);
                }
            }
            
            startGuessingRounds() {
                if (!this.isHost) return;
                
                // Get the first drawing to show
                if (this.gameState.roundOrder.length > 0) {
                    this.gameState.currentViewingPlayer = this.gameState.roundOrder.shift();
                    this.gameState.currentViewingDrawing = this.gameState.playerDrawings.get(this.gameState.currentViewingPlayer);
                    this.gameState.currentViewingPrompt = this.gameState.playerPrompts.get(this.gameState.currentViewingPlayer);
                    
                    this.gameState.phase = 'GUESSING';
                    this.gameState.guesses.clear();
                    this.broadcastGameState();
                    
                    this.startGuessingPhase();
                } else {
                    // All drawings shown, go to final results
                    this.showFinalResults();
                }
            }

            startDrawingPhase() {
                debugLog('üé® Starting drawing phase');
                this.gameState.phase = 'DRAWING';
                this.showScreen('drawing-screen');
                this.drawingHistory.clear();
                this.clearCanvas(false);
                
                if (this.isHost) {
                    // Clear previous round data
                    this.gameState.playerDrawings.clear();
                    this.gameState.drawingsCompleted.clear();
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    
                    // Assign unique prompts to each player
                    const players = Array.from(this.gameState.players.keys());
                    const shuffledPrompts = [...this.prompts].sort(() => Math.random() - 0.5);
                    
                    console.log('üéØ Assigning prompts to players:', players);
                    
                    players.forEach((playerId, index) => {
                        const prompt = shuffledPrompts[index % shuffledPrompts.length];
                        this.gameState.playerPrompts.set(playerId, prompt);
                        console.log(`Player ${playerId} gets prompt: ${prompt}`);
                    });
                    
                    // Create random order for showing drawings
                    this.gameState.roundOrder = [...players].sort(() => Math.random() - 0.5);
                    
                    console.log('üéØ Round order:', this.gameState.roundOrder);
                    console.log('üéØ Player prompts assigned:', this.gameState.playerPrompts);
                    this.broadcastGameState();
                } else {
                    console.log('Waiting for host to assign prompts...');
                }
                
                this.updateDrawingUI();
                this.startTimer(this.gameConfig.timers.drawing, () => this.endDrawingPhase());
            }




            
            startGuessingPhase() {
                debugLog('ü§î Starting guessing phase');
                this.showScreen('guessing-screen');
                
                // Load the current viewing drawing
                const guessCanvas = document.getElementById('guess-canvas');
                const guessCtx = guessCanvas.getContext('2d');
                
                // Set canvas size
                const container = guessCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                guessCanvas.width = container.clientWidth * dpr;
                guessCanvas.height = container.clientHeight * dpr;
                guessCtx.scale(dpr, dpr);
                
                // Load drawing from data URL
                if (this.gameState.currentViewingDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        guessCtx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
                        guessCtx.drawImage(img, 0, 0, guessCanvas.width / dpr, guessCanvas.height / dpr);
                    };
                    img.src = this.gameState.currentViewingDrawing;
                }
                
                // Update UI - hide artist name if it's the guesser's own drawing
                const artistName = this.gameState.players.get(this.gameState.currentViewingPlayer)?.name || 'Unknown';
                const artistNameElement = document.getElementById('artist-name');
                
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    artistNameElement.textContent = 'This is your drawing - watch others guess!';
                    document.getElementById('guess-input').style.display = 'none';
                    document.getElementById('submit-guess').style.display = 'none';
                } else {
                    artistNameElement.textContent = `What do you think this is?`;
                    document.getElementById('guess-input').style.display = 'block';
                    document.getElementById('submit-guess').style.display = 'block';
                    document.getElementById('guess-input').value = '';
                    document.getElementById('guess-input').disabled = false;
                    document.getElementById('submit-guess').disabled = false;
                }
                
                this.startTimer(this.gameConfig.timers.guessing, () => this.endGuessingPhase());
            }

            submitGuess() {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();
                
                if (!guess) {
                    this.showToast('Please enter a guess!', 'warning');
                    return;
                }
                
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    this.showToast('You cannot guess your own drawing!', 'warning');
                    return;
                }
                
                // Send guess to host
                this.broadcastMessage({
                    type: 'GUESS_SUBMITTED',
                    playerId: this.playerId,
                    guess: guess
                });
                
                guessInput.disabled = true;
                document.getElementById('submit-guess').disabled = true;
                this.showToast('Guess submitted!', 'success');
            }
            
            endGuessingPhase() {
                debugLog('ü§î Guessing phase ended');
                if (this.isHost) {
                    this.gameState.phase = 'VOTING';
                    this.prepareVotingOptions();
                    this.broadcastGameState();
                }
                this.startVotingPhase();
            }
            
            prepareVotingOptions() {
                // Get all submitted guesses
                const guesses = Array.from(this.gameState.guesses.entries());
                
                // Add the correct answer
                const correctAnswer = this.gameState.currentViewingPrompt;
                
                // Create voting options - include all unique guesses plus the correct answer
                const allGuesses = guesses.map(([playerId, guess]) => ({
                    text: guess,
                    playerId: playerId,
                    playerName: this.gameState.players.get(playerId)?.name || 'Unknown'
                }));
                
                // Add correct answer if no one guessed it exactly
                const hasCorrectAnswer = allGuesses.some(g => g.text.toLowerCase() === correctAnswer.toLowerCase());
                if (!hasCorrectAnswer) {
                    allGuesses.push({
                        text: correctAnswer,
                        playerId: 'CORRECT',
                        playerName: 'The Truth'
                    });
                }
                
                // Remove duplicates and shuffle
                const uniqueOptions = [];
                const seenTexts = new Set();
                
                for (const option of allGuesses) {
                    const normalizedText = option.text.toLowerCase().trim();
                    if (!seenTexts.has(normalizedText)) {
                        seenTexts.add(normalizedText);
                        uniqueOptions.push(option);
                    }
                }
                
                this.gameState.votingOptions = uniqueOptions.sort(() => Math.random() - 0.5);
                this.gameState.correctAnswer = correctAnswer;
            }
            
            startVotingPhase() {
                debugLog('üó≥Ô∏è Starting voting phase');
                this.showScreen('voting-screen');
                
                // Copy drawing to voting canvas
                const drawingCanvas = document.getElementById('drawing-canvas');
                const voteCanvas = document.getElementById('vote-canvas');
                const voteCtx = voteCanvas.getContext('2d');
                
                // Set canvas size
                const container = voteCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                voteCanvas.width = container.clientWidth * dpr;
                voteCanvas.height = container.clientHeight * dpr;
                voteCtx.scale(dpr, dpr);
                
                // Copy drawing
                voteCtx.drawImage(drawingCanvas, 0, 0);
                
                // Create voting options
                this.createVotingButtons();
                
                this.startTimer(this.gameConfig.timers.voting, () => this.endVotingPhase());
            }
            
            createVotingButtons() {
                const container = document.getElementById('voting-options');
                container.innerHTML = '';
                
                this.gameState.votingOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full btn btn-primary text-lg p-4 mb-2';
                    button.innerHTML = `
                        <div class="text-lg font-bold">${option.text}</div>
                        ${option.playerId !== 'CORRECT' ? `<div class="text-sm text-gray-300">by ${option.playerName}</div>` : ''}
                    `;
                    button.addEventListener('click', () => this.submitVote(option));
                    container.appendChild(button);
                });
            }
            
            submitVote(selectedOption) {
                // Artist cannot vote on their own drawing
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    this.showToast('You cannot vote on your own drawing!', 'warning');
                    return;
                }
                
                // Can't vote for your own guess
                if (selectedOption.playerId === this.playerId) {
                    this.showToast('You cannot vote for your own guess!', 'warning');
                    return;
                }
                
                this.broadcastMessage({
                    type: 'VOTE_SUBMITTED',
                    playerId: this.playerId,
                    vote: selectedOption
                });
                
                // Disable all voting buttons
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.querySelector('.text-lg').textContent === selectedOption.text) {
                        btn.classList.add('bg-green-600');
                    }
                });
                
                this.showToast('Vote submitted!', 'success');
            }
            
            endVotingPhase() {
                debugLog('üó≥Ô∏è Voting phase ended');
                if (this.isHost) {
                    this.calculateResults();
                    this.gameState.phase = 'RESULTS';
                    this.broadcastGameState();
                }
                this.showResults();
            }
            
            calculateResults() {
                const correctAnswer = this.gameState.correctAnswer;
                const votes = Array.from(this.gameState.votes.entries());
                const guesses = Array.from(this.gameState.guesses.entries());
                
                // Track who voted for what
                const votesByOption = new Map();
                let correctVoters = [];
                
                votes.forEach(([playerId, vote]) => {
                    const voteText = vote.text.toLowerCase();
                    
                    // Check if this was a correct vote
                    if (voteText === correctAnswer.toLowerCase()) {
                        correctVoters.push(playerId);
                        // Give points for correct guess
                        const currentScore = this.gameState.scores.get(playerId) || 0;
                        this.gameState.scores.set(playerId, currentScore + 100);
                    }
                    
                    // Track votes for scoring fake answers
                    if (vote.playerId !== 'CORRECT' && vote.playerId !== playerId) {
                        if (!votesByOption.has(vote.playerId)) {
                            votesByOption.set(vote.playerId, []);
                        }
                        votesByOption.get(vote.playerId).push(playerId);
                    }
                });
                
                // Give points to players whose fake answers got votes
                votesByOption.forEach((voters, guesserId) => {
                    const pointsPerVote = 50;
                    const totalPoints = voters.length * pointsPerVote;
                    const currentScore = this.gameState.scores.get(guesserId) || 0;
                    this.gameState.scores.set(guesserId, currentScore + totalPoints);
                });
                
                // Artist (drawing owner) gets points based on correct guesses
                const artistId = this.gameState.currentViewingPlayer;
                const totalVoters = votes.length;
                if (totalVoters > 0 && correctVoters.length > 0) {
                    const artistPoints = Math.round((correctVoters.length / totalVoters) * 150);
                    const currentArtistScore = this.gameState.scores.get(artistId) || 0;
                    this.gameState.scores.set(artistId, currentArtistScore + artistPoints);
                }
                
                this.gameState.roundResults = {
                    correctAnswer,
                    artistId,
                    correctVoters,
                    totalVoters: votes.length,
                    votes: votes,
                    guesses: guesses,
                    votesByOption
                };
            }
            
            showResults() {
                debugLog('üéâ Showing results');
                this.showScreen('results-screen');
                
                const container = document.getElementById('results-content');
                const results = this.gameState.roundResults;
                const artistName = this.gameState.players.get(results.artistId)?.name || 'Unknown';
                
                // Build who voted for what display
                let votesDisplay = '<div class="mt-4">';
                this.gameState.votingOptions.forEach(option => {
                    const voters = Array.from(results.votes.entries())
                        .filter(([_, vote]) => vote.text === option.text)
                        .map(([playerId, _]) => this.gameState.players.get(playerId)?.name || 'Unknown');
                    
                    const isCorrect = option.text.toLowerCase() === results.correctAnswer.toLowerCase();
                    votesDisplay += `
                        <div class="mb-3 p-3 rounded ${isCorrect ? 'bg-green-800' : 'bg-gray-800'}">
                            <div class="font-bold ${isCorrect ? 'text-green-400' : ''}">${option.text}</div>
                            ${option.playerId !== 'CORRECT' ? `<div class="text-sm text-gray-400">Guessed by ${option.playerName}</div>` : ''}
                            <div class="text-sm mt-1">Voted by: ${voters.length > 0 ? voters.join(', ') : 'Nobody'}</div>
                        </div>
                    `;
                });
                votesDisplay += '</div>';
                
                container.innerHTML = `
                    <div class="card text-center mb-4">
                        <h3 class="text-2xl font-bold mb-2">The correct answer was:</h3>
                        <div class="text-4xl font-bold text-green-400">${results.correctAnswer}</div>
                        <div class="text-lg text-gray-400 mt-2">Drawing by ${artistName}</div>
                    </div>
                    
                    <div class="card mb-4">
                        <h4 class="text-xl font-bold mb-2">Who voted for what:</h4>
                        ${votesDisplay}
                    </div>
                    
                    <div class="card mb-4">
                        <h4 class="text-xl font-bold mb-2">Points this round:</h4>
                        <p class="text-lg">${results.correctVoters.length}/${results.totalVoters} players guessed correctly</p>
                    </div>
                `;
                
                // Check if we have more drawings to show
                setTimeout(() => {
                    if (this.isHost) {
                        if (this.gameState.roundOrder.length > 0) {
                            // More drawings to show
                            this.startGuessingRounds();
                        } else {
                            // Round complete, check if game over
                            if (this.gameState.currentRound >= this.gameState.totalRounds) {
                                this.showFinalResults();
                            } else {
                                // Show next round button
                                const nextBtn = document.createElement('button');
                                nextBtn.className = 'btn btn-primary text-xl mt-4';
                                nextBtn.textContent = 'Next Round';
                                nextBtn.addEventListener('click', () => this.nextRound());
                                container.appendChild(nextBtn);
                            }
                        }
                    }
                }, 5000);
            }
            
            updateScoresDisplay() {
                const container = document.getElementById('current-scores');
                const scores = Array.from(this.gameState.scores.entries())
                    .map(([playerId, score]) => ({
                        playerId,
                        name: this.gameState.players.get(playerId)?.name || 'Unknown',
                        score
                    }))
                    .sort((a, b) => b.score - a.score);
                
                container.innerHTML = scores.map(player => 
                    `<div class="flex justify-between items-center p-2 bg-gray-700 rounded mb-2">
                        <span class="font-bold">${player.name}</span>
                        <span class="text-xl">${player.score}</span>
                    </div>`
                ).join('');
            }

            nextRound() {
                if (!this.isHost) return;
                
                this.gameState.currentRound++;
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                
                this.broadcastMessage({ type: 'START_GAME' });
                this.startDrawingPhase();
            }
            
            showFinalResults() {
                this.showScreen('final-scores-screen');
                
                const container = document.getElementById('final-scores-content');
                const scores = Array.from(this.gameState.scores.entries())
                    .map(([playerId, score]) => ({
                        playerId,
                        name: this.gameState.players.get(playerId)?.name || 'Unknown',
                        score
                    }))
                    .sort((a, b) => b.score - a.score);
                
                const winner = scores[0];
                
                container.innerHTML = `
                    <div class="card text-center mb-6">
                        <h3 class="text-3xl font-bold mb-4">üèÜ ${winner.name} Wins!</h3>
                        <div class="text-6xl font-bold text-yellow-400">${winner.score}</div>
                        <div class="text-lg text-gray-400">points</div>
                    </div>
                    
                    <div class="card">
                        <h4 class="text-xl font-bold mb-4">Final Scores:</h4>
                        ${scores.map((player, index) => 
                            `<div class="flex justify-between items-center p-3 ${index === 0 ? 'bg-yellow-600' : 'bg-gray-700'} rounded mb-2">
                                <span class="flex items-center">
                                    <span class="text-2xl mr-3">${index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ'}</span>
                                    <span class="font-bold">${player.name}</span>
                                </span>
                                <span class="text-xl font-bold">${player.score}</span>
                            </div>`
                        ).join('')}
                    </div>
                `;
            }

            playAgain() {
                if (!this.isHost) return;
                
                // Reset game state for new game
                this.gameState.currentRound = 0;
                this.gameState.phase = 'LOBBY';
                this.gameState.playerDrawings.clear();
                this.gameState.playerPrompts.clear();
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                this.gameState.scores.clear();
                this.gameState.drawingsCompleted.clear();
                this.gameState.currentViewingPlayer = null;
                this.gameState.currentViewingDrawing = null;
                this.gameState.currentViewingPrompt = '';
                this.gameState.roundOrder = [];
                
                // Reset all player scores
                this.gameState.players.forEach((player, playerId) => {
                    player.score = 0;
                    this.gameState.players.set(playerId, player);
                });
                
                this.broadcastGameState();
                this.showLobby();
            }
            
            checkAllGuessesSubmitted() {
                // Check if all non-artist players have submitted guesses
                const nonArtistPlayers = Array.from(this.gameState.players.keys())
                    .filter(playerId => playerId !== this.gameState.currentViewingPlayer);
                const submittedGuesses = Array.from(this.gameState.guesses.keys());
                
                debugLog(`üìù Guesses: ${submittedGuesses.length}/${nonArtistPlayers.length}`);
                
                if (submittedGuesses.length >= nonArtistPlayers.length) {
                    debugLog('üìù All guesses submitted, advancing to voting');
                    // Small delay to let UI update
                    setTimeout(() => this.endGuessingPhase(), 1000);
                }
            }
            
            checkAllVotesSubmitted() {
                // Check if all non-artist players have submitted votes
                const nonArtistPlayers = Array.from(this.gameState.players.keys())
                    .filter(playerId => playerId !== this.gameState.currentViewingPlayer);
                const submittedVotes = Array.from(this.gameState.votes.keys());
                
                debugLog(`üó≥Ô∏è Votes: ${submittedVotes.length}/${nonArtistPlayers.length}`);
                
                if (submittedVotes.length >= nonArtistPlayers.length) {
                    debugLog('üó≥Ô∏è All votes submitted, showing results');
                    // Small delay to let UI update
                    setTimeout(() => this.endVotingPhase(), 1000);
                }
            }

            newGame() {
                window.location.href = window.location.pathname;
            }

            showToast(message, type) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast shadow-lg px-6 py-3 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white`;
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 3000);
            }

            // Timer System
            startTimer(seconds, onComplete) {
                if (this.currentTimer) {
                    clearInterval(this.currentTimer);
                }
                
                let timeLeft = seconds;
                this.updateTimerDisplay(timeLeft);
                
                this.currentTimer = setInterval(() => {
                    timeLeft--;
                    this.updateTimerDisplay(timeLeft);
                    
                    if (timeLeft <= 0) {
                        clearInterval(this.currentTimer);
                        this.currentTimer = null;
                        onComplete();
                    }
                }, 1000);
            }
            
            updateTimerDisplay(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeString = `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                // Update all timer displays
                const timerElements = ['drawing-timer', 'guessing-timer', 'voting-timer'];
                timerElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element && !element.classList.contains('hidden')) {
                        element.textContent = timeString;
                        
                        // Add urgency styling for last 10 seconds
                        if (seconds <= 10) {
                            element.classList.add('text-red-500', 'animate-pulse');
                        } else {
                            element.classList.remove('text-red-500', 'animate-pulse');
                        }
                    }
                });
            }
            
                        // Drawing UI Updates
            updateDrawingUI() {
                const promptElement = document.getElementById('drawing-prompt');
                const toolsElement = document.getElementById('drawing-tools');
                const statusElement = document.getElementById('other-players-status');
                
                if (!promptElement || !toolsElement || !statusElement) {
                    console.warn('Missing drawing UI elements');
                    return;
                }
                
                // All players can draw their own prompt
                const myPrompt = this.gameState.playerPrompts?.get(this.playerId) || 'Loading...';
                promptElement.textContent = `Draw: ${myPrompt}`;
                
                // Show drawing tools if not submitted
                if (this.gameState.drawingsCompleted.has(this.playerId)) {
                    toolsElement.style.display = 'none';
                } else {
                    toolsElement.style.display = 'flex';
                }
                
                // Show how many players have finished
                const completedCount = this.gameState.drawingsCompleted?.size || 0;
                const totalPlayers = this.gameState.players.size;
                statusElement.textContent = `${completedCount}/${totalPlayers} players have finished drawing`;
                
                console.log('Updated drawing UI:', myPrompt, `${completedCount}/${totalPlayers} completed`);
                
                // Add submit button if not already there
                if (!document.getElementById('submit-drawing')) {
                    const submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-drawing';
                    submitBtn.className = 'btn btn-secondary text-lg mt-4';
                    submitBtn.textContent = 'Submit Drawing';
                    submitBtn.addEventListener('click', () => this.submitDrawing());
                    
                    // Insert the button after the status element
                    statusElement.parentNode.insertBefore(submitBtn, statusElement.nextSibling);
                    console.log('Submit drawing button added');
                }
                
                // Update submit button state
                const submitBtn = document.getElementById('submit-drawing');
                if (submitBtn) {
                    if (this.gameState.drawingsCompleted.has(this.playerId)) {
                        submitBtn.disabled = true;
                        submitBtn.textContent = 'Drawing Submitted!';
                        submitBtn.classList.add('bg-green-600');
                    } else {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit Drawing';
                        submitBtn.classList.remove('bg-green-600');
                    }
                }
            }
            
            // Performance-optimized drawing loop using requestAnimationFrame
            startDrawingLoop(canvas, ctx) {
                const processDrawingBuffer = () => {
                    if (this.drawingBuffer.length === 0) {
                        if (!this.isDrawing) {
                            this.animationFrameId = null;
                            return;
                        }
                        this.animationFrameId = requestAnimationFrame(processDrawingBuffer);
                        return;
                    }
                    
                    // Process all pending drawing operations in batch
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Batch similar operations together
                    let currentColor = null;
                    let currentSize = null;
                    
                    ctx.beginPath();
                    
                    while (this.drawingBuffer.length > 0) {
                        const stroke = this.drawingBuffer.shift();
                        
                        // Only update context properties if they changed
                        if (stroke.color !== currentColor) {
                            if (currentColor !== null) {
                                ctx.stroke();
                                ctx.beginPath();
                            }
                            currentColor = stroke.color;
                            ctx.strokeStyle = currentColor;
                        }
                        
                        if (stroke.size !== currentSize) {
                            if (currentSize !== null) {
                                ctx.stroke();
                                ctx.beginPath();
                            }
                            currentSize = stroke.size;
                            ctx.lineWidth = currentSize;
                        }
                        
                        ctx.moveTo(stroke.from.x, stroke.from.y);
                        ctx.lineTo(stroke.to.x, stroke.to.y);
                    }
                    
                    ctx.stroke();
                    ctx.restore();
                };
                
                this.animationFrameId = requestAnimationFrame(processDrawingBuffer);
            }
            
            // Update canvas from received drawing data
            updateCanvas(imageData) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
                };
                img.src = imageData;
            }
            
            // Update canvas from compressed drawing data (e.g., individual strokes)
            updateCanvasFromData(drawingData) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                
                drawingData.forEach(stroke => {
                    ctx.strokeStyle = stroke.color;
                    ctx.lineWidth = stroke.size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(stroke.from.x, stroke.from.y);
                    ctx.lineTo(stroke.to.x, stroke.to.y);
                    ctx.stroke();
                });
            }

            setupCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');

                const resize = () => {
                    const container = canvas.parentElement;
                    const containerRect = container.getBoundingClientRect();
                    
                    // Set canvas display size
                    canvas.style.width = containerRect.width + 'px';
                    canvas.style.height = containerRect.height + 'px';
                    
                    // Set canvas actual size (for high DPI displays)
                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    canvas.width = containerRect.width * dpr;
                    canvas.height = containerRect.height * dpr;
                    
                    // Scale the drawing context
                    ctx.scale(dpr, dpr);
                    
                    // Fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, containerRect.width, containerRect.height);
                    
                    console.log('Canvas resized:', containerRect.width, 'x', containerRect.height);
                };
                
                // Debounced resize for performance
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(resize, 100);
                });
                resize();

                const getPos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { 
                        x: clientX - rect.left, 
                        y: clientY - rect.top 
                    };
                };

                const start = (e) => {
                    if (this.gameState.phase !== 'DRAWING') {
                        console.log('Not in drawing phase:', this.gameState.phase);
                        return;
                    }
                    
                    e.preventDefault();
                    this.isDrawing = true;
                    this.lastPos = getPos(e);
                    console.log('Drawing started at:', this.lastPos);
                };
                
                const draw = (e) => {
                    if (!this.isDrawing) return;
                    if (this.gameState.phase !== 'DRAWING') return;
                    
                    e.preventDefault();
                    const pos = getPos(e);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.lastPos.x, this.lastPos.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = this.currentTool === 'eraser' ? 'white' : this.currentColor;
                    ctx.lineWidth = this.currentSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    this.lastPos = pos;
                };
                
                const stop = () => {
                    if (!this.isDrawing) return;
                    this.isDrawing = false;
                    this.drawingHistory.saveState(canvas);
                    console.log('Drawing stopped');
                };

                canvas.addEventListener('mousedown', start);
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', stop);
                canvas.addEventListener('mouseout', stop);
                canvas.addEventListener('touchstart', start, { passive: false });
                canvas.addEventListener('touchmove', draw, { passive: false });
                canvas.addEventListener('touchend', stop);
                
                console.log('Canvas setup complete');
            }
        }

        window.game = new DrawPartyGame();
    </script>
</body>
</html>