<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! 🎨</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎨</text></svg>">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Tailwind CSS (for development only) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind production warning for development
        if (typeof tailwind !== 'undefined') {
            tailwind.config = { ...tailwind.config, mode: 'jit' };
        }
    </script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2c2a4a">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        :root {
            --font-display: 'Nunito', sans-serif;
            --font-body: 'Inter', sans-serif;
            --color-bg: #1a1836;
            --color-surface: #2c2a4a;
            --color-primary: #8a5cf6;
            --color-primary-hover: #7c3aed;
            --color-secondary: #34d399;
            --color-secondary-hover: #059669;
            --color-accent: #22d3ee;
            --color-text: #e5e7eb;
            --color-text-muted: #9ca3af;
            --color-border: #4b5563;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-display);
            font-weight: 800;
        }

        .btn {
            font-family: var(--font-display);
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }
        .btn-secondary {
            background-color: var(--color-secondary);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--color-secondary-hover);
        }

        .input-field {
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s;
            font-family: var(--font-body);
        }
        .input-field:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            max-width: min(90vw, 90vh, 500px);
            aspect-ratio: 4/3;
            margin: 0 auto;
        }
        
        .drawing-canvas {
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
            font-family: var(--font-display);
            font-weight: 700;
            border-radius: 0.5rem;
        }
        
        .fade-in { animation: fadeIn 0.5s ease-in; }
        .bounce { animation: bounce 0.6s ease-in-out; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        * { touch-action: manipulation; }
    </style>
</head>
<body class="min-h-screen">
    <div id="app" class="min-h-screen flex flex-col p-4">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">🎨</div>
                <h1 class="text-4xl mb-2">Draw Party!</h1>
                <div class="text-lg text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-6 py-3 shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col items-center justify-center max-w-4xl w-full mx-auto">
            
            <!-- Welcome Screen -->
            <div id="welcome-screen" class="text-center w-full max-w-md">
                <div class="text-8xl mb-6">🎨</div>
                <h1 class="text-5xl mb-4">Welcome to Draw Party!</h1>
                <p class="text-xl text-gray-400 mb-10">The easiest multiplayer drawing game ever.</p>
                
                <div class="space-y-4">
                    <button id="create-room" class="w-full btn btn-primary text-xl">
                        🎮 Create New Game
                    </button>
                    <div class="text-gray-500 font-bold">OR</div>
                    <div class="flex gap-3">
                        <input id="join-code" type="text" placeholder="ENTER CODE" 
                               class="flex-1 input-field text-center uppercase tracking-widest font-bold text-lg" 
                               maxlength="4">
                        <button id="join-room" class="btn btn-secondary">
                            Join
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Lobby Screen -->
            <div id="lobby-screen" class="hidden w-full max-w-md">
                <div class="text-center mb-8">
                    <h2 class="text-4xl mb-4">Game Lobby</h2>
                    <div class="card mb-6">
                        <div class="text-lg text-gray-400">Room Code</div>
                        <div id="current-room-code" class="text-5xl font-mono font-bold text-white tracking-widest"></div>
                    </div>
                    
                    <button id="share-game" class="w-full btn btn-primary">
                        📱 Share Game Link
                    </button>
                </div>
                
                <div class="card mb-6">
                    <h3 class="text-2xl font-bold mb-4 text-center">Players</h3>
                    <div id="players-list" class="space-y-3"></div>
                    <div id="waiting-message" class="text-gray-400 text-center mt-4">
                        Waiting for more players... (need at least 2)
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="flex gap-3">
                        <input id="player-name" type="text" placeholder="Enter your name" 
                               class="flex-1 input-field">
                        <button id="submit-name" class="btn btn-primary">
                            Set
                        </button>
                    </div>
                    <button id="start-game" class="w-full btn btn-secondary text-xl" disabled>
                        🎨 Start Drawing!
                    </button>
                </div>
            </div>
            
            <!-- Drawing Screen -->
            <div id="drawing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <div id="drawing-prompt" class="text-2xl font-bold mb-2 card inline-block"></div>
                    <div id="drawing-timer" class="text-4xl font-mono text-accent"></div>
                </div>
                
                <div class="canvas-container mx-auto mb-4" id="canvas-container">
                    <canvas id="drawing-canvas" class="drawing-canvas w-full"></canvas>
                </div>
                
                <div class="flex flex-wrap gap-4 justify-center items-center mb-4" id="drawing-tools">
                    <div class="flex gap-2 card p-2" id="color-palette">
                        <!-- Player colors will be populated here -->
                    </div>
                    
                    <div class="flex gap-2 card p-2" id="tool-palette">
                        <button id="undo-btn" class="tool-btn btn">↩️</button>
                        <button id="redo-btn" class="tool-btn btn">↪️</button>
                        <button id="brush-small" class="tool-btn btn">S</button>
                        <button id="brush-medium" class="tool-btn btn btn-primary">M</button>
                        <button id="brush-large" class="tool-btn btn">L</button>
                        <button id="eraser" class="tool-btn btn">🗑️</button>
                        <button id="clear-canvas" class="tool-btn btn bg-red-600 hover:bg-red-700">✖️</button>
                    </div>
                </div>
                
                <div class="text-center">
                    <div class="text-sm text-gray-400 mb-2">⚠️ No letters or words allowed!</div>
                    <div id="other-players-status" class="text-gray-400"></div>
                </div>
            </div>
            
            <!-- Guessing Screen -->
            <div id="guessing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">What is this masterpiece?</h2>
                    <div id="guessing-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="guess-canvas" class="drawing-canvas"></canvas>
                    </div>
                    <div class="text-center mt-2 text-lg text-gray-400" id="artist-name"></div>
                </div>
                
                <div class="max-w-md mx-auto">
                    <input id="guess-input" type="text" placeholder="Write your guess..." 
                           class="w-full input-field text-lg mb-4">
                    <button id="submit-guess" class="w-full btn btn-secondary text-lg">
                        Submit Answer
                    </button>
                </div>
            </div>
            
            <!-- Voting Screen -->
            <div id="voting-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">Which is the REAL answer?</h2>
                    <div id="voting-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="vote-canvas" class="drawing-canvas"></canvas>
                    </div>
                </div>
                
                <div id="voting-options" class="grid grid-cols-1 md:grid-cols-2 gap-3 max-w-2xl mx-auto">
                    <!-- Voting options will be populated here -->
                </div>
            </div>
            
            <!-- Results Screen -->
            <div id="results-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">🎉 Round Results!</h2>
                </div>
                
                <div id="results-content" class="space-y-4">
                    <!-- Results will be populated here -->
                </div>
                
                <div class="text-center mt-8">
                    <button id="next-round" class="btn btn-primary text-xl">
                        Next Round 🎨
                    </button>
                </div>
            </div>
            
            <!-- Final Scores Screen -->
            <div id="final-scores-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">🏆 Final Results!</h2>
                </div>
                
                <div id="final-scores-content" class="space-y-4">
                    <!-- Final scores will be populated here -->
                </div>
                
                <div class="text-center mt-8 space-y-4">
                    <button id="play-again" class="w-full btn btn-secondary text-xl">
                        🎮 Play Again!
                    </button>
                    <button id="new-game" class="w-full btn btn-primary text-xl">
                        🎨 New Game
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DEBUG_MODE = false; // Set to true for development logging
        // Lightweight debug logger that respects the DEBUG_MODE flag
        const debugLog = (...args) => { if (typeof DEBUG_MODE !== 'undefined' && DEBUG_MODE) console.log(...args); };

        class DrawingHistory {
            constructor(maxSteps = 20) {
                this.history = [];
                this.currentStep = -1;
                this.maxSteps = maxSteps;
            }

            saveState(canvas) {
                if (this.currentStep < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentStep + 1);
                }

                if (this.history.length >= this.maxSteps) {
                    this.history.shift();
                }

                this.history.push(canvas.toDataURL());
                this.currentStep = this.history.length - 1;
            }

            undo(canvas, ctx) {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.restoreState(canvas, ctx);
                }
            }

            redo(canvas, ctx) {
                if (this.currentStep < this.history.length - 1) {
                    this.currentStep++;
                    this.restoreState(canvas, ctx);
                }
            }

            restoreState(canvas, ctx) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const dpr = window.devicePixelRatio || 1;
                    ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
                    // Restore white background
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                    ctx.globalCompositeOperation = 'source-over';
                };
                img.src = this.history[this.currentStep];
            }

            clear() {
                this.history = [];
                this.currentStep = -1;
            }
        }

        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5,
                    playerDrawings: new Map(), // Each player's drawing
                    playerPrompts: new Map(),  // Each player's unique prompt
                    currentViewingPlayer: null, // Whose drawing we're viewing
                    currentViewingDrawing: null,
                    currentViewingPrompt: '',
                    guesses: new Map(), // Player guesses for current drawing
                    votes: new Map(),   // Player votes for which guess is correct
                    scores: new Map(),
                    drawingsCompleted: new Set(), // Track who finished drawing
                    roundOrder: [], // Order of drawings to show
                    votingOptions: [] // Options for voting
                };
                
                this.isDrawing = false;
                this.currentColor = '#ff595e'; // Start with red (visible color)
                this.currentSize = 5;
                this.currentTool = 'brush';
                this.drawingHistory = new DrawingHistory();

                // Performance optimizations - ACTUALLY IMPLEMENT THESE
                this.drawingBuffer = [];
                this.lastNetworkUpdate = 0;
                this.networkUpdateInterval = 50; // Update network every 50ms max
                this.animationFrameId = null;
                this.isProcessingDrawing = false;
                
                // Performance monitoring
                this.performanceMetrics = {
                    fps: 60,
                    drawLatency: 0,
                    networkLatency: 0,
                    lastFrameTime: performance.now()
                };

                this.playerColors = [
                    '#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93', '#ff924c', '#22d3ee', '#f957a8'
                ];
                
                this.gameConfig = {
                    timers: { drawing: 90, guessing: 45, voting: 30 },
                    gameplay: { minPlayers: 2, maxPlayers: 8, totalRounds: 5 }
                };
                
                // Timer system
                this.currentTimer = null;
                this.timerDisplay = null;
                
                // Resource management for memory leak prevention
                this.eventListeners = [];
                this.activeTimeouts = new Set();
                this.activeIntervals = new Set();
                this.canvasEventListeners = [];
                this.resizeTimeout = null;
                
                // Prompt system
                this.prompts = [
                    'Cat', 'Dog', 'House', 'Car', 'Tree', 'Sun', 'Moon', 'Fish', 'Bird', 'Flower',
                    'Pizza', 'Burger', 'Ice Cream', 'Cake', 'Apple', 'Banana', 'Guitar', 'Piano', 'Book', 'Phone',
                    'Computer', 'TV', 'Chair', 'Table', 'Bed', 'Door', 'Window', 'Shoe', 'Hat', 'Glasses',
                    'Bicycle', 'Bus', 'Train', 'Airplane', 'Boat', 'Mountain', 'Beach', 'Forest', 'River', 'Cloud',
                    'Star', 'Heart', 'Smile', 'Rainbow', 'Snowman', 'Castle', 'Robot', 'Alien', 'Dragon', 'Unicorn'
                ];
                
                this.gameState.totalRounds = this.gameConfig.gameplay.totalRounds;
                
                // Cleanup on page unload
                this.addManagedEventListener(window, 'beforeunload', () => this.cleanup());
                this.addManagedEventListener(window, 'unload', () => this.cleanup());
                
                this.init();
            }
            
            // Resource management methods
            addManagedEventListener(element, event, handler, options = {}) {
                element.addEventListener(event, handler, options);
                this.eventListeners.push({ element, event, handler, options });
            }
            
            createManagedTimeout(callback, delay) {
                const timeoutId = setTimeout(() => {
                    this.activeTimeouts.delete(timeoutId);
                    callback();
                }, delay);
                this.activeTimeouts.add(timeoutId);
                return timeoutId;
            }
            
            createManagedInterval(callback, interval) {
                const intervalId = setInterval(callback, interval);
                this.activeIntervals.add(intervalId);
                return intervalId;
            }
            
            clearManagedTimeout(timeoutId) {
                if (this.activeTimeouts.has(timeoutId)) {
                    clearTimeout(timeoutId);
                    this.activeTimeouts.delete(timeoutId);
                }
            }
            
            clearManagedInterval(intervalId) {
                if (this.activeIntervals.has(intervalId)) {
                    clearInterval(intervalId);
                    this.activeIntervals.delete(intervalId);
                }
            }
            
            cleanup() {
                console.log('🧹 Cleaning up resources to prevent memory leaks...');
                
                // Clear all managed event listeners
                this.eventListeners.forEach(({ element, event, handler, options }) => {
                    try {
                        element.removeEventListener(event, handler, options);
                    } catch (error) {
                        console.warn('Error removing event listener:', error);
                    }
                });
                this.eventListeners = [];
                
                // Clear all managed timeouts
                this.activeTimeouts.forEach(timeoutId => {
                    try {
                        clearTimeout(timeoutId);
                    } catch (error) {
                        console.warn('Error clearing timeout:', error);
                    }
                });
                this.activeTimeouts.clear();
                
                // Clear all managed intervals
                this.activeIntervals.forEach(intervalId => {
                    try {
                        clearInterval(intervalId);
                    } catch (error) {
                        console.warn('Error clearing interval:', error);
                    }
                });
                this.activeIntervals.clear();
                
                // Clear canvas event listeners
                this.cleanupCanvasEventListeners();
                
                // Clear timers
                this.clearTimer();
                
                // Clear animation frames
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Clear resize timeout
                if (this.resizeTimeout) {
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = null;
                }
                
                // Close peer connections
                if (this.peer) {
                    try {
                        this.peer.destroy();
                    } catch (error) {
                        console.warn('Error destroying peer:', error);
                    }
                    this.peer = null;
                }
                
                // Close all connections
                this.connections.forEach((conn, peerId) => {
                    try {
                        conn.close();
                    } catch (error) {
                        console.warn(`Error closing connection to ${peerId}:`, error);
                    }
                });
                this.connections.clear();
                
                console.log('✅ Resource cleanup completed');
            }
            
            cleanupCanvasEventListeners() {
                this.canvasEventListeners.forEach(({ element, event, handler, options }) => {
                    try {
                        element.removeEventListener(event, handler, options);
                    } catch (error) {
                        console.warn('Error removing canvas event listener:', error);
                    }
                });
                this.canvasEventListeners = [];
            }
            
            addCanvasEventListener(element, event, handler, options = {}) {
                element.addEventListener(event, handler, options);
                this.canvasEventListeners.push({ element, event, handler, options });
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas(); 
                this.checkForRoomInURL();
                this.populateColorPalette();
                
                // Test device performance
                this.testDevicePerformance();
            }
            
            // Test device performance and adjust settings accordingly
            testDevicePerformance() {
                const testCanvas = document.createElement('canvas');
                testCanvas.width = 500;
                testCanvas.height = 500;
                const testCtx = testCanvas.getContext('2d');
                
                const startTime = performance.now();
                
                // Perform drawing operations to test performance
                for (let i = 0; i < 100; i++) {
                    testCtx.beginPath();
                    testCtx.arc(
                        Math.random() * 500,
                        Math.random() * 500,
                        Math.random() * 50,
                        0,
                        2 * Math.PI
                    );
                    testCtx.fillStyle = `hsl(${Math.random() * 360}, 50%, 50%)`;
                    testCtx.fill();
                }
                
                const duration = performance.now() - startTime;
                
                // Adjust settings based on performance
                if (duration > 50) {
                    // Slow device - reduce network update frequency
                    this.networkUpdateInterval = 100;
                    debugLog('⚠️ Slow device detected, adjusting performance settings');
                } else if (duration < 20) {
                    // Fast device - increase network update frequency for better responsiveness
                    this.networkUpdateInterval = 30;
                    debugLog('⚡ Fast device detected, optimizing for best quality');
                }
                
                debugLog(`📊 Device performance test: ${duration.toFixed(2)}ms`);
            }

            hideLoading() {
                this.createManagedTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 500);
            }

            populateColorPalette() {
                const palette = document.getElementById('color-palette');
                if (!palette) {
                    console.warn('Color palette element not found');
                    return;
                }
                
                palette.innerHTML = '';
                this.playerColors.forEach((color, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'color-btn w-10 h-10 rounded-full border-2 border-transparent transition-all transform hover:scale-110';
                    btn.style.backgroundColor = color;
                    btn.dataset.color = color;
                    btn.title = `Color ${index + 1}`;
                    
                    // Select the first color (red) by default
                    if (index === 0) {
                        btn.classList.add('ring-2', 'ring-white', 'border-white');
                        this.currentColor = color;
                        console.log('Selected default color:', color);
                    }
                    
                    btn.addEventListener('click', () => this.selectColor(color));
                    palette.appendChild(btn);
                });
                
                console.log('Color palette populated with', this.playerColors.length, 'colors');
            }
            
            selectColor(color) {
                this.currentColor = color;
                this.currentTool = 'brush';
                
                // Update UI to show selected color
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.remove('ring-2', 'ring-white', 'border-white');
                });
                
                const selectedBtn = document.querySelector(`[data-color="${color}"]`);
                if (selectedBtn) {
                    selectedBtn.classList.add('ring-2', 'ring-white', 'border-white');
                }
                
                console.log('Selected color:', color);
            }
            
            selectBrush(size) {
                this.currentSize = size;
                this.currentTool = 'brush';
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('btn-primary'));
                if (size === 2) document.getElementById('brush-small').classList.add('btn-primary');
                if (size === 5) document.getElementById('brush-medium').classList.add('btn-primary');
                if (size === 10) document.getElementById('brush-large').classList.add('btn-primary');
            }
            
            selectEraser() {
                this.currentTool = 'eraser';
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('btn-primary'));
                document.getElementById('eraser').classList.add('btn-primary');
            }
            
            // Optimized canvas clearing
            clearCanvas(broadcast = true) {
                const canvas = document.getElementById('drawing-canvas');
                if (!canvas) {
                    console.warn('Canvas not found for clearing');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                
                // Get the actual display dimensions
                const rect = canvas.getBoundingClientRect();
                
                // Clear the entire canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Fill with white background - use display dimensions
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                console.log('Canvas cleared and filled white:', rect.width, 'x', rect.height);
                
                // Clear drawing buffer
                this.drawingBuffer = [];
                
                // Reset drawing history
                this.drawingHistory.clear();
                this.drawingHistory.saveState(canvas);
                
                // In the new game mode, we don't broadcast individual drawing actions
                // Each player draws independently
            }
            
            undo() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                this.drawingHistory.undo(canvas, ctx);
            }
            
            redo() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                this.drawingHistory.redo(canvas, ctx);
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                let roomCode = null;
                if (path.includes('/draw-party-game/')) {
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) roomCode = parts[1];
                } else {
                    const parts = path.slice(1);
                    if (parts.length === 4) roomCode = parts;
                }
                if (roomCode) {
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                document.getElementById('join-code').addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                
                const submitName = () => {
                    this.playerName = document.getElementById('player-name').value.trim();
                    if (!this.playerName) return;
                    
                    console.log('Setting player name:', this.playerName, 'for player:', this.playerId);
                    
                    // Update local player data
                    this.gameState.players.set(this.playerId, { 
                        id: this.playerId, 
                        name: this.playerName, 
                        score: 0 
                    });
                    
                    // Send update to all players (including host)
                    this.broadcastMessage({ 
                        type: 'PLAYER_UPDATE', 
                        playerId: this.playerId, 
                        playerName: this.playerName 
                    });
                    
                    this.updatePlayersDisplay();
                    this.showToast(`Name set to: ${this.playerName}`, 'success');
                };
                document.getElementById('submit-name').addEventListener('click', submitName);
                document.getElementById('player-name').addEventListener('keypress', (e) => { if (e.key === 'Enter') submitName(); });

                document.getElementById('undo-btn').addEventListener('click', () => this.undo());
                document.getElementById('redo-btn').addEventListener('click', () => this.redo());
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(2));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(5));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(10));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            createRoom() {
                debugLog('CREATE_ROOM', 'Starting room creation', 'out');
                
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                debugLog('ROOM_CODE', `Generated: ${this.roomCode}`, 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('HOST_SETUP', 'Becoming host, creating peer', 'out');
                
                this.createHostPeer();
                this.showLobby();
                
                debugLog('ROOM_READY', 'Room created successfully', 'out');
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('👑 Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('🎯 Host peer opened with ID:', id);
                    debugLog('🌐 Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    debugLog('➕ Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('📞 Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('error', (err) => {
                    console.error('❌ Host peer error:', err);
                    debugLog('🔄 Attempting to recover host connection...');
                    this.updateConnectionStatus('Connection error - recovering...');
                    
                    setTimeout(() => {
                        if (this.peer && this.peer.destroyed) {
                            debugLog('🔄 Recreating host peer after error');
                            this.createHostPeer();
                        } else if (this.peer && this.peer.disconnected) {
                            debugLog('🔄 Reconnecting host peer');
                            this.peer.reconnect();
                        }
                    }, 2000);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('🔌 Host peer disconnected from server');
                    this.updateConnectionStatus('Disconnected - reconnecting...');
                    
                    setTimeout(() => {
                        if (this.peer && !this.peer.destroyed) {
                            debugLog('🔄 Attempting to reconnect host peer');
                            this.peer.reconnect();
                        }
                    }, 1000);
                });
                
                this.peer.on('close', () => {
                    debugLog('🔌 Host peer connection closed');
                });
            }
            
            joinRoom(code) {
                debugLog('JOIN_ROOM', `Attempting to join: ${code}`, 'out');
                
                this.roomCode = code;
                this.isHost = false;
                
                debugLog('PLAYER_SETUP', 'Set as player, looking for host', 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('PEER_INIT', 'Initializing peer connection', 'out');
                this.initializePeer();
                this.showLobby();
                
                debugLog('JOIN_COMPLETE', 'Join room setup complete', 'out');
            }
            
            initializePeer() {
                // Always attempt P2P connection
                if (!this.isHost) {
                    this.createPlayerPeer();
                }
            }
            
            createPlayerPeer() {
                debugLog('🎭 Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('🎯 Player peer opened with ID:', id);
                    debugLog('🌐 Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.error('❌ Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    // Fallback to becoming host if connection fails
                    this.becomeHost();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('📞 Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('🔌 Player peer disconnected');
                });
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('🔌 Attempting to connect to host:', hostId);
                
                const connectionTimeout = setTimeout(() => {
                    debugLog('⏰ Connection timeout - no host found.');
                    this.updateConnectionStatus('Host not found. The room may have been closed.');
                    this.showToast('Could not connect to the game room.', 'error');
                }, 8000);
                
                try {
                    debugLog('📞 Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        debugLog('✅ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.error('❌ Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Failed to connect to host.');
                        this.showToast('Error connecting to room.', 'error');
                    });
                    
                    conn.on('close', () => {
                        debugLog('🔌 Connection to host closed');
                    });
                    
                    conn.on('data', (data) => {
                        debugLog('📥 Data from host:', data);
                    });
                    
                } catch (error) {
                    console.error('💥 Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.updateConnectionStatus('Failed to connect to host.');
                    this.showToast('Error creating connection.', 'error');
                }
            }
            
            becomeHost() {
                if (this.isHost) return;
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                if (this.peer) {
                    this.peer.destroy();
                }
                
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    debugLog('🎯 becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    debugLog('➕ becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    debugLog('🔗 Connection established with:', conn.peer);
                    debugLog('🎭 I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    if (this.isHost) {
                        debugLog('📡 Host sending ROOM_JOINED to:', conn.peer);
                        this.sendToPlayer(conn.peer, { type: 'ROOM_JOINED', roomCode: this.roomCode });
                        setTimeout(() => {
                            debugLog('📡 Host also sending current game state to new player');
                            this.broadcastGameState();
                        }, 100);
                    } else {
                        debugLog('📡 Player sending PLAYER_JOIN to host:', conn.peer);
                        debugLog('🏷️ Player name at join time:', this.playerName, '(empty is normal)');
                        this.sendToPlayer(conn.peer, { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName || 'Player' });
                    }
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer, conn);
                });
                
                conn.on('close', () => {
                    debugLog('🔌 Connection closed with:', conn.peer);
                    this.connections.delete(conn.peer);
                    
                    if (this.isHost && this.gameState.players.has(conn.peer)) {
                        debugLog('➖ Removing disconnected player:', conn.peer);
                        this.gameState.players.delete(conn.peer);
                        this.broadcastGameState();
                    }
                    
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('❌ Connection error with', conn.peer, ':', err);
                    this.connections.delete(conn.peer);
                    this.updatePlayersDisplay();
                });
            }
            
            handleMessage(message, fromPeer, connection = null) {
                debugLog('📨 Received message:', message.type, 'from:', fromPeer);
                debugLog('📨 Message details:', message);
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        debugLog('🎯 Handling PLAYER_JOIN. I am host?', this.isHost);
                        debugLog('🎯 Player joining:', message.playerId, 'Name:', message.playerName);
                        debugLog('🎯 Current players before adding:', this.gameState.players.size);
                        if (this.isHost) {
                            debugLog('➕ Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true,
                                likes: 0
                            });
                            debugLog('✅ Player added! New player count:', this.gameState.players.size);
                            debugLog('📋 All players now:', Array.from(this.gameState.players.entries()));
                            debugLog('📡 Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            debugLog('👤 Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        console.log('Received PLAYER_UPDATE:', message.playerId, message.playerName);
                        
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                            console.log('Updated player:', player);
                        } else {
                            // Player doesn't exist yet, create them
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0
                            });
                            console.log('Created new player:', message.playerId, message.playerName);
                        }
                        
                        this.updatePlayersDisplay();
                        
                        if (this.isHost) {
                            console.log('Host broadcasting updated game state');
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'ROOM_JOINED':
                        debugLog('🎯 Received ROOM_JOINED from host - sending PLAYER_JOIN back');
                        if (!this.isHost) {
                            const playerJoinMessage = {
                                type: 'PLAYER_JOIN',
                                playerId: this.playerId,
                                playerName: this.playerName || 'Player'
                            };
                            debugLog('📡 Sending PLAYER_JOIN to host:', playerJoinMessage);
                            if (connection && connection.open) {
                                try {
                                    connection.send(playerJoinMessage);
                                    debugLog('✅ PLAYER_JOIN sent successfully via direct connection');
                                } catch (error) {
                                    console.error('❌ Failed to send PLAYER_JOIN:', error);
                                    this.sendToPlayer(fromPeer, playerJoinMessage);
                                }
                            } else {
                                debugLog('🔄 Using sendToPlayer fallback');
                                this.sendToPlayer(fromPeer, playerJoinMessage);
                            }
                        }
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        debugLog('📥 Received GAME_STATE_UPDATE:', message.gameState);
                        debugLog('🔍 Before update - players.size:', this.gameState.players.size);
                        
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            debugLog('🔄 Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                debugLog('➕ Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            debugLog('✅ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        if (message.gameState.playerDrawings && Array.isArray(message.gameState.playerDrawings)) {
                            this.gameState.playerDrawings.clear();
                            message.gameState.playerDrawings.forEach(([id, drawing]) => this.gameState.playerDrawings.set(id, drawing));
                        }
                        
                        if (message.gameState.drawingsCompleted && Array.isArray(message.gameState.drawingsCompleted)) {
                            this.gameState.drawingsCompleted = new Set(message.gameState.drawingsCompleted);
                        }
                        
                        // Sync voting options
                        if (message.gameState.votingOptions && Array.isArray(message.gameState.votingOptions)) {
                            this.gameState.votingOptions = message.gameState.votingOptions;
                        }
                        
                        const { players, guesses, votes, scores, playerPrompts, playerDrawings, drawingsCompleted, votingOptions, ...scalarState } = message.gameState;
                        
                        // Validate phase transition
                        const previousPhase = this.gameState.phase;
                        Object.assign(this.gameState, scalarState);
                        
                        if (previousPhase !== this.gameState.phase) {
                            console.log('🔄 Phase transition:', previousPhase, '→', this.gameState.phase);
                        }
                        
                        debugLog('📊 Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        if (message.clear) {
                            // Handle clear command
                            this.clearCanvas(false);
                        } else if (message.drawingData) {
                            // Handle compressed drawing data (more efficient)
                            this.updateCanvasFromData(message.drawingData);
                        } else if (message.imageData || message.canvasData) {
                            // Handle full canvas data (fallback)
                            this.updateCanvas(message.imageData || message.canvasData);
                        }
                        
                        // Track network latency
                        if (message.timestamp) {
                            this.performanceMetrics.networkLatency = performance.now() - message.timestamp;
                        }
                        break;
                        
                    case 'DRAWING_SUBMITTED':
                        if (this.isHost) {
                            console.log('Host received drawing from:', message.playerId);
                            this.gameState.playerDrawings.set(message.playerId, message.drawing);
                            this.gameState.drawingsCompleted.add(message.playerId);
                            
                            console.log('Drawings completed:', this.gameState.drawingsCompleted.size, '/', this.gameState.players.size);
                            console.log('Completed by:', Array.from(this.gameState.drawingsCompleted));
                            
                            // Update UI for all players
                            this.broadcastGameState();
                            
                            // Check if all drawings are submitted
                            if (this.gameState.drawingsCompleted.size >= this.gameState.players.size) {
                                console.log('All drawings submitted! Moving to guessing phase...');
                                this.endDrawingPhase();
                            }
                        }
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'LIKE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.likes.set(message.playerId, {
                                targetPlayerId: message.targetPlayerId,
                                guessText: message.guessText
                            });
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'HEARTBEAT':
                        debugLog(`💓 Heartbeat received from ${fromPeer}`);
                        if (this.isHost) {
                            this.sendToPlayer(fromPeer, {
                                type: 'HEARTBEAT_ACK',
                                timestamp: Date.now()
                            }, { waitForReady: false, retries: 0 });
                        }
                        break;
                        
                    case 'HEARTBEAT_ACK':
                        debugLog(`💓 Heartbeat ACK received from ${fromPeer}`);
                        break;
                        
                    case 'RESET_TO_LOBBY':
                        // Simple approach: reload the page to reset UI/state
                        window.location.reload();
                        break;
                }
            }
            
            sendToPlayer(playerId, message, options = {}) {
                const {
                    timeout = 5000,
                    retries = 2,
                    retryDelay = 1000,
                    waitForReady = true
                } = options;
                
                const startTime = Date.now();
                
                const createStatus = (success, details = {}) => ({
                    success,
                    playerId,
                    messageType: message.type,
                    timestamp: Date.now(),
                    duration: Date.now() - startTime,
                    ...details
                });
                
                const conn = this.connections.get(playerId);
                if (!conn) {
                    console.warn(`⚠️ No connection found for player: ${playerId}`);
                    return createStatus(false, { 
                        error: 'No connection found',
                        connectionExists: false
                    });
                }
                
                const validateConnection = () => {
                    if (!conn) return { valid: false, reason: 'Connection is null' };
                    if (conn.destroyed) return { valid: false, reason: 'Connection destroyed' };
                    if (!conn.open) return { valid: false, reason: 'Connection not open' };
                    return { valid: true };
                };
                
                const attemptSend = async (attempt = 0) => {
                    const validation = validateConnection();
                    
                    if (!validation.valid) {
                        console.warn(`⚠️ Connection to ${playerId} invalid: ${validation.reason}`);
                        
                        if (waitForReady && attempt < retries && validation.reason.includes('state')) {
                            debugLog(`🔄 Waiting for connection to be ready (attempt ${attempt + 1}/${retries + 1})`);
                            
                            const readyPromise = new Promise((resolve) => {
                                const checkReady = () => {
                                    const newValidation = validateConnection();
                                    if (newValidation.valid) {
                                        resolve(true);
                                    } else if (Date.now() - startTime > timeout) {
                                        resolve(false);
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                setTimeout(checkReady, retryDelay);
                            });
                            
                            const isReady = await readyPromise;
                            if (isReady) {
                                return attemptSend(attempt + 1);
                            }
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`📤 Message sent to ${playerId}:`, message.type);
                        
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            attemptsUsed: attempt + 1,
                            method: 'peerjs'
                        });
                        
                    } catch (error) {
                        console.error(`❌ Send attempt ${attempt + 1} failed to ${playerId}:`, error);
                        
                        if (attempt < retries) {
                            debugLog(`🔄 Retrying send to ${playerId} in ${retryDelay}ms`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return attemptSend(attempt + 1);
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                };
                
                if (waitForReady || retries > 0) {
                    return attemptSend();
                } else {
                    const validation = validateConnection();
                    if (!validation.valid) {
                        this.connections.delete(playerId);
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`📤 Message sent to ${playerId}:`, message.type);
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            method: 'peerjs'
                        });
                    } catch (error) {
                        console.error(`❌ Failed to send message to ${playerId}:`, error);
                        this.connections.delete(playerId);
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                }
            }
            
            async sendReliably(playerId, message, options = {}) {
                const defaultOptions = {
                    waitForReady: true,
                    retries: 2,
                    retryDelay: 500,
                    ...options
                };
                
                try {
                    const result = await this.sendToPlayer(playerId, message, defaultOptions);
                    
                    if (result.success) {
                        debugLog(`✅ Reliable send success to ${playerId}:`, result);
                        return result;
                    } else {
                        console.warn(`⚠️ Reliable send failed to ${playerId}:`, result);
                        if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                            this.showToast(`Failed to send ${message.type.toLowerCase()} - connection issue`, 'warning');
                        }
                        return result;
                    }
                } catch (error) {
                    console.error(`❌ Reliable send error to ${playerId}:`, error);
                    const errorResult = {
                        success: false,
                        error: error.message,
                        playerId,
                        messageType: message.type,
                        timestamp: Date.now()
                    };
                    
                    if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                        this.showToast(`Network error sending ${message.type.toLowerCase()}`, 'error');
                    }
                    return errorResult;
                }
            }
            
            attemptReconnection(playerId, oldConn) {
                console.warn(`Attempting to reconnect to ${playerId}...`);
                if (oldConn) {
                    try { oldConn.close(); } catch (e) { console.error("Error closing old connection:", e); }
                    try { oldConn.destroy(); } catch (e) { console.error("Error destroying old connection:", e); }
                }
                
                if (this.isHost) {
                    // Host doesn't actively reconnect to players, players reconnect to host
                    // Just remove the player from the game state
                    if (this.gameState.players.has(playerId)) {
                        this.gameState.players.delete(playerId);
                        this.broadcastGameState();
                        this.updatePlayersDisplay();
                    }
                } else {
                    // Player tries to reconnect to host
                    this.updateConnectionStatus('Reconnecting to host...');
                    this.createManagedTimeout(() => this.connectToHost(), 3000);
                }
            }
            
            broadcastMessage(message) {
                if (this.isHost) {
                    this.connections.forEach((conn, peerId) => {
                        if (peerId !== this.playerId) { // Don't send to self
                            this.sendToPlayer(peerId, message);
                        }
                    });
                } else {
                    // Players send messages to the host
                    const hostConn = this.connections.get(`${this.roomCode}_HOST`);
                    if (hostConn) {
                        this.sendToPlayer(`${this.roomCode}_HOST`, message);
                    } else {
                        console.warn('No host connection found to broadcast message.');
                    }
                }
            }
            
            broadcastGameState() {
                if (!this.isHost) return;
                
                const stateToBroadcast = {
                    ...this.gameState,
                    players: Array.from(this.gameState.players.entries()),
                    playerDrawings: Array.from(this.gameState.playerDrawings.entries()),
                    playerPrompts: Array.from(this.gameState.playerPrompts.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                    drawingsCompleted: Array.from(this.gameState.drawingsCompleted),
                    // Add missing votingOptions for proper sync
                    votingOptions: this.gameState.votingOptions || []
                };
                
                console.log('Broadcasting game state:', stateToBroadcast.phase, 'to', this.connections.size, 'players');
                
                this.connections.forEach((conn, peerId) => {
                    if (peerId !== this.playerId) { // Don't send to self
                        this.sendToPlayer(peerId, { type: 'GAME_STATE_UPDATE', gameState: stateToBroadcast });
                    }
                });
            }

            updateConnectionStatus(status) {
                // Check if connection status element exists, if not create it
                let statusElement = document.getElementById('connection-status');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'connection-status';
                    statusElement.className = 'text-sm text-gray-400 text-center mt-2';
                    const lobbyScreen = document.getElementById('lobby-screen');
                    if (lobbyScreen) {
                        lobbyScreen.appendChild(statusElement);
                    }
                }
                statusElement.textContent = status;
            }
            
            updateUI() {
                // Update UI based on current game state
                switch (this.gameState.phase) {
                    case 'LOBBY':
                        this.showLobby();
                        break;
                    case 'DRAWING':
                        this.showScreen('drawing-screen');
                        this.updateDrawingUI();
                        break;
                    case 'GUESSING':
                        this.startGuessingPhase();
                        break;
                    case 'VOTING':
                        this.startVotingPhase();
                        break;
                    case 'RESULTS':
                        this.showResults();
                        break;
                }
            }

            showScreen(screenId) {
                ['welcome-screen', 'lobby-screen', 'drawing-screen', 'guessing-screen', 'voting-screen', 'results-screen', 'final-scores-screen'].forEach(id => {
                    document.getElementById(id).classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            }

            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                this.updatePlayersDisplay();
            }

            updatePlayersDisplay() {
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                this.gameState.players.forEach(player => {
                    const playerEl = document.createElement('div');
                    playerEl.className = 'flex items-center justify-between p-3 bg-gray-800 rounded-lg';
                    playerEl.innerHTML = `<span class="font-bold text-lg">${player.name}</span><span class="text-gray-400">${player.score} pts</span>`;
                    playersList.appendChild(playerEl);
                });
                document.getElementById('start-game').disabled = this.gameState.players.size < this.gameConfig.gameplay.minPlayers;
            }
            
            shareGame() {
                const shareUrl = window.location.href;
                console.log('Sharing game URL:', shareUrl);
                
                if (navigator.share) {
                    navigator.share({
                        title: 'Draw Party!',
                        text: 'Join my Draw Party game!',
                        url: shareUrl,
                    }).then(() => {
                        console.log('Share successful');
                        this.showToast('Game shared successfully!', 'success');
                    }).catch((error) => {
                        console.error('Error sharing:', error);
                        // Fallback to clipboard
                        this.copyToClipboard(shareUrl);
                    });
                } else {
                    this.copyToClipboard(shareUrl);
                }
            }
            
            copyToClipboard(url) {
                navigator.clipboard.writeText(url).then(() => {
                    this.showToast('Game link copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Could not copy text:', err);
                    this.showToast('Failed to copy link. Please copy manually: ' + url, 'error');
                });
            }

            startGame() {
                if (!this.isHost) return;
                if (this.gameState.players.size < this.gameConfig.gameplay.minPlayers) {
                    this.showToast(`Need at least ${this.gameConfig.gameplay.minPlayers} players to start!`, 'warning');
                    return;
                }
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.broadcastMessage({ type: 'START_GAME' });
                this.startDrawingPhase();
            }
            
            handleStartGame() {
                // Called when receiving START_GAME message
                console.log('📢 Received START_GAME message');
                this.gameState.phase = 'DRAWING';
                this.startDrawingPhase();
            }
            
            submitDrawing() {
                // Check if already submitted
                if (this.gameState.drawingsCompleted.has(this.playerId)) {
                    console.log('Drawing already submitted');
                    this.showToast('Drawing already submitted!', 'warning');
                    return;
                }
                
                // Check if we're in the right phase
                if (this.gameState.phase !== 'DRAWING') {
                    console.warn('Not in drawing phase, cannot submit');
                    this.showToast('Can only submit during drawing phase', 'warning');
                    return;
                }
                
                // Save the drawing
                const canvas = document.getElementById('drawing-canvas');
                if (!canvas) {
                    console.error('Canvas not found for drawing submission');
                    this.showToast('Error: Canvas not found', 'error');
                    return;
                }
                
                try {
                    const drawingData = canvas.toDataURL('image/webp', 0.8);
                    console.log('Submitting drawing for player:', this.playerId);
                    
                    // Send drawing to host with error handling
                    const message = {
                        type: 'DRAWING_SUBMITTED',
                        playerId: this.playerId,
                        drawing: drawingData,
                        timestamp: Date.now()
                    };
                    
                    if (this.isHost) {
                        // Host handles their own submission
                        this.handleMessage(message, this.playerId);
                    } else {
                        // Send to host
                        this.broadcastMessage(message);
                    }
                    
                    // Mark as completed locally (will be synced by host)
                    this.gameState.drawingsCompleted.add(this.playerId);
                    
                    // Update UI immediately
                    this.updateDrawingUI();
                    
                    // Disable drawing tools
                    const toolsElement = document.getElementById('drawing-tools');
                    const submitButton = document.getElementById('submit-drawing');
                    
                    if (toolsElement) toolsElement.style.display = 'none';
                    if (submitButton) {
                        submitButton.disabled = true;
                        submitButton.textContent = 'Drawing Submitted! ✓';
                        submitButton.classList.remove('btn-secondary');
                        submitButton.classList.add('bg-green-600', 'hover:bg-green-700');
                    }
                    
                    this.showToast('Drawing submitted successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error submitting drawing:', error);
                    this.showToast('Failed to submit drawing. Please try again.', 'error');
                }
            }
            
            endDrawingPhase() {
                console.log('🎨 Drawing phase ended');
                
                // Auto-submit drawing if not already submitted
                if (!this.gameState.drawingsCompleted.has(this.playerId)) {
                    console.log('Auto-submitting drawing for player:', this.playerId);
                    this.submitDrawing();
                }
                
                if (this.isHost) {
                    // Check if we have enough drawings to continue
                    if (this.gameState.drawingsCompleted.size === 0) {
                        console.warn('No drawings submitted! Cannot continue.');
                        this.showToast('No drawings were submitted. Game cannot continue.', 'error');
                        return;
                    }
                    
                    // Wait a bit for final submissions, then start guessing rounds
                    this.createManagedTimeout(() => {
                        console.log('Host starting guessing rounds...');
                        console.log('Total drawings completed:', this.gameState.drawingsCompleted.size);
                        console.log('Total players:', this.gameState.players.size);
                        this.startGuessingRounds();
                    }, 3000);
                }
            }
            
            startGuessingRounds() {
                if (!this.isHost) return;
                
                console.log('🎯 Starting guessing rounds. Remaining drawings:', this.gameState.roundOrder.length);
                
                // Get the first drawing to show
                if (this.gameState.roundOrder.length > 0) {
                    this.gameState.currentViewingPlayer = this.gameState.roundOrder.shift();
                    this.gameState.currentViewingDrawing = this.gameState.playerDrawings.get(this.gameState.currentViewingPlayer);
                    this.gameState.currentViewingPrompt = this.gameState.playerPrompts.get(this.gameState.currentViewingPlayer);
                    
                    console.log('📋 Now viewing:', {
                        player: this.gameState.currentViewingPlayer,
                        prompt: this.gameState.currentViewingPrompt,
                        hasDrawing: !!this.gameState.currentViewingDrawing
                    });
                    
                    this.gameState.phase = 'GUESSING';
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    this.broadcastGameState();
                    
                    this.startGuessingPhase();
                } else {
                    // All drawings shown, go to final results
                    console.log('🏆 All drawings shown, showing final results');
                    this.showFinalResults();
                }
            }

            startDrawingPhase() {
                console.log('🎨 Starting drawing phase');
                this.gameState.phase = 'DRAWING';
                this.showScreen('drawing-screen');
                
                // Wait for screen to be visible, then setup canvas
                this.createManagedTimeout(() => {
                    console.log('Initializing canvas for drawing phase...');
                    this.drawingHistory.clear();
                    this.clearCanvas(false);
                    
                    // Force canvas refresh
                    const canvas = document.getElementById('drawing-canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        const rect = canvas.getBoundingClientRect();
                        
                        // Ensure white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, rect.width, rect.height);
                        
                        console.log('Canvas ready for drawing:', rect.width, 'x', rect.height);
                    }
                }, 200);
                
                if (this.isHost) {
                    // Clear previous round data
                    this.gameState.playerDrawings.clear();
                    this.gameState.drawingsCompleted.clear();
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    
                    // Assign unique prompts to each player
                    const players = Array.from(this.gameState.players.keys());
                    const shuffledPrompts = [...this.prompts].sort(() => Math.random() - 0.5);
                    
                    console.log('🎯 Assigning prompts to players:', players);
                    
                    players.forEach((playerId, index) => {
                        const prompt = shuffledPrompts[index % shuffledPrompts.length];
                        this.gameState.playerPrompts.set(playerId, prompt);
                        console.log(`Player ${playerId} gets prompt: ${prompt}`);
                    });
                    
                    // Create random order for showing drawings
                    this.gameState.roundOrder = [...players].sort(() => Math.random() - 0.5);
                    
                    console.log('🎯 Round order:', this.gameState.roundOrder);
                    console.log('🎯 Player prompts assigned:', this.gameState.playerPrompts);
                    this.broadcastGameState();
                } else {
                    console.log('Waiting for host to assign prompts...');
                }
                
                this.updateDrawingUI();
                this.startTimer(this.gameConfig.timers.drawing, () => this.endDrawingPhase());
            }




            
            startGuessingPhase() {
                console.log('🤔 Starting guessing phase for player:', this.gameState.currentViewingPlayer);
                this.showScreen('guessing-screen');
                
                // Load the current viewing drawing
                const guessCanvas = document.getElementById('guess-canvas');
                const guessCtx = guessCanvas.getContext('2d');
                
                // Set canvas size
                const container = guessCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                guessCanvas.width = container.clientWidth * dpr;
                guessCanvas.height = container.clientHeight * dpr;
                guessCtx.scale(dpr, dpr);
                
                // Load drawing from data URL
                if (this.gameState.currentViewingDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        guessCtx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
                        guessCtx.drawImage(img, 0, 0, guessCanvas.width / dpr, guessCanvas.height / dpr);
                    };
                    img.onerror = () => {
                        console.error('Failed to load guessing canvas image');
                        // Fill with white background as fallback
                        guessCtx.fillStyle = 'white';
                        guessCtx.fillRect(0, 0, guessCanvas.width / dpr, guessCanvas.height / dpr);
                    };
                    img.src = this.gameState.currentViewingDrawing;
                } else {
                    console.warn('No drawing data for guessing phase');
                    // Fill with white background as fallback
                    guessCtx.fillStyle = 'white';
                    guessCtx.fillRect(0, 0, guessCanvas.width / dpr, guessCanvas.height / dpr);
                }
                
                // Update UI - hide artist name if it's the guesser's own drawing
                const artistName = this.gameState.players.get(this.gameState.currentViewingPlayer)?.name || 'Unknown';
                const artistNameElement = document.getElementById('artist-name');
                
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    artistNameElement.textContent = 'This is your drawing - watch others guess!';
                    document.getElementById('guess-input').style.display = 'none';
                    document.getElementById('submit-guess').style.display = 'none';
                } else {
                    artistNameElement.textContent = `What do you think this is?`;
                    const guessInput = document.getElementById('guess-input');
                    const submitBtn = document.getElementById('submit-guess');
                    
                    guessInput.style.display = 'block';
                    submitBtn.style.display = 'block';
                    guessInput.value = '';
                    guessInput.disabled = false;
                    submitBtn.disabled = false;
                    
                    // Focus the input for better UX
                    setTimeout(() => guessInput.focus(), 100);
                }
                
                this.startTimer(this.gameConfig.timers.guessing, () => this.endGuessingPhase());
            }

            submitGuess() {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();
                
                if (!guess) {
                    this.showToast('Please enter a guess!', 'warning');
                    return;
                }
                
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    this.showToast('You cannot guess your own drawing!', 'warning');
                    return;
                }
                
                // Send guess to host
                this.broadcastMessage({
                    type: 'GUESS_SUBMITTED',
                    playerId: this.playerId,
                    guess: guess
                });
                
                guessInput.disabled = true;
                document.getElementById('submit-guess').disabled = true;
                this.showToast('Guess submitted!', 'success');
            }
            
            endGuessingPhase() {
                console.log('🤔 Guessing phase ended');
                
                // Clear timer first
                this.clearTimer();
                
                if (this.isHost) {
                    // Validate phase transition
                    if (this.gameState.phase !== 'GUESSING') {
                        console.warn('⚠️ EndGuessingPhase called but not in GUESSING phase:', this.gameState.phase);
                        return;
                    }
                    
                    this.gameState.phase = 'VOTING';
                    this.prepareVotingOptions();
                    
                    // Check if we have any voting options
                    if (this.gameState.votingOptions.length === 0) {
                        console.warn('No voting options available! Adding correct answer only.');
                        this.gameState.votingOptions = [{
                            text: this.gameState.currentViewingPrompt,
                            playerId: 'CORRECT',
                            playerName: 'The Truth'
                        }];
                    }
                    
                    this.broadcastGameState();
                }
                this.startVotingPhase();
            }
            
            prepareVotingOptions() {
                // Get all submitted guesses
                const guesses = Array.from(this.gameState.guesses.entries());
                console.log('Preparing voting options from guesses:', guesses);
                
                // Add the correct answer
                const correctAnswer = this.gameState.currentViewingPrompt;
                if (!correctAnswer) {
                    console.error('No correct answer available for voting!');
                    this.gameState.votingOptions = [];
                    return;
                }
                
                // Create voting options - include all unique guesses plus the correct answer
                const allGuesses = guesses.map(([playerId, guess]) => ({
                    text: guess?.trim() || 'Empty Guess',
                    playerId: playerId,
                    playerName: this.gameState.players.get(playerId)?.name || 'Unknown'
                })).filter(option => option.text && option.text !== 'Empty Guess');
                
                // Add correct answer if no one guessed it exactly
                const hasCorrectAnswer = allGuesses.some(g => 
                    g.text.toLowerCase().trim() === correctAnswer.toLowerCase().trim()
                );
                
                if (!hasCorrectAnswer) {
                    allGuesses.push({
                        text: correctAnswer,
                        playerId: 'CORRECT',
                        playerName: 'The Truth'
                    });
                }
                
                // Handle case where there are no guesses
                if (allGuesses.length === 0) {
                    console.warn('No guesses submitted, only showing correct answer');
                    allGuesses.push({
                        text: correctAnswer,
                        playerId: 'CORRECT',
                        playerName: 'The Truth'
                    });
                }
                
                // Remove duplicates and shuffle
                const uniqueOptions = [];
                const seenTexts = new Set();
                
                for (const option of allGuesses) {
                    const normalizedText = option.text.toLowerCase().trim();
                    if (!seenTexts.has(normalizedText) && normalizedText.length > 0) {
                        seenTexts.add(normalizedText);
                        uniqueOptions.push(option);
                    }
                }
                
                this.gameState.votingOptions = uniqueOptions.sort(() => Math.random() - 0.5);
                this.gameState.correctAnswer = correctAnswer;
                
                console.log('Voting options prepared:', this.gameState.votingOptions);
            }
            
            startVotingPhase() {
                console.log('🗳️ Starting voting phase');
                this.showScreen('voting-screen');
                
                // Load the current viewing drawing (same as guessing phase)
                const voteCanvas = document.getElementById('vote-canvas');
                const voteCtx = voteCanvas.getContext('2d');
                
                // Set canvas size
                const container = voteCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                voteCanvas.width = container.clientWidth * dpr;
                voteCanvas.height = container.clientHeight * dpr;
                voteCtx.scale(dpr, dpr);
                
                // Load drawing from data URL (not from drawing canvas)
                if (this.gameState.currentViewingDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        voteCtx.clearRect(0, 0, voteCanvas.width, voteCanvas.height);
                        voteCtx.drawImage(img, 0, 0, voteCanvas.width / dpr, voteCanvas.height / dpr);
                    };
                    img.onerror = () => {
                        console.error('Failed to load voting canvas image');
                        // Fill with white background as fallback
                        voteCtx.fillStyle = 'white';
                        voteCtx.fillRect(0, 0, voteCanvas.width / dpr, voteCanvas.height / dpr);
                    };
                    img.src = this.gameState.currentViewingDrawing;
                } else {
                    console.warn('No drawing data for voting phase');
                    // Fill with white background as fallback
                    voteCtx.fillStyle = 'white';
                    voteCtx.fillRect(0, 0, voteCanvas.width / dpr, voteCanvas.height / dpr);
                }
                
                // Create voting options
                this.createVotingButtons();
                
                this.startTimer(this.gameConfig.timers.voting, () => this.endVotingPhase());
            }
            
            createVotingButtons() {
                const container = document.getElementById('voting-options');
                container.innerHTML = '';
                
                this.gameState.votingOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full btn btn-primary text-lg p-4 mb-2';
                    button.innerHTML = `
                        <div class="text-lg font-bold">${option.text}</div>
                        ${option.playerId !== 'CORRECT' ? `<div class="text-sm text-gray-300">by ${option.playerName}</div>` : ''}
                    `;
                    button.addEventListener('click', () => this.submitVote(option));
                    container.appendChild(button);
                });
            }
            
            submitVote(selectedOption) {
                // Artist cannot vote on their own drawing
                if (this.gameState.currentViewingPlayer === this.playerId) {
                    this.showToast('You cannot vote on your own drawing!', 'warning');
                    return;
                }
                
                // Can't vote for your own guess
                if (selectedOption.playerId === this.playerId) {
                    this.showToast('You cannot vote for your own guess!', 'warning');
                    return;
                }
                
                this.broadcastMessage({
                    type: 'VOTE_SUBMITTED',
                    playerId: this.playerId,
                    vote: selectedOption
                });
                
                // Disable all voting buttons
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.querySelector('.text-lg').textContent === selectedOption.text) {
                        btn.classList.add('bg-green-600');
                    }
                });
                
                this.showToast('Vote submitted!', 'success');
            }
            
            endVotingPhase() {
                console.log('🗳️ Voting phase ended');
                
                // Clear timer first
                this.clearTimer();
                
                if (this.isHost) {
                    // Validate phase transition
                    if (this.gameState.phase !== 'VOTING') {
                        console.warn('⚠️ EndVotingPhase called but not in VOTING phase:', this.gameState.phase);
                        return;
                    }
                    
                    this.calculateResults();
                    this.gameState.phase = 'RESULTS';
                    this.broadcastGameState();
                }
                this.showResults();
            }
            
            calculateResults() {
                const correctAnswer = this.gameState.correctAnswer;
                const votes = Array.from(this.gameState.votes.entries());
                const guesses = Array.from(this.gameState.guesses.entries());
                
                // Track who voted for what
                const votesByOption = new Map();
                let correctVoters = [];
                
                votes.forEach(([playerId, vote]) => {
                    const voteText = vote.text.toLowerCase();
                    
                    // Check if this was a correct vote
                    if (voteText === correctAnswer.toLowerCase()) {
                        correctVoters.push(playerId);
                        // Give points for correct guess
                        const currentScore = this.gameState.scores.get(playerId) || 0;
                        this.gameState.scores.set(playerId, currentScore + 100);
                    }
                    
                    // Track votes for scoring fake answers
                    if (vote.playerId !== 'CORRECT' && vote.playerId !== playerId) {
                        if (!votesByOption.has(vote.playerId)) {
                            votesByOption.set(vote.playerId, []);
                        }
                        votesByOption.get(vote.playerId).push(playerId);
                    }
                });
                
                // Give points to players whose fake answers got votes
                votesByOption.forEach((voters, guesserId) => {
                    const pointsPerVote = 50;
                    const totalPoints = voters.length * pointsPerVote;
                    const currentScore = this.gameState.scores.get(guesserId) || 0;
                    this.gameState.scores.set(guesserId, currentScore + totalPoints);
                });
                
                // Artist (drawing owner) gets points based on correct guesses
                const artistId = this.gameState.currentViewingPlayer;
                const totalVoters = votes.length;
                if (totalVoters > 0 && correctVoters.length > 0) {
                    const artistPoints = Math.round((correctVoters.length / totalVoters) * 150);
                    const currentArtistScore = this.gameState.scores.get(artistId) || 0;
                    this.gameState.scores.set(artistId, currentArtistScore + artistPoints);
                }
                
                this.gameState.roundResults = {
                    correctAnswer,
                    artistId,
                    correctVoters,
                    totalVoters: votes.length,
                    votes: votes,
                    guesses: guesses,
                    votesByOption
                };
            }
            
            showResults() {
                console.log('🎉 Showing results');
                this.showScreen('results-screen');
                
                const container = document.getElementById('results-content');
                const results = this.gameState.roundResults;
                
                if (!results) {
                    console.error('No results data available!');
                    container.innerHTML = '<div class="card text-center"><h3>Error: No results available</h3></div>';
                    return;
                }
                
                const artistName = this.gameState.players.get(results.artistId)?.name || 'Unknown';
                
                // Build who voted for what display
                let votesDisplay = '<div class="mt-4">';
                this.gameState.votingOptions.forEach(option => {
                    const voters = Array.from(results.votes.entries())
                        .filter(([_, vote]) => vote.text === option.text)
                        .map(([playerId, _]) => this.gameState.players.get(playerId)?.name || 'Unknown');
                    
                    const isCorrect = option.text.toLowerCase() === results.correctAnswer.toLowerCase();
                    votesDisplay += `
                        <div class="mb-3 p-3 rounded ${isCorrect ? 'bg-green-800' : 'bg-gray-800'}">
                            <div class="font-bold ${isCorrect ? 'text-green-400' : ''}">${option.text}</div>
                            ${option.playerId !== 'CORRECT' ? `<div class="text-sm text-gray-400">Guessed by ${option.playerName}</div>` : ''}
                            <div class="text-sm mt-1">Voted by: ${voters.length > 0 ? voters.join(', ') : 'Nobody'}</div>
                        </div>
                    `;
                });
                votesDisplay += '</div>';
                
                container.innerHTML = `
                    <div class="card text-center mb-4">
                        <h3 class="text-2xl font-bold mb-2">The correct answer was:</h3>
                        <div class="text-4xl font-bold text-green-400">${results.correctAnswer}</div>
                        <div class="text-lg text-gray-400 mt-2">Drawing by ${artistName}</div>
                    </div>
                    
                    <div class="card mb-4">
                        <h4 class="text-xl font-bold mb-2">Who voted for what:</h4>
                        ${votesDisplay}
                    </div>
                    
                    <div class="card mb-4">
                        <h4 class="text-xl font-bold mb-2">Points this round:</h4>
                        <p class="text-lg">${results.correctVoters.length}/${results.totalVoters} players guessed correctly</p>
                    </div>
                `;
                
                // Handle progression - only auto-advance if there are more drawings in the current round
                if (this.isHost) {
                    if (this.gameState.roundOrder.length > 0) {
                        // More drawings to show in this round - auto advance after short delay
                        setTimeout(() => {
                            console.log('Auto-advancing to next drawing in round');
                            this.startGuessingRounds();
                        }, 3000);
                    } else {
                        // All drawings shown for this round
                        console.log('Round complete - waiting for user input');
                        
                        // Add appropriate button
                        const buttonContainer = document.createElement('div');
                        buttonContainer.className = 'text-center mt-6';
                        
                        if (this.gameState.currentRound >= this.gameState.totalRounds) {
                            // Game over
                            const finalBtn = document.createElement('button');
                            finalBtn.className = 'btn btn-primary text-xl';
                            finalBtn.textContent = '🏆 View Final Results';
                            finalBtn.addEventListener('click', () => this.showFinalResults());
                            buttonContainer.appendChild(finalBtn);
                        } else {
                            // More rounds to play
                            const nextBtn = document.createElement('button');
                            nextBtn.className = 'btn btn-primary text-xl';
                            nextBtn.textContent = `Round ${this.gameState.currentRound + 1} 🎨`;
                            nextBtn.addEventListener('click', () => this.nextRound());
                            buttonContainer.appendChild(nextBtn);
                        }
                        
                        container.appendChild(buttonContainer);
                    }
                }
            }
            
            // Removed unused updateScoresDisplay method - scores are shown in results/final screens

            nextRound() {
                if (!this.isHost) return;
                
                this.gameState.currentRound++;
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                
                this.broadcastMessage({ type: 'START_GAME' });
                this.startDrawingPhase();
            }
            
            showFinalResults() {
                console.log('🏆 Showing final results');
                this.showScreen('final-scores-screen');
                
                const container = document.getElementById('final-scores-content');
                const scores = Array.from(this.gameState.scores.entries())
                    .map(([playerId, score]) => ({
                        playerId,
                        name: this.gameState.players.get(playerId)?.name || 'Unknown',
                        score
                    }))
                    .sort((a, b) => b.score - a.score);
                
                if (scores.length === 0) {
                    console.warn('No scores available for final results');
                    container.innerHTML = `
                        <div class="card text-center">
                            <h3 class="text-3xl font-bold mb-4">🎉 Game Complete!</h3>
                            <p class="text-lg">No scores were recorded during this game.</p>
                        </div>
                    `;
                    return;
                }
                
                const winner = scores[0];
                
                container.innerHTML = `
                    <div class="card text-center mb-6">
                        <h3 class="text-3xl font-bold mb-4">🏆 ${winner.name} Wins!</h3>
                        <div class="text-6xl font-bold text-yellow-400">${winner.score}</div>
                        <div class="text-lg text-gray-400">points</div>
                    </div>
                    
                    <div class="card">
                        <h4 class="text-xl font-bold mb-4">Final Scores:</h4>
                        ${scores.map((player, index) => 
                            `<div class="flex justify-between items-center p-3 ${index === 0 ? 'bg-yellow-600' : 'bg-gray-700'} rounded mb-2">
                                <span class="flex items-center">
                                    <span class="text-2xl mr-3">${index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '🏅'}</span>
                                    <span class="font-bold">${player.name}</span>
                                </span>
                                <span class="text-xl font-bold">${player.score}</span>
                            </div>`
                        ).join('')}
                    </div>
                `;
            }

            playAgain() {
                if (!this.isHost) return;
                
                // Reset game state for new game
                this.gameState.currentRound = 0;
                this.gameState.phase = 'LOBBY';
                this.gameState.playerDrawings.clear();
                this.gameState.playerPrompts.clear();
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                this.gameState.scores.clear();
                this.gameState.drawingsCompleted.clear();
                this.gameState.currentViewingPlayer = null;
                this.gameState.currentViewingDrawing = null;
                this.gameState.currentViewingPrompt = '';
                this.gameState.roundOrder = [];
                
                // Reset all player scores
                this.gameState.players.forEach((player, playerId) => {
                    player.score = 0;
                    this.gameState.players.set(playerId, player);
                });
                
                // Inform all clients to return to the lobby for a fresh start
                this.broadcastMessage({ type: 'RESET_TO_LOBBY' });
                this.broadcastGameState();
                this.showLobby();
            }
            
            checkAllGuessesSubmitted() {
                // Check if all non-artist players have submitted guesses
                const nonArtistPlayers = Array.from(this.gameState.players.keys())
                    .filter(playerId => playerId !== this.gameState.currentViewingPlayer);
                const submittedGuesses = Array.from(this.gameState.guesses.keys());
                
                console.log(`📝 Guesses: ${submittedGuesses.length}/${nonArtistPlayers.length}`);
                console.log('📝 Non-artist players:', nonArtistPlayers);
                console.log('📝 Submitted guesses:', submittedGuesses);
                
                // Handle edge case where there are no non-artist players
                if (nonArtistPlayers.length === 0) {
                    console.log('📝 No players to guess (only artist), advancing to voting');
                    this.createManagedTimeout(() => this.endGuessingPhase(), 1000);
                    return;
                }
                
                if (submittedGuesses.length >= nonArtistPlayers.length) {
                    console.log('📝 All guesses submitted, advancing to voting');
                    // Small delay to let UI update
                    this.createManagedTimeout(() => this.endGuessingPhase(), 1000);
                }
            }
            
            checkAllVotesSubmitted() {
                // Check if all non-artist players have submitted votes
                const nonArtistPlayers = Array.from(this.gameState.players.keys())
                    .filter(playerId => playerId !== this.gameState.currentViewingPlayer);
                const submittedVotes = Array.from(this.gameState.votes.keys());
                
                console.log(`🗳️ Votes: ${submittedVotes.length}/${nonArtistPlayers.length}`);
                console.log('🗳️ Non-artist players:', nonArtistPlayers);
                console.log('🗳️ Submitted votes:', submittedVotes);
                
                // Handle edge case where there are no non-artist players
                if (nonArtistPlayers.length === 0) {
                    console.log('🗳️ No players to vote (only artist), showing results');
                    this.createManagedTimeout(() => this.endVotingPhase(), 1000);
                    return;
                }
                
                if (submittedVotes.length >= nonArtistPlayers.length) {
                    console.log('🗳️ All votes submitted, showing results');
                    // Small delay to let UI update
                    this.createManagedTimeout(() => this.endVotingPhase(), 1000);
                }
            }

            newGame() {
                window.location.href = window.location.pathname;
            }

            showToast(message, type) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast shadow-lg px-6 py-3 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white`;
                toast.classList.remove('hidden');
                this.createManagedTimeout(() => toast.classList.add('hidden'), 3000);
            }

            // Memory leak prevention test method
            testMemoryLeakPrevention() {
                console.log('🧪 Testing memory leak prevention...');
                
                const initialCounts = {
                    eventListeners: this.eventListeners.length,
                    canvasEventListeners: this.canvasEventListeners.length,
                    activeTimeouts: this.activeTimeouts.size,
                    activeIntervals: this.activeIntervals.size
                };
                
                console.log('📊 Initial resource counts:', initialCounts);
                
                // Create some test resources
                this.addManagedEventListener(document, 'test-event', () => {});
                this.createManagedTimeout(() => {}, 5000);
                this.createManagedInterval(() => {}, 1000);
                
                const afterCreationCounts = {
                    eventListeners: this.eventListeners.length,
                    canvasEventListeners: this.canvasEventListeners.length,
                    activeTimeouts: this.activeTimeouts.size,
                    activeIntervals: this.activeIntervals.size
                };
                
                console.log('📊 After creation counts:', afterCreationCounts);
                
                // Test cleanup
                this.cleanup();
                
                const afterCleanupCounts = {
                    eventListeners: this.eventListeners.length,
                    canvasEventListeners: this.canvasEventListeners.length,
                    activeTimeouts: this.activeTimeouts.size,
                    activeIntervals: this.activeIntervals.size
                };
                
                console.log('📊 After cleanup counts:', afterCleanupCounts);
                
                const cleanupSuccessful = 
                    afterCleanupCounts.eventListeners === 0 &&
                    afterCleanupCounts.canvasEventListeners === 0 &&
                    afterCleanupCounts.activeTimeouts === 0 &&
                    afterCleanupCounts.activeIntervals === 0;
                
                console.log(cleanupSuccessful ? '✅ Memory leak prevention test PASSED' : '❌ Memory leak prevention test FAILED');
                
                return cleanupSuccessful;
            }

            // Timer System
            startTimer(seconds, onComplete) {
                // Always clear any existing timer first
                this.clearTimer();
                
                let timeLeft = seconds;
                this.updateTimerDisplay(timeLeft);
                console.log(`⏰ Starting timer: ${seconds} seconds`);
                
                this.currentTimer = this.createManagedInterval(() => {
                    timeLeft--;
                    this.updateTimerDisplay(timeLeft);
                    
                    if (timeLeft <= 0) {
                        console.log('⏰ Timer completed');
                        this.clearTimer();
                        onComplete();
                    }
                }, 1000);
            }
            
            clearTimer() {
                if (this.currentTimer) {
                    this.clearManagedInterval(this.currentTimer);
                    this.currentTimer = null;
                    console.log('⏰ Timer cleared');
                }
            }
            
            updateTimerDisplay(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeString = `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                // Update all timer displays
                const timerElements = ['drawing-timer', 'guessing-timer', 'voting-timer'];
                timerElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element && !element.classList.contains('hidden')) {
                        element.textContent = timeString;
                        
                        // Add urgency styling for last 10 seconds
                        if (seconds <= 10) {
                            element.classList.add('text-red-500', 'animate-pulse');
                        } else {
                            element.classList.remove('text-red-500', 'animate-pulse');
                        }
                    }
                });
            }
            
                        // Drawing UI Updates
            updateDrawingUI() {
                console.log('Updating drawing UI...');
                console.log('Current game phase:', this.gameState.phase);
                console.log('Player prompts:', this.gameState.playerPrompts);
                console.log('My player ID:', this.playerId);
                
                const promptElement = document.getElementById('drawing-prompt');
                const toolsElement = document.getElementById('drawing-tools');
                const statusElement = document.getElementById('other-players-status');
                
                if (!promptElement || !toolsElement || !statusElement) {
                    console.warn('Missing drawing UI elements:', {
                        prompt: !!promptElement,
                        tools: !!toolsElement, 
                        status: !!statusElement
                    });
                    return;
                }
                
                // All players can draw their own prompt
                const myPrompt = this.gameState.playerPrompts?.get(this.playerId) || 'Loading...';
                promptElement.textContent = `Draw: ${myPrompt}`;
                console.log('My prompt:', myPrompt);
                
                // Show drawing tools if not submitted
                if (this.gameState.drawingsCompleted.has(this.playerId)) {
                    toolsElement.style.display = 'none';
                } else {
                    toolsElement.style.display = 'flex';
                }
                
                // Show how many players have finished
                const completedCount = this.gameState.drawingsCompleted?.size || 0;
                const totalPlayers = this.gameState.players.size;
                statusElement.textContent = `${completedCount}/${totalPlayers} players have finished drawing`;
                
                console.log('Updated drawing UI:', myPrompt, `${completedCount}/${totalPlayers} completed`);
                
                // Add submit button if not already there
                let submitBtn = document.getElementById('submit-drawing');
                if (!submitBtn) {
                    submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-drawing';
                    submitBtn.className = 'btn btn-secondary text-lg mt-4';
                    submitBtn.textContent = 'Submit Drawing';
                    submitBtn.addEventListener('click', () => this.submitDrawing());
                    
                    // Insert the button after the status element
                    if (statusElement.parentNode) {
                        statusElement.parentNode.insertBefore(submitBtn, statusElement.nextSibling);
                        console.log('Submit drawing button added');
                    } else {
                        console.warn('Could not add submit button - no parent element');
                    }
                }
                
                // Update submit button state
                const submitBtn = document.getElementById('submit-drawing');
                if (submitBtn) {
                    if (this.gameState.drawingsCompleted.has(this.playerId)) {
                        submitBtn.disabled = true;
                        submitBtn.textContent = 'Drawing Submitted!';
                        submitBtn.classList.add('bg-green-600');
                    } else {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit Drawing';
                        submitBtn.classList.remove('bg-green-600');
                    }
                }
            }
            
            // Performance-optimized drawing loop using requestAnimationFrame for 60fps
            startDrawingLoop(canvas, ctx) {
                const processDrawingBuffer = () => {
                    const currentTime = performance.now();
                    
                    // Calculate FPS for monitoring
                    const deltaTime = currentTime - this.performanceMetrics.lastFrameTime;
                    this.performanceMetrics.fps = Math.round(1000 / deltaTime);
                    this.performanceMetrics.lastFrameTime = currentTime;
                    
                    if (this.drawingBuffer.length === 0) {
                        if (!this.isDrawing) {
                            this.animationFrameId = null;
                            console.log('Drawing loop stopped - FPS:', this.performanceMetrics.fps);
                            return;
                        }
                        this.animationFrameId = requestAnimationFrame(processDrawingBuffer);
                        return;
                    }
                    
                    // Process drawing operations in optimized batches
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Batch similar operations together for performance
                    let currentColor = null;
                    let currentSize = null;
                    let strokeCount = 0;
                    const maxStrokesPerFrame = 10; // Limit strokes per frame for consistent 60fps
                    
                    ctx.beginPath();
                    
                    while (this.drawingBuffer.length > 0 && strokeCount < maxStrokesPerFrame) {
                        const stroke = this.drawingBuffer.shift();
                        strokeCount++;
                        
                        // Only update context properties when they change
                        if (stroke.color !== currentColor) {
                            if (currentColor !== null) {
                                ctx.stroke();
                                ctx.beginPath();
                            }
                            currentColor = stroke.color;
                            ctx.strokeStyle = currentColor;
                        }
                        
                        if (stroke.size !== currentSize) {
                            if (currentSize !== null) {
                                ctx.stroke();
                                ctx.beginPath();
                            }
                            currentSize = stroke.size;
                            ctx.lineWidth = currentSize;
                        }
                        
                        ctx.moveTo(stroke.from.x, stroke.from.y);
                        ctx.lineTo(stroke.to.x, stroke.to.y);
                    }
                    
                    ctx.stroke();
                    ctx.restore();
                    
                    // Continue processing if there's more to do or still drawing
                    if (this.drawingBuffer.length > 0 || this.isDrawing) {
                        this.animationFrameId = requestAnimationFrame(processDrawingBuffer);
                    } else {
                        this.animationFrameId = null;
                        console.log('Drawing loop completed - Final FPS:', this.performanceMetrics.fps);
                    }
                };
                
                this.animationFrameId = requestAnimationFrame(processDrawingBuffer);
                console.log('Started optimized 60fps drawing loop');
            }
            
            // Canvas utility methods for handling drawing data
            updateCanvas(imageData) {
                const canvas = document.getElementById('drawing-canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    const dpr = window.devicePixelRatio || 1;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
                };
                img.onerror = () => {
                    console.error('Failed to load canvas image data');
                };
                img.src = imageData;
            }

            setupCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                if (!canvas) {
                    console.error('Drawing canvas not found!');
                    return;
                }
                
                // Clear any existing canvas event listeners first
                this.cleanupCanvasEventListeners();
                
                const ctx = canvas.getContext('2d', {
                    alpha: false,           // Disable alpha for performance
                    desynchronized: true,   // Optimize for frequent redraws
                    willReadFrequently: false
                });
                console.log('Setting up optimized canvas...');

                const resize = () => {
                    const container = canvas.parentElement;
                    if (!container) {
                        console.warn('Canvas container not found');
                        return;
                    }
                    
                    const containerRect = container.getBoundingClientRect();
                    
                    // Ensure container has dimensions
                    if (containerRect.width === 0 || containerRect.height === 0) {
                        console.warn('Container has zero dimensions, using defaults');
                        containerRect.width = 400;
                        containerRect.height = 300;
                    }
                    
                    // Set canvas display size
                    canvas.style.width = containerRect.width + 'px';
                    canvas.style.height = containerRect.height + 'px';
                    
                    // Set canvas actual size (for high DPI displays)
                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    canvas.width = containerRect.width * dpr;
                    canvas.height = containerRect.height * dpr;
                    
                    // Reset context after size change
                    ctx.scale(dpr, dpr);
                    
                    // Always fill with white background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, containerRect.width, containerRect.height);
                    
                    // Set default drawing styles
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    console.log('Canvas resized and initialized:', containerRect.width, 'x', containerRect.height, 'DPR:', dpr);
                };
                
                // Managed debounced resize for performance
                const handleResize = () => {
                    if (this.resizeTimeout) {
                        clearTimeout(this.resizeTimeout);
                    }
                    this.resizeTimeout = this.createManagedTimeout(resize, 100);
                };
                
                this.addManagedEventListener(window, 'resize', handleResize);
                
                // Force initial resize
                this.createManagedTimeout(resize, 100);

                const getPos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { 
                        x: clientX - rect.left, 
                        y: clientY - rect.top 
                    };
                };

                const start = (e) => {
                    if (this.gameState.phase !== 'DRAWING') {
                        console.log('Not in drawing phase:', this.gameState.phase);
                        return;
                    }
                    
                    e.preventDefault();
                    this.isDrawing = true;
                    this.lastPos = getPos(e);
                    
                    // Start the optimized drawing loop
                    if (!this.animationFrameId) {
                        this.startDrawingLoop(canvas, ctx);
                    }
                    
                    console.log('Drawing started at:', this.lastPos);
                };
                
                const draw = (e) => {
                    if (!this.isDrawing) return;
                    if (this.gameState.phase !== 'DRAWING') return;
                    
                    e.preventDefault();
                    const pos = getPos(e);
                    
                    // Add to drawing buffer instead of immediate drawing
                    this.drawingBuffer.push({
                        from: { ...this.lastPos },
                        to: { ...pos },
                        color: this.currentTool === 'eraser' ? 'white' : this.currentColor,
                        size: this.currentSize,
                        timestamp: performance.now()
                    });
                    
                    this.lastPos = pos;
                    
                    // Track performance
                    this.performanceMetrics.drawLatency = performance.now() - this.performanceMetrics.lastFrameTime;
                };
                
                const stop = () => {
                    if (!this.isDrawing) return;
                    this.isDrawing = false;
                    
                    // Process any remaining drawing buffer
                    if (this.drawingBuffer.length > 0) {
                        // Let the drawing loop finish processing
                        this.createManagedTimeout(() => {
                            this.drawingHistory.saveState(canvas);
                        }, 50);
                    } else {
                        this.drawingHistory.saveState(canvas);
                    }
                    
                    console.log('Drawing stopped');
                };

                // Use managed event listeners for canvas events
                this.addCanvasEventListener(canvas, 'mousedown', start);
                this.addCanvasEventListener(canvas, 'mousemove', draw);
                this.addCanvasEventListener(canvas, 'mouseup', stop);
                this.addCanvasEventListener(canvas, 'mouseout', stop);
                this.addCanvasEventListener(canvas, 'touchstart', start, { passive: false });
                this.addCanvasEventListener(canvas, 'touchmove', draw, { passive: false });
                this.addCanvasEventListener(canvas, 'touchend', stop);
                
                console.log('Canvas setup complete with performance optimizations and memory leak prevention');
            }
        }

        window.game = new DrawPartyGame();
    </script>
</body>
</html>