<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! üé®</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/draw-party-game/manifest.json">
    <meta name="theme-color" content="#2c2a4a">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        :root {
            --font-display: 'Nunito', sans-serif;
            --font-body: 'Inter', sans-serif;
            --color-bg: #1a1836;
            --color-surface: #2c2a4a;
            --color-primary: #8a5cf6;
            --color-primary-hover: #7c3aed;
            --color-secondary: #34d399;
            --color-secondary-hover: #059669;
            --color-accent: #22d3ee;
            --color-text: #e5e7eb;
            --color-text-muted: #9ca3af;
            --color-border: #4b5563;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-display);
            font-weight: 800;
        }

        .btn {
            font-family: var(--font-display);
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            transform: translateY(0);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }
        .btn-secondary {
            background-color: var(--color-secondary);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--color-secondary-hover);
        }

        .input-field {
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            transition: border-color 0.2s;
            font-family: var(--font-body);
        }
        .input-field:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            max-width: min(90vw, 90vh, 500px);
            aspect-ratio: 4/3;
            margin: 0 auto;
        }
        
        .drawing-canvas {
            border: 2px solid var(--color-border);
            border-radius: 0.75rem;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
            font-family: var(--font-display);
            font-weight: 700;
            border-radius: 0.5rem;
        }
        
        .fade-in { animation: fadeIn 0.5s ease-in; }
        .bounce { animation: bounce 0.6s ease-in-out; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        * { touch-action: manipulation; }
    </style>
</head>
<body class="min-h-screen">
    <div id="app" class="min-h-screen flex flex-col p-4">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">üé®</div>
                <h1 class="text-4xl mb-2">Draw Party!</h1>
                <div class="text-lg text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-6 py-3 shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col items-center justify-center max-w-4xl w-full mx-auto">
            
            <!-- Welcome Screen -->
            <div id="welcome-screen" class="text-center w-full max-w-md">
                <div class="text-8xl mb-6">üé®</div>
                <h1 class="text-5xl mb-4">Welcome to Draw Party!</h1>
                <p class="text-xl text-gray-400 mb-10">The easiest multiplayer drawing game ever.</p>
                
                <div class="space-y-4">
                    <button id="create-room" class="w-full btn btn-primary text-xl">
                        üéÆ Create New Game
                    </button>
                    <div class="text-gray-500 font-bold">OR</div>
                    <div class="flex gap-3">
                        <input id="join-code" type="text" placeholder="ENTER CODE" 
                               class="flex-1 input-field text-center uppercase tracking-widest font-bold text-lg" 
                               maxlength="4">
                        <button id="join-room" class="btn btn-secondary">
                            Join
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Lobby Screen -->
            <div id="lobby-screen" class="hidden w-full max-w-md">
                <div class="text-center mb-8">
                    <h2 class="text-4xl mb-4">Game Lobby</h2>
                    <div class="card mb-6">
                        <div class="text-lg text-gray-400">Room Code</div>
                        <div id="current-room-code" class="text-5xl font-mono font-bold text-white tracking-widest"></div>
                    </div>
                    
                    <button id="share-game" class="w-full btn btn-primary">
                        üì± Share Game Link
                    </button>
                </div>
                
                <div class="card mb-6">
                    <h3 class="text-2xl font-bold mb-4 text-center">Players</h3>
                    <div id="players-list" class="space-y-3"></div>
                    <div id="waiting-message" class="text-gray-400 text-center mt-4">
                        Waiting for more players... (need at least 2)
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="flex gap-3">
                        <input id="player-name" type="text" placeholder="Enter your name" 
                               class="flex-1 input-field">
                        <button id="submit-name" class="btn btn-primary">
                            Set
                        </button>
                    </div>
                    <button id="start-game" class="w-full btn btn-secondary text-xl" disabled>
                        üé® Start Drawing!
                    </button>
                </div>
            </div>
            
            <!-- Drawing Screen -->
            <div id="drawing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <div id="drawing-prompt" class="text-2xl font-bold mb-2 card inline-block"></div>
                    <div id="drawing-timer" class="text-4xl font-mono text-accent"></div>
                </div>
                
                <div class="canvas-container mx-auto mb-4" id="canvas-container">
                    <canvas id="drawing-canvas" class="drawing-canvas w-full"></canvas>
                </div>
                
                <div class="flex flex-wrap gap-4 justify-center items-center mb-4" id="drawing-tools">
                    <div class="flex gap-2 card p-2" id="color-palette">
                        <!-- Player colors will be populated here -->
                    </div>
                    
                    <div class="flex gap-2 card p-2" id="tool-palette">
                        <button id="undo-btn" class="tool-btn btn">‚Ü©Ô∏è</button>
                        <button id="redo-btn" class="tool-btn btn">‚Ü™Ô∏è</button>
                        <button id="brush-small" class="tool-btn btn">S</button>
                        <button id="brush-medium" class="tool-btn btn btn-primary">M</button>
                        <button id="brush-large" class="tool-btn btn">L</button>
                        <button id="eraser" class="tool-btn btn">üóëÔ∏è</button>
                        <button id="clear-canvas" class="tool-btn btn bg-red-600 hover:bg-red-700">‚úñÔ∏è</button>
                    </div>
                </div>
                
                <div class="text-center">
                    <div class="text-sm text-gray-400 mb-2">‚ö†Ô∏è No letters or words allowed!</div>
                    <div id="other-players-status" class="text-gray-400"></div>
                </div>
            </div>
            
            <!-- Guessing Screen -->
            <div id="guessing-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">What is this masterpiece?</h2>
                    <div id="guessing-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="guess-canvas" class="drawing-canvas"></canvas>
                    </div>
                    <div class="text-center mt-2 text-lg text-gray-400" id="artist-name"></div>
                </div>
                
                <div class="max-w-md mx-auto">
                    <input id="guess-input" type="text" placeholder="Write your guess..." 
                           class="w-full input-field text-lg mb-4">
                    <button id="submit-guess" class="w-full btn btn-secondary text-lg">
                        Submit Answer
                    </button>
                </div>
            </div>
            
            <!-- Voting Screen -->
            <div id="voting-screen" class="hidden w-full">
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2">Which is the REAL answer?</h2>
                    <div id="voting-timer" class="text-3xl font-mono text-accent mb-4"></div>
                </div>
                
                <div class="mb-6 card p-4">
                    <div class="canvas-container">
                        <canvas id="vote-canvas" class="drawing-canvas"></canvas>
                    </div>
                </div>
                
                <div id="voting-options" class="grid grid-cols-1 md:grid-cols-2 gap-3 max-w-2xl mx-auto">
                    <!-- Voting options will be populated here -->
                </div>
            </div>
            
            <!-- Results Screen -->
            <div id="results-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">üéâ Round Results!</h2>
                </div>
                
                <div id="results-content" class="space-y-4">
                    <!-- Results will be populated here -->
                </div>
                
                <div class="text-center mt-8">
                    <button id="next-round" class="btn btn-primary text-xl">
                        Next Round üé®
                    </button>
                </div>
            </div>
            
            <!-- Final Scores Screen -->
            <div id="final-scores-screen" class="hidden w-full max-w-lg">
                <div class="text-center mb-6">
                    <h2 class="text-5xl font-bold mb-4">üèÜ Final Results!</h2>
                </div>
                
                <div id="final-scores-content" class="space-y-4">
                    <!-- Final scores will be populated here -->
                </div>
                
                <div class="text-center mt-8 space-y-4">
                    <button id="play-again" class="w-full btn btn-secondary text-xl">
                        üéÆ Play Again!
                    </button>
                    <button id="new-game" class="w-full btn btn-primary text-xl">
                        üé® New Game
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const DEBUG_MODE = false; // Set to true for development logging
        const debugLog = (...args) => {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        };

        class DrawingHistory {
            constructor(maxSteps = 20) {
                this.history = [];
                this.currentStep = -1;
                this.maxSteps = maxSteps;
            }

            saveState(canvas) {
                if (this.currentStep < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentStep + 1);
                }

                if (this.history.length >= this.maxSteps) {
                    this.history.shift();
                }

                this.history.push(canvas.toDataURL());
                this.currentStep = this.history.length - 1;
            }

            undo(canvas, ctx) {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.restoreState(canvas, ctx);
                }
            }

            redo(canvas, ctx) {
                if (this.currentStep < this.history.length - 1) {
                    this.currentStep++;
                    this.restoreState(canvas, ctx);
                }
            }

            restoreState(canvas, ctx) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
                };
                img.src = this.history[this.currentStep];
            }

            clear() {
                this.history = [];
                this.currentStep = -1;
            }
        }

        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5,
                    currentArtist: null,
                    currentDrawing: null,
                    currentPrompt: '',
                    guesses: new Map(),
                    votes: new Map(),
                    scores: new Map(),
                };
                
                this.isDrawing = false;
                this.currentColor = '#FFFFFF'; // Start with white
                this.currentSize = 5;
                this.currentTool = 'brush';
                this.drawingHistory = new DrawingHistory();

                this.playerColors = [
                    '#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93', '#ff924c', '#22d3ee', '#f957a8'
                ];
                
                this.gameConfig = {
                    timers: { drawing: 90, guessing: 45, voting: 30 },
                    gameplay: { minPlayers: 2, maxPlayers: 8, totalRounds: 5 }
                };
                
                this.gameState.totalRounds = this.gameConfig.gameplay.totalRounds;
                
                this.init();
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas();
                this.checkForRoomInURL();
                this.populateColorPalette();
            }

            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 500);
            }

            populateColorPalette() {
                const palette = document.getElementById('color-palette');
                palette.innerHTML = '';
                this.playerColors.forEach((color, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'color-btn w-10 h-10 rounded-full transition-transform transform hover:scale-110';
                    btn.style.backgroundColor = color;
                    btn.dataset.color = color;
                    if (index === 0) {
                        btn.classList.add('ring-2', 'ring-white');
                        this.currentColor = color;
                    }
                    btn.addEventListener('click', () => this.selectColor(color));
                    palette.appendChild(btn);
                });
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                let roomCode = null;
                if (path.includes('/draw-party-game/')) {
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) roomCode = parts[1];
                } else {
                    const parts = path.slice(1);
                    if (parts.length === 4) roomCode = parts;
                }
                if (roomCode) {
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                document.getElementById('join-code').addEventListener('input', (e) => e.target.value = e.target.value.toUpperCase());
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                
                const submitName = () => {
                    this.playerName = document.getElementById('player-name').value.trim();
                    if (!this.playerName) return;
                    this.gameState.players.set(this.playerId, { id: this.playerId, name: this.playerName, score: 0 });
                    this.broadcastMessage({ type: 'PLAYER_UPDATE', playerId: this.playerId, playerName: this.playerName });
                    this.updatePlayersDisplay();
                    this.showToast(`Name set to: ${this.playerName}`, 'success');
                };
                document.getElementById('submit-name').addEventListener('click', submitName);
                document.getElementById('player-name').addEventListener('keypress', (e) => { if (e.key === 'Enter') submitName(); });

                document.getElementById('undo-btn').addEventListener('click', () => this.undo());
                document.getElementById('redo-btn').addEventListener('click', () => this.redo());
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(2));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(5));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(10));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            createRoom() {
                debugLog('CREATE_ROOM', 'Starting room creation', 'out');
                
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                debugLog('ROOM_CODE', `Generated: ${this.roomCode}`, 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('HOST_SETUP', 'Becoming host, creating peer', 'out');
                
                this.createHostPeer();
                this.showLobby();
                
                debugLog('ROOM_READY', 'Room created successfully', 'out');
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('üëë Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('üéØ Host peer opened with ID:', id);
                    debugLog('üåê Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    debugLog('‚ûï Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('üìû Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('error', (err) => {
                    console.error('‚ùå Host peer error:', err);
                    debugLog('üîÑ Attempting to recover host connection...');
                    this.updateConnectionStatus('Connection error - recovering...');
                    
                    setTimeout(() => {
                        if (this.peer && this.peer.destroyed) {
                            debugLog('üîÑ Recreating host peer after error');
                            this.createHostPeer();
                        } else if (this.peer && this.peer.disconnected) {
                            debugLog('üîÑ Reconnecting host peer');
                            this.peer.reconnect();
                        }
                    }, 2000);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('üîå Host peer disconnected from server');
                    this.updateConnectionStatus('Disconnected - reconnecting...');
                    
                    setTimeout(() => {
                        if (this.peer && !this.peer.destroyed) {
                            debugLog('üîÑ Attempting to reconnect host peer');
                            this.peer.reconnect();
                        }
                    }, 1000);
                });
                
                this.peer.on('close', () => {
                    debugLog('üîå Host peer connection closed');
                });
            }
            
            joinRoom(code) {
                debugLog('JOIN_ROOM', `Attempting to join: ${code}`, 'out');
                
                this.roomCode = code;
                this.isHost = false;
                
                debugLog('PLAYER_SETUP', 'Set as player, looking for host', 'out');
                
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                debugLog('PEER_INIT', 'Initializing peer connection', 'out');
                this.initializePeer();
                this.showLobby();
                
                debugLog('JOIN_COMPLETE', 'Join room setup complete', 'out');
            }
            
            initializePeer() {
                // Always attempt P2P connection
                if (!this.isHost) {
                    this.createPlayerPeer();
                }
            }
            
            createPlayerPeer() {
                debugLog('üé≠ Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    debugLog('üéØ Player peer opened with ID:', id);
                    debugLog('üåê Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.error('‚ùå Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    // Fallback to becoming host if connection fails
                    this.becomeHost();
                });
                
                this.peer.on('connection', (conn) => {
                    debugLog('üìû Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    debugLog('üîå Player peer disconnected');
                });
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                debugLog('üîå Attempting to connect to host:', hostId);
                
                const connectionTimeout = setTimeout(() => {
                    debugLog('‚è∞ Connection timeout - no host found, becoming host');
                    this.becomeHost();
                }, 8000);
                
                try {
                    debugLog('üìû Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        debugLog('‚úÖ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.error('‚ùå Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.becomeHost();
                    });
                    
                    conn.on('close', () => {
                        debugLog('üîå Connection to host closed');
                    });
                    
                    conn.on('data', (data) => {
                        debugLog('üì• Data from host:', data);
                    });
                    
                } catch (error) {
                    console.error('üí• Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.becomeHost();
                }
            }
            
            becomeHost() {
                if (this.isHost) return;
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                if (this.peer) {
                    this.peer.destroy();
                }
                
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    debugLog('üéØ becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    debugLog('‚ûï becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    debugLog('üîó Connection established with:', conn.peer);
                    debugLog('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    if (this.isHost) {
                        debugLog('üì° Host sending ROOM_JOINED to:', conn.peer);
                        this.sendToPlayer(conn.peer, { type: 'ROOM_JOINED', roomCode: this.roomCode });
                        setTimeout(() => {
                            debugLog('üì° Host also sending current game state to new player');
                            this.broadcastGameState();
                        }, 100);
                    } else {
                        debugLog('üì° Player sending PLAYER_JOIN to host:', conn.peer);
                        debugLog('üè∑Ô∏è Player name at join time:', this.playerName, '(empty is normal)');
                        this.sendToPlayer(conn.peer, { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName || 'Player' });
                    }
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer, conn);
                });
                
                conn.on('close', () => {
                    debugLog('üîå Connection closed with:', conn.peer);
                    this.connections.delete(conn.peer);
                    
                    if (this.isHost && this.gameState.players.has(conn.peer)) {
                        debugLog('‚ûñ Removing disconnected player:', conn.peer);
                        this.gameState.players.delete(conn.peer);
                        this.broadcastGameState();
                    }
                    
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('‚ùå Connection error with', conn.peer, ':', err);
                    this.connections.delete(conn.peer);
                    this.updatePlayersDisplay();
                });
            }
            
            handleMessage(message, fromPeer, connection = null) {
                debugLog('üì® Received message:', message.type, 'from:', fromPeer);
                debugLog('üì® Message details:', message);
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        debugLog('üéØ Handling PLAYER_JOIN. I am host?', this.isHost);
                        debugLog('üéØ Player joining:', message.playerId, 'Name:', message.playerName);
                        debugLog('üéØ Current players before adding:', this.gameState.players.size);
                        if (this.isHost) {
                            debugLog('‚ûï Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true,
                                likes: 0
                            });
                            debugLog('‚úÖ Player added! New player count:', this.gameState.players.size);
                            debugLog('üìã All players now:', Array.from(this.gameState.players.entries()));
                            debugLog('üì° Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            debugLog('üë§ Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                        }
                        this.updatePlayersDisplay();
                        if (this.isHost) {
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'ROOM_JOINED':
                        debugLog('üéØ Received ROOM_JOINED from host - sending PLAYER_JOIN back');
                        if (!this.isHost) {
                            const playerJoinMessage = {
                                type: 'PLAYER_JOIN',
                                playerId: this.playerId,
                                playerName: this.playerName || 'Player'
                            };
                            debugLog('üì° Sending PLAYER_JOIN to host:', playerJoinMessage);
                            if (connection && connection.open) {
                                try {
                                    connection.send(playerJoinMessage);
                                    debugLog('‚úÖ PLAYER_JOIN sent successfully via direct connection');
                                } catch (error) {
                                    console.error('‚ùå Failed to send PLAYER_JOIN:', error);
                                    this.sendToPlayer(fromPeer, playerJoinMessage);
                                }
                            } else {
                                debugLog('üîÑ Using sendToPlayer fallback');
                                this.sendToPlayer(fromPeer, playerJoinMessage);
                            }
                        }
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        debugLog('üì• Received GAME_STATE_UPDATE:', message.gameState);
                        debugLog('üîç Before update - players.size:', this.gameState.players.size);
                        
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            debugLog('üîÑ Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                debugLog('‚ûï Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            debugLog('‚úÖ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        const { players, guesses, votes, scores, playerPrompts, ...scalarState } = message.gameState;
                        Object.assign(this.gameState, scalarState);
                        
                        debugLog('üìä Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        this.updateCanvas(message.canvasData);
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'LIKE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.likes.set(message.playerId, {
                                targetPlayerId: message.targetPlayerId,
                                guessText: message.guessText
                            });
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'HEARTBEAT':
                        debugLog(`üíì Heartbeat received from ${fromPeer}`);
                        if (this.isHost) {
                            this.sendToPlayer(fromPeer, {
                                type: 'HEARTBEAT_ACK',
                                timestamp: Date.now()
                            }, { waitForReady: false, retries: 0 });
                        }
                        break;
                        
                    case 'HEARTBEAT_ACK':
                        debugLog(`üíì Heartbeat ACK received from ${fromPeer}`);
                        break;
                }
            }
            
            sendToPlayer(playerId, message, options = {}) {
                const {
                    timeout = 5000,
                    retries = 2,
                    retryDelay = 1000,
                    waitForReady = true
                } = options;
                
                const startTime = Date.now();
                
                const createStatus = (success, details = {}) => ({
                    success,
                    playerId,
                    messageType: message.type,
                    timestamp: Date.now(),
                    duration: Date.now() - startTime,
                    ...details
                });
                
                const conn = this.connections.get(playerId);
                if (!conn) {
                    console.warn(`‚ö†Ô∏è No connection found for player: ${playerId}`);
                    return createStatus(false, { 
                        error: 'No connection found',
                        connectionExists: false
                    });
                }
                
                const validateConnection = () => {
                    if (!conn) return { valid: false, reason: 'Connection is null' };
                    if (conn.destroyed) return { valid: false, reason: 'Connection destroyed' };
                    if (!conn.open) return { valid: false, reason: 'Connection not open' };
                    return { valid: true };
                };
                
                const attemptSend = async (attempt = 0) => {
                    const validation = validateConnection();
                    
                    if (!validation.valid) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} invalid: ${validation.reason}`);
                        
                        if (waitForReady && attempt < retries && validation.reason.includes('state')) {
                            debugLog(`üîÑ Waiting for connection to be ready (attempt ${attempt + 1}/${retries + 1})`);
                            
                            const readyPromise = new Promise((resolve) => {
                                const checkReady = () => {
                                    const newValidation = validateConnection();
                                    if (newValidation.valid) {
                                        resolve(true);
                                    } else if (Date.now() - startTime > timeout) {
                                        resolve(false);
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                setTimeout(checkReady, retryDelay);
                            });
                            
                            const isReady = await readyPromise;
                            if (isReady) {
                                return attemptSend(attempt + 1);
                            }
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`üì§ Message sent to ${playerId}:`, message.type);
                        
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            attemptsUsed: attempt + 1,
                            method: 'peerjs'
                        });
                        
                    } catch (error) {
                        console.error(`‚ùå Send attempt ${attempt + 1} failed to ${playerId}:`, error);
                        
                        if (attempt < retries) {
                            debugLog(`üîÑ Retrying send to ${playerId} in ${retryDelay}ms`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return attemptSend(attempt + 1);
                        }
                        
                        this.connections.delete(playerId);
                        
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                };
                
                if (waitForReady || retries > 0) {
                    return attemptSend();
                } else {
                    const validation = validateConnection();
                    if (!validation.valid) {
                        this.connections.delete(playerId);
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                    
                    try {
                        conn.send(message);
                        debugLog(`üì§ Message sent to ${playerId}:`, message.type);
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            method: 'peerjs'
                        });
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        this.connections.delete(playerId);
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                }
            }
            
            async sendReliably(playerId, message, options = {}) {
                const defaultOptions = {
                    waitForReady: true,
                    retries: 2,
                    retryDelay: 500,
                    ...options
                };
                
                try {
                    const result = await this.sendToPlayer(playerId, message, defaultOptions);
                    
                    if (result.success) {
                        debugLog(`‚úÖ Reliable send success to ${playerId}:`, result);
                        return result;
                    } else {
                        console.warn(`‚ö†Ô∏è Reliable send failed to ${playerId}:`, result);
                        if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                            this.showToast(`Failed to send ${message.type.toLowerCase()} - connection issue`, 'warning');
                        }
                        return result;
                    }
                } catch (error) {
                    console.error(`‚ùå Reliable send error to ${playerId}:`, error);
                    const errorResult = {
                        success: false,
                        error: error.message,
                        playerId,
                        messageType: message.type,
                        timestamp: Date.now()
                    };
                    
                    if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                        this.showToast(`Network error sending ${message.type.toLowerCase()}`, 'error');
                    }
                    return errorResult;
                }
            }
            
            attemptReconnection(playerId, oldConn) {
                console.warn(`Attempting to reconnect to ${playerId}...`);
                if (oldConn) {
                    try { oldConn.close(); } catch (e) { console.error("Error closing old connection:", e); }
                    try { oldConn.destroy(); } catch (e) { console.error("Error destroying old connection:", e); }
                }
                
                if (this.isHost) {
                    // Host doesn't actively reconnect to players, players reconnect to host
                    // Just remove the player from the game state
                    if (this.gameState.players.has(playerId)) {
                        this.gameState.players.delete(playerId);
                        this.broadcastGameState();
                        this.updatePlayersDisplay();
                    }
                } else {
                    // Player tries to reconnect to host
                    this.updateConnectionStatus('Reconnecting to host...');
                    setTimeout(() => this.connectToHost(), 3000);
                }
            }
            
            broadcastMessage(message) {
                if (this.isHost) {
                    this.connections.forEach((conn, peerId) => {
                        if (peerId !== this.playerId) { // Don't send to self
                            this.sendToPlayer(peerId, message);
                        }
                    });
                } else {
                    // Players send messages to the host
                    const hostConn = this.connections.get(`${this.roomCode}_HOST`);
                    if (hostConn) {
                        this.sendToPlayer(`${this.roomCode}_HOST`, message);
                    } else {
                        console.warn('No host connection found to broadcast message.');
                    }
                }
            }
            
            broadcastGameState() {
                if (!this.isHost) return;
                
                const stateToBroadcast = {
                    ...this.gameState,
                    players: Array.from(this.gameState.players.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                };
                
                this.connections.forEach((conn, peerId) => {
                    if (peerId !== this.playerId) { // Don't send to self
                        this.sendToPlayer(peerId, { type: 'GAME_STATE_UPDATE', gameState: stateToBroadcast });
                    }
                });
            }

            updateConnectionStatus(status) {
                document.getElementById('connection-status').textContent = status;
            }

            showScreen(screenId) {
                ['welcome-screen', 'lobby-screen', 'drawing-screen', 'guessing-screen', 'voting-screen', 'results-screen', 'final-scores-screen'].forEach(id => {
                    document.getElementById(id).classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            }

            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                this.updatePlayersDisplay();
            }

            updatePlayersDisplay() {
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                this.gameState.players.forEach(player => {
                    const playerEl = document.createElement('div');
                    playerEl.className = 'flex items-center justify-between p-3 bg-gray-800 rounded-lg';
                    playerEl.innerHTML = `<span class="font-bold text-lg">${player.name}</span><span class="text-gray-400">${player.score} pts</span>`;
                    playersList.appendChild(playerEl);
                });
                document.getElementById('start-game').disabled = this.gameState.players.size < this.gameConfig.gameplay.minPlayers;
            }
            
            shareGame() {
                const shareUrl = window.location.href;
                if (navigator.share) {
                    navigator.share({
                        title: 'Draw Party!',
                        text: 'Join my Draw Party game!',
                        url: shareUrl,
                    }).then(() => debugLog('Successful share')).catch((error) => console.error('Error sharing', error));
                } else {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        this.showToast('Game link copied to clipboard!', 'success');
                    }).catch(err => {
                        console.error('Could not copy text: ', err);
                        this.showToast('Failed to copy link.', 'error');
                    });
                }
            }

            startGame() {
                if (!this.isHost) return;
                if (this.gameState.players.size < this.gameConfig.gameplay.minPlayers) {
                    this.showToast(`Need at least ${this.gameConfig.gameplay.minPlayers} players to start!`, 'warning');
                    return;
                }
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.broadcastMessage({ type: 'START_GAME' });
                this.startDrawingPhase();
            }

            startDrawingPhase() {
                this.showScreen('drawing-screen');
                this.drawingHistory.clear();
                this.clearCanvas(false);
                // Assign prompts and artist (host logic)
                // Start timer
            }

            submitGuess() {
                // Logic for submitting guess
            }

            nextRound() {
                // Logic for next round
            }

            playAgain() {
                // Logic for playing again
            }

            newGame() {
                window.location.href = window.location.pathname;
            }

            showToast(message, type) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast shadow-lg px-6 py-3 ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white`;
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 3000);
            }
        }

        window.game = new DrawPartyGame();
    </script>
</body>
</html>
