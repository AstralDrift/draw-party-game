<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! üé®</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/draw-party-game/manifest.json">
    <meta name="theme-color" content="#1f2937">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        /* Custom styles for canvas and animations */
        .canvas-container {
            touch-action: none;
            position: relative;
        }
        
        .drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            cursor: crosshair;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        .bounce {
            animation: bounce 0.6s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        /* Prevent zoom on double tap */
        * {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div id="app" class="min-h-screen flex flex-col">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">üé®</div>
                <div class="text-2xl font-bold mb-2">Draw Party!</div>
                <div class="text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-4 py-2 rounded shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col">
            <!-- Header -->
            <header class="bg-gray-800 p-4 text-center">
                <h1 class="text-2xl font-bold">üé® Draw Party!</h1>
                <div id="room-code" class="text-gray-400 mt-1"></div>
                <div id="connection-status" class="text-sm mt-1"></div>
                
                <!-- Debug Dashboard -->
                <div id="debug-panel" class="mt-2 p-2 bg-gray-900 rounded text-xs text-left hidden">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold text-yellow-400">üîç Debug Dashboard</span>
                        <button id="toggle-debug" class="text-blue-400 hover:text-blue-300">Hide</button>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div>
                            <div class="text-gray-400">Mode:</div>
                            <div id="debug-mode" class="text-white font-mono">-</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Connections:</div>
                            <div id="debug-connections" class="text-white font-mono">0</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Players in State:</div>
                            <div id="debug-players" class="text-white font-mono">0</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Role:</div>
                            <div id="debug-role" class="text-white font-mono">-</div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-gray-400">Last Message:</div>
                        <div id="debug-last-message" class="text-green-400 font-mono text-xs">None</div>
                    </div>
                    <div class="mt-2">
                        <div class="text-gray-400">Message Log:</div>
                        <div id="debug-message-log" class="text-xs font-mono max-h-20 overflow-y-auto bg-black p-1 rounded"></div>
                    </div>
                </div>
                
                <!-- Debug Toggle Button -->
                <button id="show-debug" class="mt-1 text-xs text-blue-400 hover:text-blue-300">Show Debug Panel</button>
            </header>
            
            <!-- Game Content -->
            <main class="flex-1 p-4">
                <!-- Welcome Screen -->
                <div id="welcome-screen" class="text-center max-w-md mx-auto">
                    <div class="text-6xl mb-6">üé®</div>
                    <h2 class="text-3xl font-bold mb-4">Welcome to Draw Party!</h2>
                    <p class="text-gray-400 mb-8">The easiest multiplayer drawing game ever - just share a link!</p>
                    
                    <div class="space-y-4">
                        <button id="create-room" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                            üéÆ Create New Game
                        </button>
                        <div class="text-gray-500">or</div>
                        <div class="flex gap-2">
                            <input id="join-code" type="text" placeholder="Enter room code" 
                                   class="flex-1 bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-center uppercase" 
                                   maxlength="4">
                            <button id="join-room" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                                Join
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Lobby Screen -->
                <div id="lobby-screen" class="hidden max-w-md mx-auto">
                    <div class="text-center mb-6">
                        <div class="text-4xl mb-2">üè†</div>
                        <h2 class="text-2xl font-bold mb-2">Game Lobby</h2>
                        <div class="bg-gray-800 rounded-lg p-4 mb-4">
                            <div class="text-sm text-gray-400">Room Code</div>
                            <div id="current-room-code" class="text-3xl font-mono font-bold"></div>
                        </div>
                        
                        <button id="share-game" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg mb-4">
                            üì± Share Game Link
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-bold mb-3">Players:</h3>
                        <div id="players-list" class="space-y-2"></div>
                        <div id="waiting-message" class="text-gray-400 text-center mt-4">
                            Waiting for more players... (need at least 3)
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <input id="player-name" type="text" placeholder="Enter your name" 
                               class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3">
                        <button id="start-game" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                            üé® Start Drawing!
                        </button>
                    </div>
                </div>
                
                <!-- Drawing Screen -->
                <div id="drawing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <div id="drawing-prompt" class="text-xl font-bold mb-2 bg-blue-600 rounded-lg p-4"></div>
                        <div id="drawing-timer" class="text-2xl font-mono"></div>
                    </div>
                    
                    <div class="canvas-container mx-auto mb-4" style="max-width: 400px;">
                        <canvas id="drawing-canvas" class="drawing-canvas w-full" width="400" height="300"></canvas>
                    </div>
                    
                    <div class="flex flex-wrap gap-2 justify-center mb-4">
                        <!-- Color palette -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2">
                            <button class="color-btn w-8 h-8 rounded-full bg-black border-2 border-white" data-color="#000000"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-red-500" data-color="#ef4444"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-blue-500" data-color="#3b82f6"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-green-500" data-color="#10b981"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-yellow-500" data-color="#f59e0b"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-purple-500" data-color="#8b5cf6"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-pink-500" data-color="#ec4899"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-orange-500" data-color="#f97316"></button>
                        </div>
                        
                        <!-- Tools -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2">
                            <button id="brush-small" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Small</button>
                            <button id="brush-medium" class="tool-btn bg-blue-600 hover:bg-blue-500 px-3 py-2 rounded text-sm">Medium</button>
                            <button id="brush-large" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Large</button>
                            <button id="eraser" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Eraser</button>
                            <button id="clear-canvas" class="tool-btn bg-red-600 hover:bg-red-500 px-3 py-2 rounded text-sm">Clear</button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div class="text-sm text-gray-400 mb-2">‚ö†Ô∏è No letters or words allowed!</div>
                        <div id="other-players-status" class="text-gray-400"></div>
                    </div>
                </div>
                
                <!-- Guessing Screen -->
                <div id="guessing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">What do you think this is?</h2>
                        <div id="guessing-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400 mb-4">Write the real answer OR something funny to trick others!</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <canvas id="guess-canvas" class="w-full border rounded" width="400" height="300"></canvas>
                        <div class="text-center mt-2 text-sm text-gray-400" id="artist-name"></div>
                    </div>
                    
                    <div class="max-w-md mx-auto">
                        <input id="guess-input" type="text" placeholder="What is this drawing?" 
                               class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 mb-4">
                        <button id="submit-guess" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            Submit Answer
                        </button>
                    </div>
                </div>
                
                <!-- Voting Screen -->
                <div id="voting-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">Which is the REAL answer?</h2>
                        <div id="voting-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400">Vote for what you think was the original prompt</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <canvas id="vote-canvas" class="w-full border rounded" width="400" height="300"></canvas>
                    </div>
                    
                    <div id="voting-options" class="space-y-3 max-w-md mx-auto">
                        <!-- Voting options will be populated here -->
                    </div>
                </div>
                
                <!-- Results Screen -->
                <div id="results-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üéâ Round Results!</h2>
                    </div>
                    
                    <div id="results-content" class="max-w-md mx-auto">
                        <!-- Results will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6">
                        <button id="next-round" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            Next Round üé®
                        </button>
                    </div>
                </div>
                
                <!-- Final Scores Screen -->
                <div id="final-scores-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üèÜ Final Results!</h2>
                    </div>
                    
                    <div id="final-scores-content" class="max-w-md mx-auto">
                        <!-- Final scores will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6 space-y-4">
                        <button id="play-again" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            üéÆ Play Again!
                        </button>
                        <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            üé® New Game
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                console.log('üé® Draw Party Game v1.7.2 - ENHANCED DEBUG LOGGING!', new Date().toISOString());
                console.log('üîß If you see old behavior, clear browser cache or hard refresh (Ctrl+Shift+R)');
                
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5,
                    currentArtist: null,
                    currentDrawing: null,
                    currentPrompt: '',
                    guesses: new Map(),
                    votes: new Map(),
                    scores: new Map()
                };
                
                // Drawing canvas state
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.currentSize = 3;
                this.currentTool = 'brush';
                
                // Connection monitoring
                this.connectionHealth = new Map();
                this.heartbeatInterval = null;
                this.lastHeartbeat = Date.now();
                
                this.init();
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
            
            // Debug Dashboard Functions
            updateDebugPanel() {
                const mode = this.isLocalMode ? 'LOCAL' : 'P2P';
                const connections = this.connections ? this.connections.size : 0;
                const players = this.gameState.players ? this.gameState.players.size : 0;
                const role = this.isHost ? 'HOST' : 'PLAYER';
                
                const debugMode = document.getElementById('debug-mode');
                const debugConnections = document.getElementById('debug-connections');
                const debugPlayers = document.getElementById('debug-players');
                const debugRole = document.getElementById('debug-role');
                
                if (debugMode) debugMode.textContent = mode;
                if (debugConnections) debugConnections.textContent = connections;
                if (debugPlayers) debugPlayers.textContent = players;
                if (debugRole) debugRole.textContent = role;
            }
            
            logDebugMessage(type, message, direction = 'out') {
                const timestamp = new Date().toLocaleTimeString();
                const arrow = direction === 'out' ? '‚Üí' : '‚Üê';
                const color = direction === 'out' ? 'text-blue-400' : 'text-green-400';
                
                // Update last message
                const lastMsg = document.getElementById('debug-last-message');
                if (lastMsg) {
                    lastMsg.textContent = `${arrow} ${type}`;
                    lastMsg.className = `${color} font-mono text-xs`;
                }
                
                // Add to message log
                const log = document.getElementById('debug-message-log');
                if (log) {
                    const entry = document.createElement('div');
                    entry.className = `${color}`;
                    entry.textContent = `${timestamp} ${arrow} ${type}`;
                    log.appendChild(entry);
                    log.scrollTop = log.scrollHeight;
                    
                    // Keep only last 10 messages
                    while (log.children.length > 10) {
                        log.removeChild(log.firstChild);
                    }
                }
                
                // Update the debug panel
                this.updateDebugPanel();
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas();
                this.checkForRoomInURL();
            }
            
            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 1000);
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                
                // Extract room code from various URL formats:
                // localhost:3000/ABCD -> ABCD
                // astraldrift.github.io/draw-party-game/ABCD -> ABCD
                let roomCode = null;
                
                if (path.includes('/draw-party-game/')) {
                    // GitHub Pages format
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) {
                        roomCode = parts[1];
                    }
                } else {
                    // Localhost format
                    const parts = path.slice(1); // Remove leading /
                    if (parts.length === 4) {
                        roomCode = parts;
                    }
                }
                
                if (roomCode && roomCode.length === 4) {
                    console.log('üîó Found room code in URL:', roomCode);
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                // Welcome screen
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                
                document.getElementById('join-code').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                
                // Lobby screen
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                document.getElementById('player-name').addEventListener('input', (e) => {
                    this.playerName = e.target.value.trim();
                    
                    // Update player in game state
                    if (this.gameState.players.has(this.playerId)) {
                        const player = this.gameState.players.get(this.playerId);
                        player.name = this.playerName || (this.isHost ? 'Host' : 'Player');
                        this.gameState.players.set(this.playerId, player);
                    } else {
                        this.gameState.players.set(this.playerId, {
                            id: this.playerId,
                            name: this.playerName || (this.isHost ? 'Host' : 'Player'),
                            score: 0,
                            connected: true
                        });
                    }
                    
                    // Broadcast to other players
                    if (this.broadcastLocal) {
                        this.broadcastLocal({
                            type: 'PLAYER_UPDATE',
                            playerId: this.playerId,
                            playerName: this.playerName || (this.isHost ? 'Host' : 'Player')
                        });
                    }
                    
                    this.updateStartButton();
                    this.updatePlayersDisplay();
                });
                
                // Drawing tools
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectColor(e.target.dataset.color));
                });
                
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(1));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(3));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(6));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                // Game actions
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                
                // Enter key handlers
                document.getElementById('join-code').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('join-room').click();
                });
                document.getElementById('player-name').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('start-game').click();
                });
                document.getElementById('guess-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('submit-guess').click();
                });
                
                // Debug Panel Toggle
                // Debug panel toggle handlers
                document.getElementById('show-debug').addEventListener('click', () => {
                    document.getElementById('debug-panel').classList.remove('hidden');
                    document.getElementById('show-debug').classList.add('hidden');
                    this.updateDebugPanel();
                });
                
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    document.getElementById('debug-panel').classList.add('hidden');
                    document.getElementById('show-debug').classList.remove('hidden');
                });
            }
            
            setupCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => this.startDrawing(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.draw(e), { passive: false });
                canvas.addEventListener('touchend', () => this.stopDrawing());
                
                // Mouse events  
                canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                canvas.addEventListener('mousemove', (e) => this.draw(e));
                canvas.addEventListener('mouseup', () => this.stopDrawing());
                canvas.addEventListener('mouseout', () => this.stopDrawing());
                
                // Prevent scrolling when drawing
                canvas.addEventListener('touchstart', (e) => e.preventDefault());
                canvas.addEventListener('touchmove', (e) => e.preventDefault());
            }
            
            getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            startDrawing(e) {
                if (this.gameState.phase !== 'DRAWING') return;
                
                this.isDrawing = true;
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                
                this.lastPos = pos;
            }
            
            draw(e) {
                if (!this.isDrawing || this.gameState.phase !== 'DRAWING') return;
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                ctx.lineWidth = this.currentSize;
                ctx.lineCap = 'round';
                ctx.strokeStyle = this.currentTool === 'eraser' ? '#FFFFFF' : this.currentColor;
                ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                
                ctx.beginPath();
                ctx.moveTo(this.lastPos.x, this.lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                
                this.lastPos = pos;
                
                // Broadcast drawing to other players if host
                if (this.isHost) {
                    this.broadcastDrawingData();
                }
            }
            
            stopDrawing() {
                this.isDrawing = false;
            }
            
            selectColor(color) {
                this.currentColor = color;
                this.currentTool = 'brush';
                this.updateToolButtons();
            }
            
            selectBrush(size) {
                this.currentSize = size;
                this.currentTool = 'brush';
                this.updateToolButtons();
            }
            
            selectEraser() {
                this.currentTool = 'eraser';
                this.currentSize = 10;
                this.updateToolButtons();
            }
            
            updateToolButtons() {
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('bg-blue-600'));
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('border-white'));
                
                if (this.currentTool === 'brush') {
                    const sizeMap = { 1: 'brush-small', 3: 'brush-medium', 6: 'brush-large' };
                    document.getElementById(sizeMap[this.currentSize])?.classList.add('bg-blue-600');
                    document.querySelector(`[data-color="${this.currentColor}"]`)?.classList.add('border-white');
                } else if (this.currentTool === 'eraser') {
                    document.getElementById('eraser').classList.add('bg-blue-600');
                }
            }
            
            clearCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (this.isHost) {
                    this.broadcastDrawingData();
                }
            }
            
            createRoom() {
                this.logDebugMessage('CREATE_ROOM', 'Starting room creation', 'out');
                
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                this.logDebugMessage('ROOM_CODE', `Generated: ${this.roomCode}`, 'out');
                
                // Update URL for sharing
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                this.logDebugMessage('HOST_SETUP', 'Becoming host, creating peer', 'out');
                
                // Create peer with host ID so others can find us
                this.createHostPeer();
                this.showLobby();
                
                this.logDebugMessage('ROOM_READY', 'Room created successfully', 'out');
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üëë Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Host peer opened with ID:', id);
                    console.log('üåê Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    // CRITICAL FIX: Host must add themselves to the players list
                    console.log('‚ûï Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                    
                    // Start connection monitoring if this is our first connection
                    if (this.connections.size === 0 && !this.heartbeatInterval) {
                        this.startConnectionMonitoring();
                    }
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Host peer error:', err);
                    console.log('üîÑ Attempting to recover host connection...');
                    this.updateConnectionStatus('Connection error - recovering...');
                    
                    // Try to reconnect after a short delay
                    setTimeout(() => {
                        if (this.peer && this.peer.destroyed) {
                            console.log('üîÑ Recreating host peer after error');
                            this.createHostPeer();
                        } else if (this.peer && this.peer.disconnected) {
                            console.log('üîÑ Reconnecting host peer');
                            this.peer.reconnect();
                        }
                    }, 2000);
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Host peer disconnected from server');
                    this.updateConnectionStatus('Disconnected - reconnecting...');
                    
                    // Attempt to reconnect
                    setTimeout(() => {
                        if (this.peer && !this.peer.destroyed) {
                            console.log('üîÑ Attempting to reconnect host peer');
                            this.peer.reconnect();
                        }
                    }, 1000);
                });
                
                this.peer.on('close', () => {
                    console.log('üîå Host peer connection closed');
                });
            }
            
            joinRoom(code) {
                this.logDebugMessage('JOIN_ROOM', `Attempting to join: ${code}`, 'out');
                
                this.roomCode = code;
                
                // For cross-device multiplayer, we always start as player and try to connect to host
                // Only become host if no host exists
                this.isHost = false;
                
                this.logDebugMessage('PLAYER_SETUP', 'Set as player, looking for host', 'out');
                
                // Update URL - handle GitHub Pages path
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                this.logDebugMessage('PEER_INIT', 'Initializing peer connection', 'out');
                this.initializePeer();
                this.showLobby();
                
                this.logDebugMessage('JOIN_COMPLETE', 'Join room setup complete', 'out');
            }
            
            initializePeer() {
                try {
                    // Local testing mode for same-device development
                    if (window.location.hostname === 'localhost' || 
                        window.location.hostname === '127.0.0.1' || 
                        window.location.protocol === 'file:') {
                        this.setupLocalTesting();
                        return;
                    }
                    
                    // For joinRoom, create player peer and try to connect to host
                    if (!this.isHost) {
                        this.createPlayerPeer();
                    }
                    // For createRoom, host peer is already created in createHostPeer()
                    
                } catch (error) {
                    // If PeerJS fails, fall back to local mode
                    this.updateConnectionStatus('Local mode fallback');
                    this.setupLocalTesting();
                }
            }
            
            createPlayerPeer() {
                console.log('üé≠ Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Player peer opened with ID:', id);
                    console.log('üåê Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    // Small delay to ensure peer is fully ready
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    this.setupLocalTesting();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Player peer disconnected');
                });
            }
            
            setupLocalTesting() {
                if (this.isLocalMode) return;
                
                this.isLocalMode = true;
                
                // Clean up any existing peer connection
                if (this.peer) {
                    try { this.peer.destroy(); } catch (e) {}
                    this.peer = null;
                }
                
                this.updateConnectionStatus('Local mode');
                this.localConnections = new Map();
                
                setTimeout(() => {
                    this.updateConnectionStatus('Connected (Local)');
                    if (!this.isHost) {
                        this.connectToLocalHost();
                    }
                }, 500);
                
                this.setupLocalStorageSync();
            }
            
            setupLocalStorageSync() {
                // Use localStorage to sync between browser tabs for local testing
                const storageKey = `drawparty_${this.roomCode}`;
                
                // Listen for storage changes (from other tabs)
                window.addEventListener('storage', (e) => {
                    if (e.key === storageKey && e.newValue) {
                        const data = JSON.parse(e.newValue);
                        this.handleLocalMessage(data);
                    }
                });
                
                // Broadcast to localStorage
                this.broadcastLocal = (message) => {
                    const data = {
                        timestamp: Date.now(),
                        fromPlayer: this.playerId,
                        isHost: this.isHost,
                        message: message
                    };
                    localStorage.setItem(storageKey, JSON.stringify(data));
                };
                
                // Announce presence after a short delay to ensure setup is complete
                setTimeout(() => {
                    this.broadcastLocal({
                        type: 'PLAYER_JOIN',
                        playerId: this.playerId,
                        playerName: this.playerName || 'Player'
                    });
                }, 100);
            }
            
            handleLocalMessage(data) {
                // Don't process our own messages
                if (data.fromPlayer === this.playerId) return;
                
                this.handleMessage(data.message, data.fromPlayer);
                
                // If this is a new player joining, send them our current state
                if (data.message.type === 'PLAYER_JOIN' && this.isHost) {
                    setTimeout(() => {
                        this.broadcastGameState();
                    }, 200);
                }
            }
            
            connectToLocalHost() {
                // Simulate connecting to host in local mode
                setTimeout(() => {
                    console.log('Connected to local host');
                    this.localConnections.set('host', true);
                }, 200);
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üîå Attempting to connect to host:', hostId);
                
                // Increase timeout to 8 seconds for better connection reliability
                const connectionTimeout = setTimeout(() => {
                    console.log('‚è∞ Connection timeout - no host found, becoming host');
                    this.becomeHost();
                }, 8000);
                
                try {
                    console.log('üìû Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        console.log('‚úÖ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.log('‚ùå Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.becomeHost();
                    });
                    
                    conn.on('close', () => {
                        console.log('üîå Connection to host closed');
                    });
                    
                    // Add debugging for connection metadata
                    conn.on('data', (data) => {
                        console.log('üì• Data from host:', data);
                    });
                    
                } catch (error) {
                    console.log('üí• Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.becomeHost();
                }
            }
            
            becomeHost() {
                if (this.isHost) return; // Already host
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                // Update our peer ID to be the host
                if (this.peer) {
                    this.peer.destroy();
                }
                
                // Recreate peer with host ID
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 0,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    console.log('üéØ becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    // CRITICAL FIX: Host must add themselves to the players list when they become host
                    console.log('‚ûï becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    console.log('üîó Connection established with:', conn.peer);
                    console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    // Initialize connection health tracking
                    this.connectionHealth.set(conn.peer, Date.now());
                    
                    // Start connection monitoring if not already started
                    if (!this.heartbeatInterval) {
                        this.startConnectionMonitoring();
                    }
                    
                    // CRITICAL FIX: Add delay to ensure connection is fully ready
                    setTimeout(() => {
                        console.log('üîÑ Connection ready delay completed, checking connection state...');
                        console.log('üîç Connection state:', conn.readyState, 'Open:', conn.open);
                        
                        if (this.isHost) {
                            console.log('üì° Host sending ROOM_JOINED to:', conn.peer);
                            
                            // Use enhanced sendToPlayer with connection readiness waiting
                            const sendResult = this.sendToPlayer(conn.peer, 
                                { type: 'ROOM_JOINED', roomCode: this.roomCode },
                                { waitForReady: true, retries: 3, retryDelay: 200 }
                            );
                            
                            // Handle both sync and async results
                            const handleResult = (result) => {
                                if (result.success) {
                                    console.log('‚úÖ ROOM_JOINED sent successfully:', result);
                                    // Only send game state if initial message succeeded
                                    setTimeout(() => {
                                        console.log('üì° Host also sending current game state to new player');
                                        this.broadcastGameState();
                                    }, 100);
                                } else {
                                    console.log('‚ùå ROOM_JOINED failed after retries:', result);
                                    // Fallback: try one more time without waiting
                                    setTimeout(() => {
                                        this.sendToPlayer(conn.peer, 
                                            { type: 'ROOM_JOINED', roomCode: this.roomCode },
                                            { waitForReady: false, retries: 0 }
                                        );
                                        this.broadcastGameState();
                                    }, 1000);
                                }
                            };
                            
                            // Handle Promise or immediate result
                            if (sendResult && typeof sendResult.then === 'function') {
                                sendResult.then(handleResult).catch(error => {
                                    console.error('‚ùå ROOM_JOINED promise error:', error);
                                    handleResult({ success: false, error: error.message });
                                });
                            } else {
                                handleResult(sendResult);
                            }
                        } else {
                            console.log('üì° Player sending PLAYER_JOIN to host:', conn.peer);
                            console.log('üè∑Ô∏è Player name at join time:', this.playerName, '(empty is normal)');
                            
                            // Add to debug panel
                            this.logDebugMessage('PLAYER_JOIN', `To host: ${conn.peer}`, 'out');
                            
                            // Use enhanced sendToPlayer with connection readiness waiting
                            const sendResult = this.sendToPlayer(conn.peer, 
                                { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName || 'Player' },
                                { waitForReady: true, retries: 3, retryDelay: 200 }
                            );
                            
                            // Handle both sync and async results
                            const handleResult = (result) => {
                                if (result.success) {
                                    console.log('‚úÖ PLAYER_JOIN sent successfully:', result);
                                } else {
                                    console.log('‚ùå PLAYER_JOIN failed after retries:', result);
                                    // Fallback: try one more time without waiting
                                    setTimeout(() => {
                                        this.sendToPlayer(conn.peer, 
                                            { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName },
                                            { waitForReady: false, retries: 0 }
                                        );
                                    }, 1000);
                                }
                            };
                            
                            // Handle Promise or immediate result
                            if (sendResult && typeof sendResult.then === 'function') {
                                sendResult.then(handleResult).catch(error => {
                                    console.error('‚ùå PLAYER_JOIN promise error:', error);
                                    handleResult({ success: false, error: error.message });
                                });
                            } else {
                                handleResult(sendResult);
                            }
                        }
                    }, 200); // 200ms delay to ensure connection is fully ready
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer);
                });
                
                conn.on('close', () => {
                    console.log('üîå Connection closed with:', conn.peer);
                    this.connections.delete(conn.peer);
                    this.connectionHealth.delete(conn.peer);
                    
                    // Stop monitoring if no connections left
                    if (this.connections.size === 0) {
                        this.stopConnectionMonitoring();
                    }
                    
                    // Remove player from game state if they disconnect
                    if (this.isHost && this.gameState.players.has(conn.peer)) {
                        console.log('‚ûñ Removing disconnected player:', conn.peer);
                        this.gameState.players.delete(conn.peer);
                        this.broadcastGameState();
                    }
                    
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('‚ùå Connection error with', conn.peer, ':', err);
                    
                    // Clean up connection on error
                    this.connections.delete(conn.peer);
                    this.connectionHealth.delete(conn.peer);
                    
                    // Stop monitoring if no connections left
                    if (this.connections.size === 0) {
                        this.stopConnectionMonitoring();
                    }
                    
                    this.updatePlayersDisplay();
                });
            }
            
            handleMessage(message, fromPeer) {
                console.log('üì® Received message:', message.type, 'from:', fromPeer);
                console.log('üì® Message details:', message);
                
                // Add to debug panel
                this.logDebugMessage(message.type, fromPeer, 'in');
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        console.log('üéØ Handling PLAYER_JOIN. I am host?', this.isHost);
                        console.log('üéØ Player joining:', message.playerId, 'Name:', message.playerName);
                        console.log('üéØ Current players before adding:', this.gameState.players.size);
                        if (this.isHost) {
                            console.log('‚ûï Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true
                            });
                            console.log('‚úÖ Player added! New player count:', this.gameState.players.size);
                            console.log('üìã All players now:', Array.from(this.gameState.players.entries()));
                            console.log('üì° Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            console.log('üë§ Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                        }
                        this.updatePlayersDisplay();
                        if (this.isHost) {
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'HOST_PRESENCE':
                        // Host presence detected, no action needed
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        console.log('üì• Received GAME_STATE_UPDATE:', message.gameState);
                        console.log('üîç Before update - players.size:', this.gameState.players.size);
                        
                        // CRITICAL FIX: Rebuild ALL Maps from arrays
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            console.log('üîÑ Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                console.log('‚ûï Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            console.log('‚úÖ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        // Rebuild other Maps from arrays
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        // Update scalar properties only
                        const { players, guesses, votes, scores, playerPrompts, ...scalarState } = message.gameState;
                        Object.assign(this.gameState, scalarState);
                        
                        console.log('üìä Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        this.updateCanvas(message.canvasData);
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'HEARTBEAT':
                        // Update connection health tracking
                        this.connectionHealth.set(fromPeer, message.timestamp || Date.now());
                        console.log(`üíì Heartbeat received from ${fromPeer}`);
                        
                        // Respond with heartbeat ack if we're the host
                        if (this.isHost) {
                            // Use lightweight options for heartbeat - no retries to avoid overhead
                            this.sendToPlayer(fromPeer, {
                                type: 'HEARTBEAT_ACK',
                                timestamp: Date.now()
                            }, { waitForReady: false, retries: 0 });
                        }
                        break;
                        
                    case 'HEARTBEAT_ACK':
                        // Update connection health tracking
                        this.connectionHealth.set(fromPeer, message.timestamp || Date.now());
                        console.log(`üíì Heartbeat ACK received from ${fromPeer}`);
                        break;
                }
            }
            
            sendToPlayer(playerId, message, options = {}) {
                const {
                    timeout = 5000,
                    retries = 2,
                    retryDelay = 1000,
                    waitForReady = true
                } = options;
                
                const startTime = Date.now();
                
                // Enhanced status object with detailed information
                const createStatus = (success, details = {}) => ({
                    success,
                    playerId,
                    messageType: message.type,
                    timestamp: Date.now(),
                    duration: Date.now() - startTime,
                    ...details
                });
                
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    try {
                        this.broadcastLocal(message);
                        return createStatus(true, { method: 'localStorage' });
                    } catch (error) {
                        return createStatus(false, { 
                            error: error.message, 
                            method: 'localStorage' 
                        });
                    }
                }
                
                const conn = this.connections.get(playerId);
                if (!conn) {
                    console.warn(`‚ö†Ô∏è No connection found for player: ${playerId}`);
                    return createStatus(false, { 
                        error: 'No connection found',
                        connectionExists: false
                    });
                }
                
                // Enhanced connection validation with timing consideration
                const validateConnection = () => {
                    if (!conn) return { valid: false, reason: 'Connection is null' };
                    if (conn.destroyed) return { valid: false, reason: 'Connection destroyed' };
                    if (!conn.open) return { valid: false, reason: 'Connection not open' };
                    if (conn.readyState !== 'open') return { 
                        valid: false, 
                        reason: `Connection state: ${conn.readyState}` 
                    };
                    return { valid: true };
                };
                
                // Recursive function to attempt sending with retries
                const attemptSend = async (attempt = 0) => {
                    const validation = validateConnection();
                    
                    if (!validation.valid) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} invalid: ${validation.reason}`);
                        
                        // If we should wait for connection to be ready and we have retries left
                        if (waitForReady && attempt < retries && validation.reason.includes('state')) {
                            console.log(`üîÑ Waiting for connection to be ready (attempt ${attempt + 1}/${retries + 1})`);
                            
                            // Wait for connection to be ready or timeout
                            const readyPromise = new Promise((resolve) => {
                                const checkReady = () => {
                                    const newValidation = validateConnection();
                                    if (newValidation.valid) {
                                        resolve(true);
                                    } else if (Date.now() - startTime > timeout) {
                                        resolve(false);
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                setTimeout(checkReady, retryDelay);
                            });
                            
                            const isReady = await readyPromise;
                            if (isReady) {
                                return attemptSend(attempt + 1);
                            }
                        }
                        
                        // Clean up dead connection
                        this.connections.delete(playerId);
                        
                        // Attempt reconnection for critical messages
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                    
                    try {
                        // Send the message
                        conn.send(message);
                        console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        
                        // Update connection health
                        this.connectionHealth.set(playerId, Date.now());
                        
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            attemptsUsed: attempt + 1,
                            method: 'peerjs'
                        });
                        
                    } catch (error) {
                        console.error(`‚ùå Send attempt ${attempt + 1} failed to ${playerId}:`, error);
                        
                        // If we have retries left, try again
                        if (attempt < retries) {
                            console.log(`üîÑ Retrying send to ${playerId} in ${retryDelay}ms`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return attemptSend(attempt + 1);
                        }
                        
                        // Clean up failed connection
                        this.connections.delete(playerId);
                        
                        // Attempt reconnection on certain errors
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                };
                
                // For non-async context, we need to handle the Promise
                if (waitForReady || retries > 0) {
                    // Return a Promise for better async handling
                    return attemptSend();
                } else {
                    // Synchronous single attempt for backwards compatibility
                    const validation = validateConnection();
                    if (!validation.valid) {
                        this.connections.delete(playerId);
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                    
                    try {
                        conn.send(message);
                        console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        this.connectionHealth.set(playerId, Date.now());
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            method: 'peerjs'
                        });
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        this.connections.delete(playerId);
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                }
            }
            
            // Helper method for reliable message sending with error handling
            async sendReliably(playerId, message, options = {}) {
                const defaultOptions = {
                    waitForReady: true,
                    retries: 2,
                    retryDelay: 500,
                    ...options
                };
                
                try {
                    const result = await this.sendToPlayer(playerId, message, defaultOptions);
                    
                    if (result.success) {
                        console.log(`‚úÖ Reliable send success to ${playerId}:`, result);
                        return result;
                    } else {
                        console.warn(`‚ö†Ô∏è Reliable send failed to ${playerId}:`, result);
                        // Show user feedback for critical failures
                        if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                            this.showToast(`Failed to send ${message.type.toLowerCase()} - connection issue`, 'warning');
                        }
                        return result;
                    }
                } catch (error) {
                    console.error(`‚ùå Reliable send error to ${playerId}:`, error);
                    const errorResult = {
                        success: false,
                        error: error.message,
                        playerId,
                        messageType: message.type,
                        timestamp: Date.now()
                    };
                    
                    // Show user feedback for critical failures
                    if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                        this.showToast(`Network error sending ${message.type.toLowerCase()}`, 'error');
                    }
                    
                    return errorResult;
                }
            }
            
            broadcastMessage(message) {
                // Add to debug panel
                this.logDebugMessage(`BROADCAST_${message.type}`, `To ${this.connections.size} players`, 'out');
                
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    this.broadcastLocal(message);
                    return;
                }
                
                // Track failed connections for cleanup
                const failedConnections = [];
                let successfulSends = 0;
                
                this.connections.forEach((conn, playerId) => {
                    try {
                        // Check if connection is still valid
                        if (conn && conn.open && conn.readyState === 'open') {
                            conn.send(message);
                            successfulSends++;
                            console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        } else {
                            console.warn(`‚ö†Ô∏è Connection to ${playerId} is not open:`, conn ? conn.readyState : 'null');
                            failedConnections.push(playerId);
                        }
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        failedConnections.push(playerId);
                        
                        // Attempt to reconnect on certain errors
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                    }
                });
                
                // Clean up failed connections
                if (failedConnections.length > 0) {
                    console.log(`üßπ Cleaning up ${failedConnections.length} failed connections`);
                    failedConnections.forEach(playerId => {
                        this.connections.delete(playerId);
                        
                        // Remove from game state if host
                        if (this.isHost && this.gameState.players.has(playerId)) {
                            console.log(`‚ûñ Removing disconnected player from game state: ${playerId}`);
                            this.gameState.players.delete(playerId);
                        }
                    });
                    
                    // Update UI after cleanup
                    this.updatePlayersDisplay();
                    
                    // Show notification if significant connection loss
                    if (failedConnections.length > 1) {
                        this.showToast(`Lost connection to ${failedConnections.length} player(s)`, 'warning');
                    }
                }
                
                // Log broadcast summary
                console.log(`üìä Broadcast summary: ${successfulSends} successful, ${failedConnections.length} failed`);
                
                // Return success status for caller to handle
                return {
                    success: successfulSends > 0,
                    successfulSends,
                    failedConnections: failedConnections.length,
                    totalConnections: this.connections.size + failedConnections.length
                };
            }
            
            attemptReconnection(playerId, failedConn) {
                console.log(`üîÑ Attempting reconnection to ${playerId}`);
                
                // Don't attempt reconnection too frequently
                const reconnectKey = `reconnect_${playerId}`;
                const lastAttempt = this[reconnectKey] || 0;
                const now = Date.now();
                
                if (now - lastAttempt < 5000) { // Wait at least 5 seconds between attempts
                    console.log(`‚è≥ Skipping reconnection to ${playerId} - too soon since last attempt`);
                    return;
                }
                
                this[reconnectKey] = now;
                
                // Clean up old connection
                if (failedConn) {
                    try {
                        failedConn.close();
                    } catch (e) {
                        console.log('Connection already closed');
                    }
                }
                
                // For players trying to reconnect to host
                if (!this.isHost && playerId.includes('_HOST')) {
                    console.log('üîå Player attempting to reconnect to host');
                    setTimeout(() => {
                        try {
                            if (this.peer && !this.peer.destroyed) {
                                const conn = this.peer.connect(playerId);
                                this.handleConnection(conn);
                            }
                        } catch (error) {
                            console.error('‚ùå Reconnection attempt failed:', error);
                        }
                    }, 2000);
                }
                
                // For host trying to reconnect to players - players should reconnect to host instead
                else if (this.isHost) {
                    console.log('üè† Host waiting for player to reconnect');
                    // Don't actively try to reconnect as host - let players reconnect to us
                }
            }
            
            startConnectionMonitoring() {
                // Start heartbeat system for connection health monitoring
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                
                this.heartbeatInterval = setInterval(() => {
                    this.sendHeartbeat();
                    this.checkConnectionHealth();
                }, 15000); // Check every 15 seconds
                
                console.log('üíì Connection monitoring started');
            }
            
            stopConnectionMonitoring() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                console.log('üíì Connection monitoring stopped');
            }
            
            sendHeartbeat() {
                const heartbeatMessage = {
                    type: 'HEARTBEAT',
                    timestamp: Date.now(),
                    playerId: this.playerId
                };
                
                // Only send heartbeat if we have active connections
                if (this.connections.size > 0) {
                    this.broadcastMessage(heartbeatMessage);
                }
                
                this.lastHeartbeat = Date.now();
            }
            
            checkConnectionHealth() {
                const now = Date.now();
                const staleConnections = [];
                
                this.connections.forEach((conn, playerId) => {
                    const lastSeen = this.connectionHealth.get(playerId) || now;
                    const timeSinceLastSeen = now - lastSeen;
                    
                    // If we haven't heard from a connection in 45 seconds, consider it stale
                    if (timeSinceLastSeen > 45000) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} appears stale (${Math.round(timeSinceLastSeen/1000)}s)`);
                        staleConnections.push(playerId);
                    }
                    
                    // If connection is not open, mark for cleanup
                    if (!conn.open || conn.readyState !== 'open') {
                        staleConnections.push(playerId);
                    }
                });
                
                // Clean up stale connections
                if (staleConnections.length > 0) {
                    console.log(`üßπ Cleaning up ${staleConnections.length} stale connections`);
                    staleConnections.forEach(playerId => {
                        this.connections.delete(playerId);
                        this.connectionHealth.delete(playerId);
                        
                        if (this.isHost && this.gameState.players.has(playerId)) {
                            this.gameState.players.delete(playerId);
                        }
                    });
                    
                    this.updatePlayersDisplay();
                    
                    if (staleConnections.length > 0) {
                        this.showToast(`Cleaned up ${staleConnections.length} inactive connection(s)`, 'info');
                    }
                }
            }
            
            broadcastGameState() {
                console.log('üì° Broadcasting game state');
                console.log('üìä Current players before broadcast:', this.gameState.players.size);
                console.log('üìã Players being broadcast:', Array.from(this.gameState.players.entries()));
                
                // CRITICAL FIX: Convert ALL Maps to Arrays for serialization
                const gameStateForBroadcast = {
                    currentRound: this.gameState.currentRound || 0,
                    totalRounds: this.gameState.totalRounds || 5,
                    phase: this.gameState.phase || 'lobby',
                    currentDrawer: this.gameState.currentDrawer || null,
                    currentPrompt: this.gameState.currentPrompt || null,
                    timeLeft: this.gameState.timeLeft || 0,
                    players: Array.from(this.gameState.players.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                    playerPrompts: this.gameState.playerPrompts ? Array.from(this.gameState.playerPrompts.entries()) : []
                };
                
                console.log('üì§ Sending GAME_STATE_UPDATE with safe data to', this.connections.size, 'connections');
                console.log('üîç Safe gameState:', gameStateForBroadcast);
                
                const broadcastResult = this.broadcastMessage({
                    type: 'GAME_STATE_UPDATE',
                    gameState: gameStateForBroadcast
                });
                
                // Handle broadcast result for better reliability
                if (broadcastResult && !broadcastResult.success) {
                    console.warn('‚ö†Ô∏è Game state broadcast failed - no active connections');
                    this.showToast('Connection issues detected', 'warning');
                } else if (broadcastResult && broadcastResult.failedConnections > 0) {
                    console.warn(`‚ö†Ô∏è Game state broadcast partial failure: ${broadcastResult.failedConnections} failed connections`);
                    
                    // If we lost more than half the connections, show a warning
                    if (broadcastResult.failedConnections > broadcastResult.successfulSends) {
                        this.showToast('Multiple players disconnected', 'warning');
                    }
                }
            }
            
            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                document.getElementById('room-code').textContent = `Room: ${this.roomCode}`;
                
                // Add current player to game state (don't assume name yet)
                this.gameState.players.set(this.playerId, {
                    id: this.playerId,
                    name: this.playerName || (this.isHost ? 'Host' : 'Player'),
                    score: 0,
                    connected: true
                });
                
                // Focus the name input for easy editing
                setTimeout(() => {
                    const nameInput = document.getElementById('player-name');
                    if (nameInput) {
                        nameInput.focus();
                        nameInput.placeholder = `Enter your name...`;
                    }
                }, 100);
                
                this.updatePlayersDisplay();
                
                // Host presence is now saved immediately in createRoom(), no need to duplicate here
            }
            
            updatePlayersDisplay() {
                console.log('üîÑ updatePlayersDisplay called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                    this.logDebugMessage('MAP_ERROR', 'Players Map corrupted, fixed', 'out');
                    return;
                }
                
                // Update debug panel with current state
                this.updateDebugPanel();
                
                console.log('üìä Current players in gameState:', this.gameState.players.size);
                const playersArray = Array.from(this.gameState.players.entries());
                console.log('üìã Players list:', playersArray);
                playersArray.forEach(([id, player], index) => {
                    console.log(`üë§ Player ${index + 1}: ID=${id}, Name=${player.name}, Connected=${player.connected}`);
                });
                console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                
                this.gameState.players.forEach((player, id) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'bg-gray-800 rounded-lg p-3 flex items-center justify-between';
                    playerDiv.innerHTML = `
                        <div class="flex items-center gap-3">
                            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                                ${player.name.charAt(0).toUpperCase()}
                            </div>
                            <span>${player.name}</span>
                            ${id === this.playerId ? '<span class="text-blue-400">(You)</span>' : ''}
                            ${this.isHost && id === this.playerId ? '<span class="text-yellow-400">(Host)</span>' : ''}
                        </div>
                        <div class="text-sm text-gray-400">
                            Score: ${player.score}
                        </div>
                    `;
                    playersList.appendChild(playerDiv);
                });
                
                this.updateStartButton();
            }
            
            updateStartButton() {
                console.log('üöÄ updateStartButton called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map in updateStartButton!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                }
                
                console.log('üìè gameState.players.size:', this.gameState.players.size);
                console.log('üó∫Ô∏è gameState.players Map:', this.gameState.players);
                console.log('üìù playerName:', this.playerName);
                console.log('üëë isHost:', this.isHost);
                
                const startButton = document.getElementById('start-game');
                const hasName = this.playerName && this.playerName.length > 0;
                const canStart = this.isHost && this.gameState.players.size >= 2 && hasName;
                
                startButton.disabled = !canStart;
                
                const waitingMessage = document.getElementById('waiting-message');
                if (this.gameState.players.size < 2) {
                    waitingMessage.textContent = `Waiting for more players... (need at least 2, have ${this.gameState.players.size})`;
                    console.log('üî¥ Not enough players:', this.gameState.players.size);
                } else if (!hasName) {
                    waitingMessage.textContent = 'Enter your name to continue';
                    console.log('üî¥ No player name');
                } else if (this.isHost) {
                    waitingMessage.textContent = 'Ready to start!';
                    console.log('üü¢ Ready to start!');
                } else {
                    waitingMessage.textContent = 'Waiting for host to start the game...';
                    console.log('üü° Waiting for host');
                }
            }
            
            shareGame() {
                // Generate correct share URL for GitHub Pages
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                const shareUrl = `${window.location.origin}${basePath}/${this.roomCode}`;
                const shareData = {
                    title: 'üé® Join our drawing game!',
                    text: `Game time! Tap to join ‚Üí`,
                    url: shareUrl
                };
                
                if (navigator.share) {
                    navigator.share(shareData).catch(console.error);
                } else {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        this.showToast('Link copied! Send to friends üì±', 'success');
                    }).catch(() => {
                        this.showToast('Share URL: ' + shareUrl, 'info');
                    });
                }
            }
            
            startGame() {
                if (!this.isHost || this.gameState.players.size < 3) return;
                
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.assignPrompts();
                this.broadcastGameState();
                this.broadcastMessage({ type: 'START_GAME' });
                this.handleStartGame();
            }
            
            handleStartGame() {
                this.showDrawingScreen();
                this.startDrawingTimer();
            }
            
            assignPrompts() {
                // Assign unique prompts to each player
                const prompts = this.getRandomPrompts(this.gameState.players.size);
                const playerIds = Array.from(this.gameState.players.keys());
                
                this.gameState.playerPrompts = new Map();
                playerIds.forEach((playerId, index) => {
                    this.gameState.playerPrompts.set(playerId, prompts[index]);
                });
            }
            
            getRandomPrompts(count) {
                const allPrompts = [
                    "Robot eating pizza", "Cat playing guitar", "Dinosaur on skateboard",
                    "Wizard making coffee", "Shark wearing hat", "Invisible man in mirror",
                    "Spaghetti tornado", "Crying birthday cake", "Dancing refrigerator", 
                    "Sneezing volcano", "Time-traveling sandwich", "Vampire dentist appointment",
                    "Yoga class for furniture", "Cow abducting aliens", "Angry broccoli army",
                    "Romantic dinner between phones", "Hamster business meeting", "Cactus beauty pageant",
                    "Penguin fire department", "Banana phone tech support", "Pirate scared of water",
                    "Grandma vs. ninja squirrels", "Battle of the condiments", "Escape from vegetable prison",
                    "Racing shopping carts downhill", "Dodgeball with planets", "Santa's summer vacation",
                    "Halloween costume for house", "Turkey plotting revenge", "New Year's Eve for clocks",
                    "Valentine's Day for robots", "Ninja fighting a pi√±ata", "Octopus bartender",
                    "Vampire accountant", "Cowboy surfing in space", "Grandma skateboarding in a volcano",
                    "The feeling of Monday", "WiFi signal as a person", "Procrastination monster",
                    "Sound of silence", "Upside-down gravity", "Sleepy ninja eating spaghetti",
                    "Angry dentist fighting a balloon", "Banana driving a car", "Pizza doing yoga",
                    "Dinosaur mixed with disco ball", "Submarine mixed with birthday cake"
                ];
                
                const shuffled = allPrompts.sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            showDrawingScreen() {
                this.showScreen('drawing-screen');
                const myPrompt = this.gameState.playerPrompts?.get(this.playerId) || 'Draw something fun!';
                document.getElementById('drawing-prompt').textContent = `Draw this: ${myPrompt}`;
                
                // Clear and prepare canvas
                this.clearCanvas();
                this.updateToolButtons();
            }
            
            startDrawingTimer() {
                let timeLeft = 60;
                const timerElement = document.getElementById('drawing-timer');
                
                const timer = setInterval(() => {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (timeLeft <= 10) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.endDrawingPhase();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            endDrawingPhase() {
                if (this.isHost) {
                    this.gameState.phase = 'GUESSING';
                    this.selectRandomDrawing();
                    this.broadcastGameState();
                }
                this.showGuessingScreen();
            }
            
            selectRandomDrawing() {
                const playerIds = Array.from(this.gameState.players.keys());
                const randomIndex = Math.floor(Math.random() * playerIds.length);
                this.gameState.currentArtist = playerIds[randomIndex];
                this.gameState.currentPrompt = this.gameState.playerPrompts.get(this.gameState.currentArtist);
                
                // Capture canvas data (in real implementation, this would be sent from the artist)
                const canvas = document.getElementById('drawing-canvas');
                this.gameState.currentDrawing = canvas.toDataURL();
            }
            
            showGuessingScreen() {
                this.showScreen('guessing-screen');
                
                // Copy drawing to guess canvas
                const sourceCanvas = document.getElementById('drawing-canvas');
                const guessCanvas = document.getElementById('guess-canvas');
                const ctx = guessCanvas.getContext('2d');
                
                if (this.gameState.currentDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = this.gameState.currentDrawing;
                } else {
                    ctx.drawImage(sourceCanvas, 0, 0);
                }
                
                const artistName = this.gameState.players.get(this.gameState.currentArtist)?.name || 'Someone';
                document.getElementById('artist-name').textContent = `Drawn by ${artistName}`;
                
                this.startGuessingTimer();
            }
            
            startGuessingTimer() {
                let timeLeft = 30;
                const timerElement = document.getElementById('guessing-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.submitGuess();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitGuess() {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();
                
                if (!guess) {
                    this.showToast('Please enter a guess!', 'warning');
                    return;
                }
                
                if (this.isHost) {
                    this.gameState.guesses.set(this.playerId, guess);
                    this.checkAllGuessesSubmitted();
                } else {
                    // Use enhanced sendToPlayer for better reliability
                    const sendResult = this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'GUESS_SUBMITTED',
                        playerId: this.playerId,
                        guess: guess
                    }, { waitForReady: true, retries: 2 });
                    
                    // Handle async result if needed
                    if (sendResult && typeof sendResult.then === 'function') {
                        sendResult.then(result => {
                            if (!result.success) {
                                console.warn('Failed to submit guess:', result);
                                this.showToast('Failed to submit guess - please try again', 'error');
                            }
                        });
                    }
                }
                
                guessInput.disabled = true;
                document.getElementById('submit-guess').disabled = true;
                this.showToast('Guess submitted!', 'success');
            }
            
            checkAllGuessesSubmitted() {
                if (this.gameState.guesses.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.startVotingPhase();
                }
            }
            
            startVotingPhase() {
                this.gameState.phase = 'VOTING';
                this.broadcastGameState();
                this.showVotingScreen();
            }
            
            showVotingScreen() {
                this.showScreen('voting-screen');
                
                // Copy drawing to vote canvas
                const voteCanvas = document.getElementById('vote-canvas');
                const ctx = voteCanvas.getContext('2d');
                
                if (this.gameState.currentDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, voteCanvas.width, voteCanvas.height);
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = this.gameState.currentDrawing;
                }
                
                this.displayVotingOptions();
                this.startVotingTimer();
            }
            
            displayVotingOptions() {
                const votingOptions = document.getElementById('voting-options');
                votingOptions.innerHTML = '';
                
                // Collect all answers plus the real one
                const allOptions = Array.from(this.gameState.guesses.values());
                allOptions.push(this.gameState.currentPrompt);
                
                // Shuffle options
                const shuffledOptions = allOptions.sort(() => 0.5 - Math.random());
                
                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded-lg p-4 text-left transition-colors';
                    button.textContent = option;
                    button.addEventListener('click', () => this.submitVote(option));
                    votingOptions.appendChild(button);
                });
            }
            
            startVotingTimer() {
                let timeLeft = 20;
                const timerElement = document.getElementById('voting-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        // Auto-submit random vote if no vote made
                        if (!this.gameState.votes.has(this.playerId)) {
                            const options = Array.from(document.getElementById('voting-options').children);
                            const randomOption = options[Math.floor(Math.random() * options.length)];
                            this.submitVote(randomOption.textContent);
                        }
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitVote(vote) {
                if (this.isHost) {
                    this.gameState.votes.set(this.playerId, vote);
                    this.checkAllVotesSubmitted();
                } else {
                    // Use enhanced sendToPlayer for better reliability
                    const sendResult = this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'VOTE_SUBMITTED',
                        playerId: this.playerId,
                        vote: vote
                    }, { waitForReady: true, retries: 2 });
                    
                    // Handle async result if needed
                    if (sendResult && typeof sendResult.then === 'function') {
                        sendResult.then(result => {
                            if (!result.success) {
                                console.warn('Failed to submit vote:', result);
                                this.showToast('Failed to submit vote - please try again', 'error');
                            }
                        });
                    }
                }
                
                // Disable all voting buttons
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.textContent === vote) {
                        btn.classList.add('bg-blue-600');
                    }
                });
                
                this.showToast('Vote submitted!', 'success');
            }
            
            checkAllVotesSubmitted() {
                if (this.gameState.votes.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.calculateScores();
                    this.showResults();
                }
            }
            
            calculateScores() {
                // Award points based on voting results
                this.gameState.votes.forEach((vote, voterId) => {
                    // Points for correct guesses
                    if (vote === this.gameState.currentPrompt) {
                        const player = this.gameState.players.get(voterId);
                        if (player) {
                            player.score += 200;
                        }
                    }
                    
                    // Points for tricking others with fake answers
                    this.gameState.guesses.forEach((guess, guesserId) => {
                        if (vote === guess && voterId !== guesserId) {
                            const trickster = this.gameState.players.get(guesserId);
                            if (trickster) {
                                trickster.score += 50;
                            }
                        }
                    });
                });
                
                // Points for artist (per correct guess)
                let correctGuesses = 0;
                this.gameState.votes.forEach(vote => {
                    if (vote === this.gameState.currentPrompt) {
                        correctGuesses++;
                    }
                });
                
                const artist = this.gameState.players.get(this.gameState.currentArtist);
                if (artist) {
                    artist.score += correctGuesses * 100;
                }
            }
            
            showResults() {
                this.showScreen('results-screen');
                
                const resultsContent = document.getElementById('results-content');
                resultsContent.innerHTML = '';
                
                // Show the reveal
                const revealDiv = document.createElement('div');
                revealDiv.className = 'bg-gray-800 rounded-lg p-4 mb-4';
                revealDiv.innerHTML = `
                    <div class="text-center mb-4">
                        <div class="text-lg font-bold">The real answer was...</div>
                        <div class="text-2xl font-bold text-green-400 mt-2">"${this.gameState.currentPrompt}"</div>
                        <div class="text-sm text-gray-400 mt-1">Drawn by ${this.gameState.players.get(this.gameState.currentArtist)?.name}</div>
                    </div>
                `;
                
                // Show vote breakdown
                const voteBreakdown = document.createElement('div');
                voteBreakdown.className = 'space-y-2';
                
                const voteCounts = new Map();
                this.gameState.votes.forEach(vote => {
                    voteCounts.set(vote, (voteCounts.get(vote) || 0) + 1);
                });
                
                voteCounts.forEach((count, answer) => {
                    const isCorrect = answer === this.gameState.currentPrompt;
                    const submitter = Array.from(this.gameState.guesses.entries()).find(([id, guess]) => guess === answer)?.[0];
                    const submitterName = submitter ? this.gameState.players.get(submitter)?.name : 'Original';
                    
                    const voteDiv = document.createElement('div');
                    voteDiv.className = `p-3 rounded ${isCorrect ? 'bg-green-600' : 'bg-gray-700'}`;
                    voteDiv.innerHTML = `
                        <div class="font-bold">"${answer}"</div>
                        <div class="text-sm text-gray-300">by ${submitterName} ‚Ä¢ ${count} vote${count !== 1 ? 's' : ''}</div>
                    `;
                    voteBreakdown.appendChild(voteDiv);
                });
                
                revealDiv.appendChild(voteBreakdown);
                resultsContent.appendChild(revealDiv);
                
                // Show updated scores
                const scoresDiv = document.createElement('div');
                scoresDiv.className = 'bg-gray-800 rounded-lg p-4';
                scoresDiv.innerHTML = '<div class="text-lg font-bold mb-3">Scores:</div>';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'flex justify-between items-center py-2';
                    playerDiv.innerHTML = `
                        <span>${index + 1}. ${player.name}</span>
                        <span class="font-bold">${player.score}</span>
                    `;
                    scoresDiv.appendChild(playerDiv);
                });
                
                resultsContent.appendChild(scoresDiv);
                
                this.broadcastGameState();
            }
            
            nextRound() {
                if (this.gameState.currentRound >= this.gameState.totalRounds) {
                    this.showFinalResults();
                } else {
                    this.gameState.currentRound++;
                    this.gameState.phase = 'DRAWING';
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    
                    this.assignPrompts();
                    this.broadcastGameState();
                    this.handleStartGame();
                }
            }
            
            showFinalResults() {
                this.showScreen('final-scores-screen');
                
                const finalScoresContent = document.getElementById('final-scores-content');
                finalScoresContent.innerHTML = '';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `bg-gray-800 rounded-lg p-4 mb-3 ${index === 0 ? 'border-2 border-yellow-400' : ''}`;
                    
                    let medal = '';
                    if (index === 0) medal = 'üèÜ';
                    else if (index === 1) medal = 'ü•à';
                    else if (index === 2) medal = 'ü•â';
                    
                    playerDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">${medal}</span>
                                <div>
                                    <div class="font-bold text-lg">${player.name}</div>
                                    <div class="text-sm text-gray-400">${index === 0 ? 'Winner!' : `${index + 1}${this.getOrdinalSuffix(index + 1)} place`}</div>
                                </div>
                            </div>
                            <div class="text-2xl font-bold">${player.score}</div>
                        </div>
                    `;
                    finalScoresContent.appendChild(playerDiv);
                });
            }
            
            getOrdinalSuffix(num) {
                const j = num % 10;
                const k = num % 100;
                if (j == 1 && k != 11) return "st";
                if (j == 2 && k != 12) return "nd";
                if (j == 3 && k != 13) return "rd";
                return "th";
            }
            
            playAgain() {
                // Reset game state for new game with same players
                this.gameState.currentRound = 0;
                this.gameState.phase = 'LOBBY';
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                
                // Reset player scores
                this.gameState.players.forEach(player => {
                    player.score = 0;
                });
                
                this.broadcastGameState();
                this.showLobby();
            }
            
            newGame() {
                // Redirect to home page for completely new game
                window.location.href = '/';
            }
            
            broadcastDrawingData() {
                const canvas = document.getElementById('drawing-canvas');
                const dataURL = canvas.toDataURL();
                
                this.broadcastMessage({
                    type: 'DRAWING_UPDATE',
                    canvasData: dataURL
                });
            }
            
            updateCanvas(dataURL) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = dataURL;
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connection-status');
                statusElement.textContent = status;
                
                if (status.includes('error')) {
                    statusElement.className = 'text-sm mt-1 text-red-400';
                } else {
                    statusElement.className = 'text-sm mt-1 text-green-400';
                }
            }
            
            showScreen(screenId) {
                // Hide all screens
                document.querySelectorAll('[id$="-screen"]').forEach(screen => {
                    screen.classList.add('hidden');
                });
                
                // Show target screen
                document.getElementById(screenId).classList.remove('hidden');
            }
            
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast px-4 py-2 rounded shadow-lg ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    type === 'warning' ? 'bg-yellow-500' : 
                    'bg-blue-500'
                } text-white`;
                
                toast.classList.remove('hidden');
                
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 3000);
            }
            
            updateUI() {
                // Update UI based on current game state
                switch (this.gameState.phase) {
                    case 'LOBBY':
                        this.updatePlayersDisplay();
                        break;
                    case 'DRAWING':
                        // Drawing phase UI updates
                        break;
                    case 'GUESSING':
                        // Update guessing display
                        break;
                    case 'VOTING':
                        // Update voting display
                        break;
                }
            }
        }
        
        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DrawPartyGame();
        });
        
        // Handle page refresh/reconnection
        window.addEventListener('beforeunload', () => {
            if (window.game) {
                // Stop connection monitoring
                window.game.stopConnectionMonitoring();
                
                // Disconnect peer
                if (window.game.peer) {
                    window.game.peer.disconnect();
                }
            }
        });
        
        // Register Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Handle GitHub Pages path
                const swPath = window.location.hostname === 'astraldrift.github.io' ? '/draw-party-game/sw.js' : '/sw.js';
                navigator.serviceWorker.register(swPath)
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Listen for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available, could show update prompt
                                        console.log('New version available');
                                    }
                                });
                            }
                        });
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'RECONNECT_GAME') {
                        // Attempt to reconnect to game
                        if (window.game && window.game.roomCode) {
                            window.game.initializePeer();
                        }
                    }
                });
            });
        }
    </script>
</body>
</html>