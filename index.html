<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! üé®</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/draw-party-game/manifest.json">
    <meta name="theme-color" content="#1f2937">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        /* Custom styles for canvas and animations */
        .canvas-container {
            touch-action: none;
            position: relative;
            width: 100%;
            max-width: min(90vw, 90vh, 500px);
            aspect-ratio: 4/3;
            margin: 0 auto;
        }
        
        .drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Mobile-specific canvas optimization */
        @media (max-width: 768px) {
            .canvas-container {
                max-width: min(95vw, 80vh);
                padding: 0 10px;
            }
            
            /* Mobile-optimized touch targets */
            .mobile-touch-target {
                min-width: 44px !important;
                min-height: 44px !important;
                padding: 8px 12px !important;
            }
            
            .color-btn.mobile-touch-target {
                width: 40px !important;
                height: 40px !important;
                margin: 2px;
            }
            
            /* Show mobile text, hide desktop text */
            .mobile-text {
                display: inline !important;
            }
            
            .desktop-text {
                display: none !important;
            }
            
            /* Optimize tool layout for mobile */
            #drawing-tools {
                gap: 8px !important;
                margin-bottom: 1rem !important;
            }
            
            #color-palette, #tool-palette {
                padding: 8px !important;
                gap: 4px !important;
            }
        }
        
        @media (max-height: 600px) {
            .canvas-container {
                max-width: min(90vw, 60vh);
            }
            
            /* Compact layout for landscape orientation */
            #drawing-tools {
                margin-bottom: 0.5rem !important;
            }
        }
        
        /* Enhanced touch feedback */
        .mobile-touch-target:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }
        
        /* Prevent text selection on mobile tools */
        .mobile-touch-target {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        .bounce {
            animation: bounce 0.6s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        /* Prevent zoom on double tap */
        * {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div id="app" class="min-h-screen flex flex-col">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">üé®</div>
                <div class="text-2xl font-bold mb-2">Draw Party!</div>
                <div class="text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-4 py-2 rounded shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col">
            <!-- Header -->
            <header class="bg-gray-800 p-4 text-center">
                <h1 class="text-2xl font-bold">üé® Draw Party!</h1>
                <div id="room-code" class="text-gray-400 mt-1"></div>
                <div id="connection-status" class="text-sm mt-1"></div>
                
                <!-- Debug Dashboard -->
                <div id="debug-panel" class="mt-2 p-2 bg-gray-900 rounded text-xs text-left hidden">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold text-yellow-400">üîç Debug Dashboard</span>
                        <button id="toggle-debug" class="text-blue-400 hover:text-blue-300">Hide</button>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div>
                            <div class="text-gray-400">Mode:</div>
                            <div id="debug-mode" class="text-white font-mono">-</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Connections:</div>
                            <div id="debug-connections" class="text-white font-mono">0</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Players in State:</div>
                            <div id="debug-players" class="text-white font-mono">0</div>
                        </div>
                        <div>
                            <div class="text-gray-400">Role:</div>
                            <div id="debug-role" class="text-white font-mono">-</div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-gray-400">Last Message:</div>
                        <div id="debug-last-message" class="text-green-400 font-mono text-xs">None</div>
                    </div>
                    <div class="mt-2">
                        <div class="text-gray-400">Message Log:</div>
                        <div id="debug-message-log" class="text-xs font-mono max-h-20 overflow-y-auto bg-black p-1 rounded"></div>
                    </div>
                </div>
                
                <!-- Debug Toggle Button -->
                <button id="show-debug" class="mt-1 text-xs text-blue-400 hover:text-blue-300">Show Debug Panel</button>
            </header>
            
            <!-- Game Content -->
            <main class="flex-1 p-4">
                <!-- Welcome Screen -->
                <div id="welcome-screen" class="text-center max-w-md mx-auto">
                    <div class="text-6xl mb-6">üé®</div>
                    <h2 class="text-3xl font-bold mb-4">Welcome to Draw Party!</h2>
                    <p class="text-gray-400 mb-8">The easiest multiplayer drawing game ever - just share a link!</p>
                    
                    <div class="space-y-4">
                        <button id="create-room" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                            üéÆ Create New Game
                        </button>
                        <div class="text-gray-500">or</div>
                        <div class="flex gap-2">
                            <input id="join-code" type="text" placeholder="Enter room code" 
                                   class="flex-1 bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-center uppercase" 
                                   maxlength="4">
                            <button id="join-room" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                                Join
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Lobby Screen -->
                <div id="lobby-screen" class="hidden max-w-md mx-auto">
                    <div class="text-center mb-6">
                        <div class="text-4xl mb-2">üè†</div>
                        <h2 class="text-2xl font-bold mb-2">Game Lobby</h2>
                        <div class="bg-gray-800 rounded-lg p-4 mb-4">
                            <div class="text-sm text-gray-400">Room Code</div>
                            <div id="current-room-code" class="text-3xl font-mono font-bold"></div>
                        </div>
                        
                        <button id="share-game" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg mb-4">
                            üì± Share Game Link
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-bold mb-3">Players:</h3>
                        <div id="players-list" class="space-y-2"></div>
                        <div id="waiting-message" class="text-gray-400 text-center mt-4">
                            Waiting for more players... (need at least 2)
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <input id="player-name" type="text" placeholder="Enter your name" 
                                   class="flex-1 bg-gray-800 border border-gray-600 rounded-lg px-4 py-3">
                            <button id="submit-name" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg">
                                ‚úì
                            </button>
                        </div>
                        <button id="start-game" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                            üé® Start Drawing!
                        </button>
                    </div>
                </div>
                
                <!-- Drawing Screen -->
                <div id="drawing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <div id="drawing-prompt" class="text-xl font-bold mb-2 bg-blue-600 rounded-lg p-4"></div>
                        <div id="drawing-timer" class="text-2xl font-mono"></div>
                    </div>
                    
                    <div class="canvas-container mx-auto mb-4" id="canvas-container">
                        <canvas id="drawing-canvas" class="drawing-canvas w-full"></canvas>
                    </div>
                    
                    <div class="flex flex-wrap gap-2 justify-center mb-4" id="drawing-tools">
                        <!-- Color palette -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2" id="color-palette">
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-black border-2 border-white" data-color="#000000"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-red-500" data-color="#ef4444"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-blue-500" data-color="#3b82f6"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-green-500" data-color="#10b981"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-yellow-500" data-color="#f59e0b"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-purple-500" data-color="#8b5cf6"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-pink-500" data-color="#ec4899"></button>
                            <button class="color-btn mobile-touch-target w-8 h-8 rounded-full bg-orange-500" data-color="#f97316"></button>
                        </div>
                        
                        <!-- Tools -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2" id="tool-palette">
                            <button id="brush-small" class="tool-btn mobile-touch-target bg-gray-600 hover:bg-gray-500 active:bg-gray-400 px-3 py-2 rounded text-sm transition-colors">
                                <span class="desktop-text">Small</span>
                                <span class="mobile-text hidden">S</span>
                            </button>
                            <button id="brush-medium" class="tool-btn mobile-touch-target bg-blue-600 hover:bg-blue-500 active:bg-blue-400 px-3 py-2 rounded text-sm transition-colors">
                                <span class="desktop-text">Medium</span>
                                <span class="mobile-text hidden">M</span>
                            </button>
                            <button id="brush-large" class="tool-btn mobile-touch-target bg-gray-600 hover:bg-gray-500 active:bg-gray-400 px-3 py-2 rounded text-sm transition-colors">
                                <span class="desktop-text">Large</span>
                                <span class="mobile-text hidden">L</span>
                            </button>
                            <button id="eraser" class="tool-btn mobile-touch-target bg-gray-600 hover:bg-gray-500 active:bg-gray-400 px-3 py-2 rounded text-sm transition-colors">
                                <span class="desktop-text">Eraser</span>
                                <span class="mobile-text hidden">üóëÔ∏è</span>
                            </button>
                            <button id="clear-canvas" class="tool-btn mobile-touch-target bg-red-600 hover:bg-red-500 active:bg-red-400 px-3 py-2 rounded text-sm transition-colors">
                                <span class="desktop-text">Clear</span>
                                <span class="mobile-text hidden">‚úñÔ∏è</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div class="text-sm text-gray-400 mb-2">‚ö†Ô∏è No letters or words allowed!</div>
                        <div id="other-players-status" class="text-gray-400"></div>
                    </div>
                </div>
                
                <!-- Guessing Screen -->
                <div id="guessing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">What do you think this is?</h2>
                        <div id="guessing-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400 mb-4">Write the real answer OR something funny to trick others!</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <div class="canvas-container">
                            <canvas id="guess-canvas" class="drawing-canvas"></canvas>
                        </div>
                        <div class="text-center mt-2 text-sm text-gray-400" id="artist-name"></div>
                    </div>
                    
                    <div class="max-w-md mx-auto">
                        <input id="guess-input" type="text" placeholder="What is this drawing?" 
                               class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 mb-4">
                        <button id="submit-guess" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            Submit Answer
                        </button>
                    </div>
                </div>
                
                <!-- Voting Screen -->
                <div id="voting-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">Which is the REAL answer?</h2>
                        <div id="voting-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400">Vote for what you think was the original prompt</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <div class="canvas-container">
                            <canvas id="vote-canvas" class="drawing-canvas"></canvas>
                        </div>
                    </div>
                    
                    <div id="voting-options" class="space-y-3 max-w-md mx-auto">
                        <!-- Voting options will be populated here -->
                    </div>
                </div>
                
                <!-- Results Screen -->
                <div id="results-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üéâ Round Results!</h2>
                    </div>
                    
                    <div id="results-content" class="max-w-md mx-auto">
                        <!-- Results will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6">
                        <button id="next-round" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            Next Round üé®
                        </button>
                    </div>
                </div>
                
                <!-- Final Scores Screen -->
                <div id="final-scores-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üèÜ Final Results!</h2>
                    </div>
                    
                    <div id="final-scores-content" class="max-w-md mx-auto">
                        <!-- Final scores will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6 space-y-4">
                        <button id="play-again" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            üéÆ Play Again!
                        </button>
                        <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            üé® New Game
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                console.log('üé® Draw Party Game v1.7.9 - NAME SUBMIT BUTTON FIX!', new Date().toISOString());
                console.log('üîß If you see old behavior, clear browser cache or hard refresh (Ctrl+Shift+R)');
                
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5, // Will be updated from gameConfig after initialization
                    currentArtist: null,
                    currentDrawing: null,
                    currentPrompt: '',
                    guesses: new Map(),
                    votes: new Map(),
                    scores: new Map(),
                    likes: new Map() // Track likes given by artists
                };
                
                // Drawing canvas state
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.currentSize = 3;
                this.currentTool = 'brush';
                
                // Game configuration with improved defaults
                this.gameConfig = {
                    timers: {
                        drawing: 90,     // Increased from 60s to 90s for more comfortable drawing
                        guessing: 45,    // Increased from 30s to 45s for better thinking time
                        voting: 30       // Increased from 20s to 30s for proper deliberation
                    },
                    gameplay: {
                        minPlayers: 2,
                        maxPlayers: 8,
                        totalRounds: 5
                    },
                    mobile: {
                        drawingThrottleMs: 16,  // ~60fps drawing updates for smooth mobile experience
                        touchDebounceMs: 10,    // Debounce rapid touch events
                        hapticEnabled: true     // Enable haptic feedback if available
                    }
                };
                
                // Update game state with configuration
                this.gameState.totalRounds = this.gameConfig.gameplay.totalRounds;
                
                // Connection monitoring
                this.connectionHealth = new Map();
                this.heartbeatInterval = null;
                this.lastHeartbeat = Date.now();
                
                this.init();
                this.initializeResponsiveCanvas();
                this.initializeMobileTouchIndicator();
            }
            
            initializeResponsiveCanvas() {
                // Set up responsive canvas sizing
                this.resizeCanvas();
                
                // Resize on window resize with debouncing
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.resizeCanvas(), 250);
                });
                
                // Resize on orientation change
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 500);
                });
            }
            
            resizeCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const container = document.getElementById('canvas-container');
                
                if (!canvas || !container) return;
                
                // Get container dimensions
                const containerRect = container.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                
                // Use device pixel ratio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas actual size (scaled for device pixel ratio)
                canvas.width = containerWidth * dpr;
                canvas.height = containerHeight * dpr;
                
                // Scale canvas back down using CSS
                canvas.style.width = containerWidth + 'px';
                canvas.style.height = containerHeight + 'px';
                
                // Scale the drawing context to account for device pixel ratio
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                
                // Reset canvas background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, containerWidth, containerHeight);
                
                console.log(`üì± Canvas resized: ${containerWidth}x${containerHeight} (DPR: ${dpr})`);
            }
            
            setupCanvasSize(canvas) {
                if (!canvas) return;
                
                const container = canvas.parentElement;
                const containerRect = container.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                
                // Use device pixel ratio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas actual size (scaled for device pixel ratio)
                canvas.width = containerWidth * dpr;
                canvas.height = containerHeight * dpr;
                
                // Scale canvas back down using CSS
                canvas.style.width = containerWidth + 'px';
                canvas.style.height = containerHeight + 'px';
                
                // Scale the drawing context to account for device pixel ratio
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                
                // Reset canvas background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, containerWidth, containerHeight);
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
            
            // Debug Dashboard Functions
            updateDebugPanel() {
                const mode = this.isLocalMode ? 'LOCAL' : 'P2P';
                const connections = this.connections ? this.connections.size : 0;
                const players = this.gameState.players ? this.gameState.players.size : 0;
                const role = this.isHost ? 'HOST' : 'PLAYER';
                
                const debugMode = document.getElementById('debug-mode');
                const debugConnections = document.getElementById('debug-connections');
                const debugPlayers = document.getElementById('debug-players');
                const debugRole = document.getElementById('debug-role');
                
                if (debugMode) debugMode.textContent = mode;
                if (debugConnections) debugConnections.textContent = connections;
                if (debugPlayers) debugPlayers.textContent = players;
                if (debugRole) debugRole.textContent = role;
            }
            
            logDebugMessage(type, message, direction = 'out') {
                const timestamp = new Date().toLocaleTimeString();
                const arrow = direction === 'out' ? '‚Üí' : '‚Üê';
                const color = direction === 'out' ? 'text-blue-400' : 'text-green-400';
                
                // Update last message
                const lastMsg = document.getElementById('debug-last-message');
                if (lastMsg) {
                    lastMsg.textContent = `${arrow} ${type}`;
                    lastMsg.className = `${color} font-mono text-xs`;
                }
                
                // Add to message log
                const log = document.getElementById('debug-message-log');
                if (log) {
                    const entry = document.createElement('div');
                    entry.className = `${color}`;
                    entry.textContent = `${timestamp} ${arrow} ${type}`;
                    log.appendChild(entry);
                    log.scrollTop = log.scrollHeight;
                    
                    // Keep only last 10 messages
                    while (log.children.length > 10) {
                        log.removeChild(log.firstChild);
                    }
                }
                
                // Update the debug panel
                this.updateDebugPanel();
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas();
                this.checkForRoomInURL();
            }
            
            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 1000);
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                
                // Extract room code from various URL formats:
                // localhost:3000/ABCD -> ABCD
                // astraldrift.github.io/draw-party-game/ABCD -> ABCD
                let roomCode = null;
                
                if (path.includes('/draw-party-game/')) {
                    // GitHub Pages format
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) {
                        roomCode = parts[1];
                    }
                } else {
                    // Localhost format
                    const parts = path.slice(1); // Remove leading /
                    if (parts.length === 4) {
                        roomCode = parts;
                    }
                }
                
                if (roomCode && roomCode.length === 4) {
                    console.log('üîó Found room code in URL:', roomCode);
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                // Welcome screen
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                
                document.getElementById('join-code').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                
                // Lobby screen
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                // Name input - only update locally while typing
                document.getElementById('player-name').addEventListener('input', (e) => {
                    this.playerName = e.target.value.trim();
                    this.updateStartButton(); // Update button state locally
                });
                
                // Submit name button and Enter key - send to other players
                const submitName = () => {
                    const nameInput = document.getElementById('player-name');
                    this.playerName = nameInput.value.trim();
                    
                    if (!this.playerName) {
                        alert('Please enter your name first!');
                        nameInput.focus();
                        return;
                    }
                    
                    console.log('üìù Submitting name:', this.playerName);
                    
                    // Update local game state
                    if (this.gameState.players.has(this.playerId)) {
                        const player = this.gameState.players.get(this.playerId);
                        player.name = this.playerName;
                        this.gameState.players.set(this.playerId, player);
                    } else {
                        this.gameState.players.set(this.playerId, {
                            id: this.playerId,
                            name: this.playerName,
                            score: 0,
                            connected: true,
                            likes: 0
                        });
                    }
                    
                    // Broadcast name to other players
                    const updateMessage = {
                        type: 'PLAYER_UPDATE',
                        playerId: this.playerId,
                        playerName: this.playerName
                    };
                    
                    console.log('üì§ Broadcasting name update:', updateMessage);
                    
                    if (this.broadcastLocal) {
                        this.broadcastLocal(updateMessage);
                    } else {
                        this.broadcastMessage(updateMessage);
                    }
                    
                    this.updateStartButton();
                    this.updatePlayersDisplay();
                    
                    // Show confirmation
                    this.showToast(`Name set to: ${this.playerName}`, 'success');
                };
                
                document.getElementById('submit-name').addEventListener('click', submitName);
                
                // Drawing tools
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectColor(e.target.dataset.color));
                });
                
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(1));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(3));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(6));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                // Game actions
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                
                // Enter key handlers
                document.getElementById('join-code').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('join-room').click();
                });
                document.getElementById('player-name').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') submitName();
                });
                document.getElementById('guess-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('submit-guess').click();
                });
                
                // Debug Panel Toggle
                // Debug panel toggle handlers
                document.getElementById('show-debug').addEventListener('click', () => {
                    document.getElementById('debug-panel').classList.remove('hidden');
                    document.getElementById('show-debug').classList.add('hidden');
                    this.updateDebugPanel();
                });
                
                document.getElementById('toggle-debug').addEventListener('click', () => {
                    document.getElementById('debug-panel').classList.add('hidden');
                    document.getElementById('show-debug').classList.remove('hidden');
                });
            }
            
            setupCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                
                // Mobile-optimized touch events with improved sensitivity
                canvas.addEventListener('touchstart', (e) => this.startDrawing(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.draw(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.stopDrawing(e), { passive: false });
                canvas.addEventListener('touchcancel', () => this.stopDrawing());
                
                // Mouse events for desktop
                canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                canvas.addEventListener('mousemove', (e) => this.draw(e));
                canvas.addEventListener('mouseup', () => this.stopDrawing());
                canvas.addEventListener('mouseout', () => this.stopDrawing());
                
                // Enhanced mobile drawing prevention of unwanted interactions
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                
                // Prevent context menu on long press
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Prevent text selection while drawing
                canvas.addEventListener('selectstart', (e) => e.preventDefault());
                
                // Initialize mobile drawing settings
                this.initializeMobileDrawingSettings();
            }
            
            initializeMobileDrawingSettings() {
                // Detect if user is on mobile device
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.isTouch = 'ontouchstart' in window;
                
                // Mobile-specific drawing optimizations
                if (this.isMobile || this.isTouch) {
                    // Optimize brush sizes for touch
                    this.touchBrushSizes = {
                        small: 2,    // Slightly larger than desktop
                        medium: 5,   // Better for finger drawing
                        large: 8     // Good for broader strokes
                    };
                    
                    // Touch pressure simulation for more natural drawing
                    this.touchPressureEnabled = true;
                    this.lastTouchTime = 0;
                    this.touchVelocity = 0;
                    
                    // Anti-aliasing for smoother lines on mobile
                    this.enableAntiAliasing = true;
                    
                    // Performance throttling for mobile
                    this.lastDrawTime = 0;
                    this.drawThrottleMs = this.gameConfig.mobile.drawingThrottleMs;
                } else {
                    // Desktop optimized sizes
                    this.touchBrushSizes = {
                        small: 1,
                        medium: 3,
                        large: 6
                    };
                    this.touchPressureEnabled = false;
                    this.enableAntiAliasing = false;
                }
                
                console.log(`üé® Mobile drawing initialized - isMobile: ${this.isMobile}, isTouch: ${this.isTouch}`);
            }
            
            initializeMobileTouchIndicator() {
                // Create touch indicator for mobile devices
                if (this.isMobile || this.isTouch) {
                    this.touchIndicator = document.createElement('div');
                    this.touchIndicator.id = 'touch-indicator';
                    this.touchIndicator.style.cssText = `
                        position: absolute;
                        width: 20px;
                        height: 20px;
                        border: 2px solid rgba(255, 255, 255, 0.8);
                        border-radius: 50%;
                        pointer-events: none;
                        z-index: 1000;
                        display: none;
                        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                        transition: transform 0.1s ease;
                    `;
                    document.body.appendChild(this.touchIndicator);
                }
            }
            
            showTouchIndicator(x, y) {
                if (this.touchIndicator && (this.isMobile || this.isTouch)) {
                    this.touchIndicator.style.display = 'block';
                    this.touchIndicator.style.left = (x - 10) + 'px';
                    this.touchIndicator.style.top = (y - 10) + 'px';
                    this.touchIndicator.style.borderColor = this.currentColor;
                }
            }
            
            hideTouchIndicator() {
                if (this.touchIndicator) {
                    this.touchIndicator.style.display = 'none';
                }
            }
            
            getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                
                // Enhanced touch coordinate handling for mobile
                if (e.touches && e.touches[0]) {
                    // Use the first touch point
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                    
                    // Show touch indicator for mobile
                    this.showTouchIndicator(clientX, clientY);
                    
                    // Calculate touch velocity for pressure simulation
                    if (this.touchPressureEnabled) {
                        const now = Date.now();
                        const timeDelta = now - (this.lastTouchTime || now);
                        const distance = this.lastPos ? 
                            Math.sqrt(Math.pow(clientX - this.lastTouchX || 0, 2) + Math.pow(clientY - this.lastTouchY || 0, 2)) : 0;
                        
                        this.touchVelocity = timeDelta > 0 ? distance / timeDelta : 0;
                        this.lastTouchTime = now;
                        this.lastTouchX = clientX;
                        this.lastTouchY = clientY;
                    }
                } else {
                    // Mouse events
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Account for device pixel ratio in coordinate scaling
                const dpr = window.devicePixelRatio || 1;
                
                return {
                    x: (clientX - rect.left) * (scaleX / dpr),
                    y: (clientY - rect.top) * (scaleY / dpr)
                };
            }
            
            startDrawing(e) {
                if (this.gameState.phase !== 'DRAWING') return;
                
                this.isDrawing = true;
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                // Mobile-optimized drawing settings
                if (this.isMobile || this.isTouch) {
                    // Enable anti-aliasing for smoother lines
                    ctx.imageSmoothingEnabled = this.enableAntiAliasing;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Reset touch tracking
                    this.touchVelocity = 0;
                    this.lastTouchTime = Date.now();
                }
                
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                
                this.lastPos = pos;
                
                // Add a small dot for touch start to ensure visibility
                if (this.isMobile || this.isTouch) {
                    ctx.fillStyle = this.currentTool === 'eraser' ? '#FFFFFF' : this.currentColor;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, Math.max(1, this.currentSize / 2), 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            draw(e) {
                if (!this.isDrawing || this.gameState.phase !== 'DRAWING') return;
                
                // Mobile performance throttling
                if (this.isMobile || this.isTouch) {
                    const now = Date.now();
                    if (now - this.lastDrawTime < this.drawThrottleMs) {
                        return; // Skip this draw call for performance
                    }
                    this.lastDrawTime = now;
                }
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                // Calculate dynamic brush size based on velocity (mobile only)
                let dynamicSize = this.currentSize;
                if (this.touchPressureEnabled && this.touchVelocity !== undefined) {
                    // Slower movements = thicker lines (more pressure)
                    // Faster movements = thinner lines (less pressure)
                    const velocityFactor = Math.max(0.3, Math.min(1.5, 1 - (this.touchVelocity * 0.01)));
                    dynamicSize = this.currentSize * velocityFactor;
                }
                
                ctx.lineWidth = dynamicSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = this.currentTool === 'eraser' ? '#FFFFFF' : this.currentColor;
                ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                
                // Enhanced line smoothing for mobile
                if (this.isMobile || this.isTouch) {
                    // Use quadratic curves for smoother lines on touch devices
                    const midPointX = (this.lastPos.x + pos.x) / 2;
                    const midPointY = (this.lastPos.y + pos.y) / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.lastPos.x, this.lastPos.y);
                    ctx.quadraticCurveTo(this.lastPos.x, this.lastPos.y, midPointX, midPointY);
                    ctx.stroke();
                } else {
                    // Standard line drawing for desktop
                    ctx.beginPath();
                    ctx.moveTo(this.lastPos.x, this.lastPos.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
                
                this.lastPos = pos;
                
                // Note: During DRAWING phase, each player draws independently
                // Broadcasting is handled separately during GUESSING/VOTING phases
            }
            
            stopDrawing(e) {
                this.isDrawing = false;
                
                // Hide touch indicator
                this.hideTouchIndicator();
                
                // Reset mobile touch tracking
                if (this.isMobile || this.isTouch) {
                    this.touchVelocity = 0;
                    this.lastTouchTime = 0;
                    this.lastTouchX = undefined;
                    this.lastTouchY = undefined;
                }
            }
            
            selectColor(color) {
                this.currentColor = color;
                this.currentTool = 'brush';
                this.updateToolButtons();
                
                // Mobile haptic feedback
                this.provideMobileHapticFeedback();
                
                console.log(`üé® Color selected: ${color}`);
            }
            
            selectBrush(size) {
                // Use mobile-optimized brush sizes if on touch device
                if (this.isMobile || this.isTouch) {
                    const sizeMap = {
                        1: this.touchBrushSizes.small,
                        3: this.touchBrushSizes.medium,
                        6: this.touchBrushSizes.large
                    };
                    this.currentSize = sizeMap[size] || size;
                } else {
                    this.currentSize = size;
                }
                
                this.currentTool = 'brush';
                this.updateToolButtons();
                
                // Mobile haptic feedback
                this.provideMobileHapticFeedback();
                
                console.log(`üñåÔ∏è Brush selected: ${this.currentSize}px (mobile optimized: ${this.isMobile || this.isTouch})`);
            }
            
            selectEraser() {
                this.currentTool = 'eraser';
                
                // Mobile-optimized eraser size
                if (this.isMobile || this.isTouch) {
                    this.currentSize = 15; // Larger eraser for touch devices
                } else {
                    this.currentSize = 10; // Standard eraser size for desktop
                }
                
                this.updateToolButtons();
                
                // Mobile haptic feedback
                this.provideMobileHapticFeedback();
                
                console.log(`üóëÔ∏è Eraser selected: ${this.currentSize}px (mobile optimized: ${this.isMobile || this.isTouch})`);
            }
            
            provideMobileHapticFeedback() {
                // Provide haptic feedback on mobile devices
                if (this.isMobile && 'vibrate' in navigator && this.gameConfig.mobile.hapticEnabled) {
                    navigator.vibrate(50); // Light haptic feedback
                }
            }
            
            clearCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const container = document.getElementById('canvas-container');
                const ctx = canvas.getContext('2d');
                
                // Get logical dimensions (not scaled by device pixel ratio)
                const containerRect = container.getBoundingClientRect();
                const width = containerRect.width;
                const height = containerRect.height;
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, width, height);
                
                // Mobile haptic feedback for clear action
                if (this.isMobile && 'vibrate' in navigator && this.gameConfig.mobile.hapticEnabled) {
                    navigator.vibrate([100, 50, 100]); // Double buzz for clear action
                }
                
                console.log('üóëÔ∏è Canvas cleared');
                
                // Note: Canvas clearing is local to each player during DRAWING phase
                // No broadcasting needed as each player manages their own canvas
            }
            
            updateToolButtons() {
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('bg-blue-600'));
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('border-white'));
                
                if (this.currentTool === 'brush') {
                    const sizeMap = { 1: 'brush-small', 3: 'brush-medium', 6: 'brush-large' };
                    document.getElementById(sizeMap[this.currentSize])?.classList.add('bg-blue-600');
                    document.querySelector(`[data-color="${this.currentColor}"]`)?.classList.add('border-white');
                } else if (this.currentTool === 'eraser') {
                    document.getElementById('eraser').classList.add('bg-blue-600');
                }
            }
            
            
            createRoom() {
                this.logDebugMessage('CREATE_ROOM', 'Starting room creation', 'out');
                
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                this.logDebugMessage('ROOM_CODE', `Generated: ${this.roomCode}`, 'out');
                
                // Update URL for sharing
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                this.logDebugMessage('HOST_SETUP', 'Becoming host, creating peer', 'out');
                
                // Create peer with host ID so others can find us
                this.createHostPeer();
                this.showLobby();
                
                this.logDebugMessage('ROOM_READY', 'Room created successfully', 'out');
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üëë Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Host peer opened with ID:', id);
                    console.log('üåê Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    // CRITICAL FIX: Host must add themselves to the players list
                    console.log('‚ûï Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                    
                    // Start connection monitoring if this is our first connection
                    if (this.connections.size === 0 && !this.heartbeatInterval) {
                        this.startConnectionMonitoring();
                    }
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Host peer error:', err);
                    console.log('üîÑ Attempting to recover host connection...');
                    this.updateConnectionStatus('Connection error - recovering...');
                    
                    // Try to reconnect after a short delay
                    setTimeout(() => {
                        if (this.peer && this.peer.destroyed) {
                            console.log('üîÑ Recreating host peer after error');
                            this.createHostPeer();
                        } else if (this.peer && this.peer.disconnected) {
                            console.log('üîÑ Reconnecting host peer');
                            this.peer.reconnect();
                        }
                    }, 2000);
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Host peer disconnected from server');
                    this.updateConnectionStatus('Disconnected - reconnecting...');
                    
                    // Attempt to reconnect
                    setTimeout(() => {
                        if (this.peer && !this.peer.destroyed) {
                            console.log('üîÑ Attempting to reconnect host peer');
                            this.peer.reconnect();
                        }
                    }, 1000);
                });
                
                this.peer.on('close', () => {
                    console.log('üîå Host peer connection closed');
                });
            }
            
            joinRoom(code) {
                this.logDebugMessage('JOIN_ROOM', `Attempting to join: ${code}`, 'out');
                
                this.roomCode = code;
                
                // For cross-device multiplayer, we always start as player and try to connect to host
                // Only become host if no host exists
                this.isHost = false;
                
                this.logDebugMessage('PLAYER_SETUP', 'Set as player, looking for host', 'out');
                
                // Update URL - handle GitHub Pages path
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                this.logDebugMessage('PEER_INIT', 'Initializing peer connection', 'out');
                this.initializePeer();
                this.showLobby();
                
                this.logDebugMessage('JOIN_COMPLETE', 'Join room setup complete', 'out');
            }
            
            initializePeer() {
                try {
                    // Local testing mode for same-device development
                    if (window.location.hostname === 'localhost' || 
                        window.location.hostname === '127.0.0.1' || 
                        window.location.protocol === 'file:') {
                        this.setupLocalTesting();
                        return;
                    }
                    
                    // For joinRoom, create player peer and try to connect to host
                    if (!this.isHost) {
                        this.createPlayerPeer();
                    }
                    // For createRoom, host peer is already created in createHostPeer()
                    
                } catch (error) {
                    // If PeerJS fails, fall back to local mode
                    this.updateConnectionStatus('Local mode fallback');
                    this.setupLocalTesting();
                }
            }
            
            createPlayerPeer() {
                console.log('üé≠ Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Player peer opened with ID:', id);
                    console.log('üåê Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    // Small delay to ensure peer is fully ready
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    this.setupLocalTesting();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Player peer disconnected');
                });
            }
            
            setupLocalTesting() {
                if (this.isLocalMode) return;
                
                this.isLocalMode = true;
                
                // Clean up any existing peer connection
                if (this.peer) {
                    try { this.peer.destroy(); } catch (e) {}
                    this.peer = null;
                }
                
                this.updateConnectionStatus('Local mode');
                this.localConnections = new Map();
                
                setTimeout(() => {
                    this.updateConnectionStatus('Connected (Local)');
                    if (!this.isHost) {
                        this.connectToLocalHost();
                    }
                }, 500);
                
                this.setupLocalStorageSync();
            }
            
            setupLocalStorageSync() {
                // Use localStorage to sync between browser tabs for local testing
                const storageKey = `drawparty_${this.roomCode}`;
                
                // Listen for storage changes (from other tabs)
                window.addEventListener('storage', (e) => {
                    if (e.key === storageKey && e.newValue) {
                        const data = JSON.parse(e.newValue);
                        this.handleLocalMessage(data);
                    }
                });
                
                // Broadcast to localStorage
                this.broadcastLocal = (message) => {
                    const data = {
                        timestamp: Date.now(),
                        fromPlayer: this.playerId,
                        isHost: this.isHost,
                        message: message
                    };
                    localStorage.setItem(storageKey, JSON.stringify(data));
                };
                
                // Announce presence after a short delay to ensure setup is complete
                setTimeout(() => {
                    this.broadcastLocal({
                        type: 'PLAYER_JOIN',
                        playerId: this.playerId,
                        playerName: this.playerName || 'Player'
                    });
                }, 100);
            }
            
            handleLocalMessage(data) {
                // Don't process our own messages
                if (data.fromPlayer === this.playerId) return;
                
                this.handleMessage(data.message, data.fromPlayer);
                
                // If this is a new player joining, send them our current state
                if (data.message.type === 'PLAYER_JOIN' && this.isHost) {
                    setTimeout(() => {
                        this.broadcastGameState();
                    }, 200);
                }
            }
            
            connectToLocalHost() {
                // Simulate connecting to host in local mode
                setTimeout(() => {
                    console.log('Connected to local host');
                    this.localConnections.set('host', true);
                }, 200);
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üîå Attempting to connect to host:', hostId);
                
                // Increase timeout to 8 seconds for better connection reliability
                const connectionTimeout = setTimeout(() => {
                    console.log('‚è∞ Connection timeout - no host found, becoming host');
                    this.becomeHost();
                }, 8000);
                
                try {
                    console.log('üìû Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        console.log('‚úÖ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.log('‚ùå Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.becomeHost();
                    });
                    
                    conn.on('close', () => {
                        console.log('üîå Connection to host closed');
                    });
                    
                    // Add debugging for connection metadata
                    conn.on('data', (data) => {
                        console.log('üì• Data from host:', data);
                    });
                    
                } catch (error) {
                    console.log('üí• Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.becomeHost();
                }
            }
            
            becomeHost() {
                if (this.isHost) return; // Already host
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                // Update our peer ID to be the host
                if (this.peer) {
                    this.peer.destroy();
                }
                
                // Recreate peer with host ID
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 0,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    console.log('üéØ becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    // CRITICAL FIX: Host must add themselves to the players list when they become host
                    console.log('‚ûï becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true,
                        likes: 0
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    console.log('üîó Connection established with:', conn.peer);
                    console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    // Initialize connection health tracking
                    this.connectionHealth.set(conn.peer, Date.now());
                    
                    // Start connection monitoring if not already started
                    if (!this.heartbeatInterval) {
                        this.startConnectionMonitoring();
                    }
                    
                    // CRITICAL FIX: Add delay to ensure connection is fully ready
                    setTimeout(() => {
                        console.log('üîÑ Connection ready delay completed, checking connection state...');
                        console.log('üîç Connection state:', conn.readyState, 'Open:', conn.open);
                        
                        if (this.isHost) {
                            console.log('üì° Host sending ROOM_JOINED to:', conn.peer);
                            
                            // Use enhanced sendToPlayer with connection readiness waiting
                            const sendResult = this.sendToPlayer(conn.peer, 
                                { type: 'ROOM_JOINED', roomCode: this.roomCode },
                                { waitForReady: true, retries: 3, retryDelay: 200 }
                            );
                            
                            // Handle both sync and async results
                            const handleResult = (result) => {
                                if (result.success) {
                                    console.log('‚úÖ ROOM_JOINED sent successfully:', result);
                                    // Only send game state if initial message succeeded
                                    setTimeout(() => {
                                        console.log('üì° Host also sending current game state to new player');
                                        this.broadcastGameState();
                                    }, 100);
                                } else {
                                    console.log('‚ùå ROOM_JOINED failed after retries:', result);
                                    // Fallback: try one more time without waiting
                                    setTimeout(() => {
                                        this.sendToPlayer(conn.peer, 
                                            { type: 'ROOM_JOINED', roomCode: this.roomCode },
                                            { waitForReady: false, retries: 0 }
                                        );
                                        this.broadcastGameState();
                                    }, 1000);
                                }
                            };
                            
                            // Handle Promise or immediate result
                            if (sendResult && typeof sendResult.then === 'function') {
                                sendResult.then(handleResult).catch(error => {
                                    console.error('‚ùå ROOM_JOINED promise error:', error);
                                    handleResult({ success: false, error: error.message });
                                });
                            } else {
                                handleResult(sendResult);
                            }
                        } else {
                            console.log('üì° Player sending PLAYER_JOIN to host:', conn.peer);
                            console.log('üè∑Ô∏è Player name at join time:', this.playerName, '(empty is normal)');
                            
                            // Add to debug panel
                            this.logDebugMessage('PLAYER_JOIN', `To host: ${conn.peer}`, 'out');
                            
                            // Use enhanced sendToPlayer with connection readiness waiting
                            const sendResult = this.sendToPlayer(conn.peer, 
                                { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName || 'Player' },
                                { waitForReady: true, retries: 3, retryDelay: 200 }
                            );
                            
                            // Handle both sync and async results
                            const handleResult = (result) => {
                                if (result.success) {
                                    console.log('‚úÖ PLAYER_JOIN sent successfully:', result);
                                } else {
                                    console.log('‚ùå PLAYER_JOIN failed after retries:', result);
                                    // Fallback: try one more time without waiting
                                    setTimeout(() => {
                                        this.sendToPlayer(conn.peer, 
                                            { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName },
                                            { waitForReady: false, retries: 0 }
                                        );
                                    }, 1000);
                                }
                            };
                            
                            // Handle Promise or immediate result
                            if (sendResult && typeof sendResult.then === 'function') {
                                sendResult.then(handleResult).catch(error => {
                                    console.error('‚ùå PLAYER_JOIN promise error:', error);
                                    handleResult({ success: false, error: error.message });
                                });
                            } else {
                                handleResult(sendResult);
                            }
                        }
                    }, 200); // 200ms delay to ensure connection is fully ready
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer, conn);
                });
                
                conn.on('close', () => {
                    console.log('üîå Connection closed with:', conn.peer);
                    this.connections.delete(conn.peer);
                    this.connectionHealth.delete(conn.peer);
                    
                    // Stop monitoring if no connections left
                    if (this.connections.size === 0) {
                        this.stopConnectionMonitoring();
                    }
                    
                    // Remove player from game state if they disconnect
                    if (this.isHost && this.gameState.players.has(conn.peer)) {
                        console.log('‚ûñ Removing disconnected player:', conn.peer);
                        this.gameState.players.delete(conn.peer);
                        this.broadcastGameState();
                    }
                    
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('‚ùå Connection error with', conn.peer, ':', err);
                    
                    // Clean up connection on error
                    this.connections.delete(conn.peer);
                    this.connectionHealth.delete(conn.peer);
                    
                    // Stop monitoring if no connections left
                    if (this.connections.size === 0) {
                        this.stopConnectionMonitoring();
                    }
                    
                    this.updatePlayersDisplay();
                });
            }
            
            handleMessage(message, fromPeer, connection = null) {
                console.log('üì® Received message:', message.type, 'from:', fromPeer);
                console.log('üì® Message details:', message);
                
                // Add to debug panel
                this.logDebugMessage(message.type, fromPeer, 'in');
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        console.log('üéØ Handling PLAYER_JOIN. I am host?', this.isHost);
                        console.log('üéØ Player joining:', message.playerId, 'Name:', message.playerName);
                        console.log('üéØ Current players before adding:', this.gameState.players.size);
                        if (this.isHost) {
                            console.log('‚ûï Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true,
                                likes: 0
                            });
                            console.log('‚úÖ Player added! New player count:', this.gameState.players.size);
                            console.log('üìã All players now:', Array.from(this.gameState.players.entries()));
                            console.log('üì° Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            console.log('üë§ Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                        }
                        this.updatePlayersDisplay();
                        if (this.isHost) {
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'HOST_PRESENCE':
                        // Host presence detected, no action needed
                        break;
                        
                    case 'ROOM_JOINED':
                        console.log('üéØ Received ROOM_JOINED from host - sending PLAYER_JOIN back');
                        // Player received confirmation from host, now send player info
                        if (!this.isHost) {
                            const playerJoinMessage = {
                                type: 'PLAYER_JOIN',
                                playerId: this.playerId,
                                playerName: this.playerName || 'Player'
                            };
                            
                            console.log('üì° Sending PLAYER_JOIN to host:', playerJoinMessage);
                            this.logDebugMessage('PLAYER_JOIN', 'To host', 'out');
                            
                            // Send back through the same connection that sent us ROOM_JOINED
                            if (connection && connection.open) {
                                try {
                                    connection.send(playerJoinMessage);
                                    console.log('‚úÖ PLAYER_JOIN sent successfully via direct connection');
                                } catch (error) {
                                    console.error('‚ùå Failed to send PLAYER_JOIN:', error);
                                    // Fallback to sendToPlayer
                                    this.sendToPlayer(fromPeer, playerJoinMessage);
                                }
                            } else {
                                console.log('üîÑ Using sendToPlayer fallback');
                                this.sendToPlayer(fromPeer, playerJoinMessage);
                            }
                        }
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        console.log('üì• Received GAME_STATE_UPDATE:', message.gameState);
                        console.log('üîç Before update - players.size:', this.gameState.players.size);
                        
                        // CRITICAL FIX: Rebuild ALL Maps from arrays
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            console.log('üîÑ Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                console.log('‚ûï Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            console.log('‚úÖ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        // Rebuild other Maps from arrays
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        // Update scalar properties only
                        const { players, guesses, votes, scores, playerPrompts, ...scalarState } = message.gameState;
                        Object.assign(this.gameState, scalarState);
                        
                        console.log('üìä Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        this.updateCanvas(message.canvasData);
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                        
                    case 'LIKE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.likes.set(message.playerId, {
                                targetPlayerId: message.targetPlayerId,
                                guessText: message.guessText
                            });
                            this.checkAllVotesSubmitted(); // Same check works since it counts all players - 1
                        }
                        break;
                        
                    case 'HEARTBEAT':
                        // Update connection health tracking
                        this.connectionHealth.set(fromPeer, message.timestamp || Date.now());
                        console.log(`üíì Heartbeat received from ${fromPeer}`);
                        
                        // Respond with heartbeat ack if we're the host
                        if (this.isHost) {
                            // Use lightweight options for heartbeat - no retries to avoid overhead
                            this.sendToPlayer(fromPeer, {
                                type: 'HEARTBEAT_ACK',
                                timestamp: Date.now()
                            }, { waitForReady: false, retries: 0 });
                        }
                        break;
                        
                    case 'HEARTBEAT_ACK':
                        // Update connection health tracking
                        this.connectionHealth.set(fromPeer, message.timestamp || Date.now());
                        console.log(`üíì Heartbeat ACK received from ${fromPeer}`);
                        break;
                }
            }
            
            sendToPlayer(playerId, message, options = {}) {
                const {
                    timeout = 5000,
                    retries = 2,
                    retryDelay = 1000,
                    waitForReady = true
                } = options;
                
                const startTime = Date.now();
                
                // Enhanced status object with detailed information
                const createStatus = (success, details = {}) => ({
                    success,
                    playerId,
                    messageType: message.type,
                    timestamp: Date.now(),
                    duration: Date.now() - startTime,
                    ...details
                });
                
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    try {
                        this.broadcastLocal(message);
                        return createStatus(true, { method: 'localStorage' });
                    } catch (error) {
                        return createStatus(false, { 
                            error: error.message, 
                            method: 'localStorage' 
                        });
                    }
                }
                
                const conn = this.connections.get(playerId);
                if (!conn) {
                    console.warn(`‚ö†Ô∏è No connection found for player: ${playerId}`);
                    return createStatus(false, { 
                        error: 'No connection found',
                        connectionExists: false
                    });
                }
                
                // Enhanced connection validation with timing consideration
                const validateConnection = () => {
                    if (!conn) return { valid: false, reason: 'Connection is null' };
                    if (conn.destroyed) return { valid: false, reason: 'Connection destroyed' };
                    if (!conn.open) return { valid: false, reason: 'Connection not open' };
                    // FIXED: Don't check readyState as PeerJS may not set it consistently
                    // The conn.open property is the reliable indicator
                    return { valid: true };
                };
                
                // Recursive function to attempt sending with retries
                const attemptSend = async (attempt = 0) => {
                    const validation = validateConnection();
                    
                    if (!validation.valid) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} invalid: ${validation.reason}`);
                        
                        // If we should wait for connection to be ready and we have retries left
                        if (waitForReady && attempt < retries && validation.reason.includes('state')) {
                            console.log(`üîÑ Waiting for connection to be ready (attempt ${attempt + 1}/${retries + 1})`);
                            
                            // Wait for connection to be ready or timeout
                            const readyPromise = new Promise((resolve) => {
                                const checkReady = () => {
                                    const newValidation = validateConnection();
                                    if (newValidation.valid) {
                                        resolve(true);
                                    } else if (Date.now() - startTime > timeout) {
                                        resolve(false);
                                    } else {
                                        setTimeout(checkReady, 100);
                                    }
                                };
                                setTimeout(checkReady, retryDelay);
                            });
                            
                            const isReady = await readyPromise;
                            if (isReady) {
                                return attemptSend(attempt + 1);
                            }
                        }
                        
                        // Clean up dead connection
                        this.connections.delete(playerId);
                        
                        // Attempt reconnection for critical messages
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                    
                    try {
                        // Send the message
                        conn.send(message);
                        console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        
                        // Update connection health
                        this.connectionHealth.set(playerId, Date.now());
                        
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            attemptsUsed: attempt + 1,
                            method: 'peerjs'
                        });
                        
                    } catch (error) {
                        console.error(`‚ùå Send attempt ${attempt + 1} failed to ${playerId}:`, error);
                        
                        // If we have retries left, try again
                        if (attempt < retries) {
                            console.log(`üîÑ Retrying send to ${playerId} in ${retryDelay}ms`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return attemptSend(attempt + 1);
                        }
                        
                        // Clean up failed connection
                        this.connections.delete(playerId);
                        
                        // Attempt reconnection on certain errors
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown',
                            attemptsUsed: attempt + 1,
                            cleanedUp: true
                        });
                    }
                };
                
                // For non-async context, we need to handle the Promise
                if (waitForReady || retries > 0) {
                    // Return a Promise for better async handling
                    return attemptSend();
                } else {
                    // Synchronous single attempt for backwards compatibility
                    const validation = validateConnection();
                    if (!validation.valid) {
                        this.connections.delete(playerId);
                        if (message.type === 'GAME_STATE_UPDATE' || message.type === 'START_GAME') {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: validation.reason,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                    
                    try {
                        conn.send(message);
                        console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        this.connectionHealth.set(playerId, Date.now());
                        return createStatus(true, {
                            connectionState: conn.readyState,
                            method: 'peerjs'
                        });
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        this.connections.delete(playerId);
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                        return createStatus(false, {
                            error: error.message,
                            errorType: error.name,
                            connectionState: conn?.readyState || 'unknown'
                        });
                    }
                }
            }
            
            // Helper method for reliable message sending with error handling
            async sendReliably(playerId, message, options = {}) {
                const defaultOptions = {
                    waitForReady: true,
                    retries: 2,
                    retryDelay: 500,
                    ...options
                };
                
                try {
                    const result = await this.sendToPlayer(playerId, message, defaultOptions);
                    
                    if (result.success) {
                        console.log(`‚úÖ Reliable send success to ${playerId}:`, result);
                        return result;
                    } else {
                        console.warn(`‚ö†Ô∏è Reliable send failed to ${playerId}:`, result);
                        // Show user feedback for critical failures
                        if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                            this.showToast(`Failed to send ${message.type.toLowerCase()} - connection issue`, 'warning');
                        }
                        return result;
                    }
                } catch (error) {
                    console.error(`‚ùå Reliable send error to ${playerId}:`, error);
                    const errorResult = {
                        success: false,
                        error: error.message,
                        playerId,
                        messageType: message.type,
                        timestamp: Date.now()
                    };
                    
                    // Show user feedback for critical failures
                    if (message.type === 'GUESS_SUBMITTED' || message.type === 'VOTE_SUBMITTED') {
                        this.showToast(`Network error sending ${message.type.toLowerCase()}`, 'error');
                    }
                    
                    return errorResult;
                }
            }
            
            broadcastMessage(message) {
                // Add to debug panel
                this.logDebugMessage(`BROADCAST_${message.type}`, `To ${this.connections.size} players`, 'out');
                
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    this.broadcastLocal(message);
                    return;
                }
                
                // Track failed connections for cleanup
                const failedConnections = [];
                let successfulSends = 0;
                
                this.connections.forEach((conn, playerId) => {
                    try {
                        // Check if connection is still valid (simplified check - only use conn.open)
                        if (conn && conn.open) {
                            conn.send(message);
                            successfulSends++;
                            console.log(`üì§ Message sent to ${playerId}:`, message.type);
                        } else {
                            console.warn(`‚ö†Ô∏è Connection to ${playerId} is not open:`, conn ? `destroyed=${conn.destroyed} open=${conn.open}` : 'null');
                            failedConnections.push(playerId);
                        }
                    } catch (error) {
                        console.error(`‚ùå Failed to send message to ${playerId}:`, error);
                        failedConnections.push(playerId);
                        
                        // Attempt to reconnect on certain errors
                        if (error.name === 'DataCloneError' || error.message.includes('connection')) {
                            this.attemptReconnection(playerId, conn);
                        }
                    }
                });
                
                // Give failed connections time to recover before cleanup
                if (failedConnections.length > 0) {
                    console.log(`‚è≥ ${failedConnections.length} connections temporarily failed - giving recovery time`);
                    
                    // Initialize connection failure tracking if not exists
                    if (!this.connectionFailures) this.connectionFailures = new Map();
                    
                    const connectionsToRemove = [];
                    
                    failedConnections.forEach(playerId => {
                        const now = Date.now();
                        const lastFailure = this.connectionFailures.get(playerId) || now;
                        
                        // If this is the first failure, just mark it
                        if (!this.connectionFailures.has(playerId)) {
                            console.log(`üîÑ First failure for ${playerId} - starting recovery timer`);
                            this.connectionFailures.set(playerId, now);
                        } 
                        // If connection has been failing for more than 60 seconds, remove it
                        else if (now - lastFailure > 60000) {
                            console.log(`üßπ Connection to ${playerId} failed for >60s - removing`);
                            connectionsToRemove.push(playerId);
                        } else {
                            console.log(`‚è±Ô∏è Connection to ${playerId} failing for ${Math.round((now - lastFailure)/1000)}s - waiting`);
                        }
                    });
                    
                    // Only remove connections that have been failing for a while
                    if (connectionsToRemove.length > 0) {
                        connectionsToRemove.forEach(playerId => {
                            this.connections.delete(playerId);
                            this.connectionFailures.delete(playerId);
                            
                            // Remove from game state if host
                            if (this.isHost && this.gameState.players.has(playerId)) {
                                console.log(`‚ûñ Removing permanently disconnected player: ${playerId}`);
                                this.gameState.players.delete(playerId);
                            }
                        });
                        
                        // Update UI after cleanup
                        this.updatePlayersDisplay();
                        
                        // Show notification if significant connection loss
                        if (connectionsToRemove.length > 1) {
                            this.showToast(`Lost connection to ${connectionsToRemove.length} player(s)`, 'warning');
                        }
                    }
                } else {
                    // Clear any failure tracking for successful connections
                    if (this.connectionFailures) {
                        this.connections.forEach((conn, playerId) => {
                            if (this.connectionFailures.has(playerId)) {
                                console.log(`‚úÖ Connection to ${playerId} recovered`);
                                this.connectionFailures.delete(playerId);
                            }
                        });
                    }
                }
                
                // Log broadcast summary
                console.log(`üìä Broadcast summary: ${successfulSends} successful, ${failedConnections.length} failed`);
                
                // Return success status for caller to handle
                return {
                    success: successfulSends > 0,
                    successfulSends,
                    failedConnections: failedConnections.length,
                    totalConnections: this.connections.size + failedConnections.length
                };
            }
            
            attemptReconnection(playerId, failedConn) {
                console.log(`üîÑ Attempting reconnection to ${playerId}`);
                
                // Don't attempt reconnection too frequently
                const reconnectKey = `reconnect_${playerId}`;
                const lastAttempt = this[reconnectKey] || 0;
                const now = Date.now();
                
                if (now - lastAttempt < 5000) { // Wait at least 5 seconds between attempts
                    console.log(`‚è≥ Skipping reconnection to ${playerId} - too soon since last attempt`);
                    return;
                }
                
                this[reconnectKey] = now;
                
                // Clean up old connection
                if (failedConn) {
                    try {
                        failedConn.close();
                    } catch (e) {
                        console.log('Connection already closed');
                    }
                }
                
                // For players trying to reconnect to host
                if (!this.isHost && playerId.includes('_HOST')) {
                    console.log('üîå Player attempting to reconnect to host');
                    setTimeout(() => {
                        try {
                            if (this.peer && !this.peer.destroyed) {
                                const conn = this.peer.connect(playerId);
                                this.handleConnection(conn);
                            }
                        } catch (error) {
                            console.error('‚ùå Reconnection attempt failed:', error);
                        }
                    }, 2000);
                }
                
                // For host trying to reconnect to players - players should reconnect to host instead
                else if (this.isHost) {
                    console.log('üè† Host waiting for player to reconnect');
                    // Don't actively try to reconnect as host - let players reconnect to us
                }
            }
            
            startConnectionMonitoring() {
                // Start heartbeat system for connection health monitoring
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                
                this.heartbeatInterval = setInterval(() => {
                    this.sendHeartbeat();
                    this.checkConnectionHealth();
                }, 30000); // Check every 30 seconds (less aggressive)
                
                console.log('üíì Connection monitoring started');
            }
            
            stopConnectionMonitoring() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                console.log('üíì Connection monitoring stopped');
            }
            
            sendHeartbeat() {
                const heartbeatMessage = {
                    type: 'HEARTBEAT',
                    timestamp: Date.now(),
                    playerId: this.playerId
                };
                
                // Only send heartbeat if we have active connections
                if (this.connections.size > 0) {
                    this.broadcastMessage(heartbeatMessage);
                }
                
                this.lastHeartbeat = Date.now();
            }
            
            checkConnectionHealth() {
                const now = Date.now();
                const staleConnections = [];
                
                this.connections.forEach((conn, playerId) => {
                    const lastSeen = this.connectionHealth.get(playerId) || now;
                    const timeSinceLastSeen = now - lastSeen;
                    
                    // If we haven't heard from a connection in 90 seconds, consider it stale
                    if (timeSinceLastSeen > 90000) {
                        console.warn(`‚ö†Ô∏è Connection to ${playerId} appears stale (${Math.round(timeSinceLastSeen/1000)}s)`);
                        staleConnections.push(playerId);
                    }
                    
                    // If connection is not open, mark for cleanup (only check conn.open, not readyState)
                    if (!conn.open) {
                        console.log(`üîå Connection to ${playerId} is closed - marking for cleanup`);
                        staleConnections.push(playerId);
                    }
                });
                
                // Clean up stale connections
                if (staleConnections.length > 0) {
                    console.log(`üßπ Cleaning up ${staleConnections.length} stale connections`);
                    staleConnections.forEach(playerId => {
                        this.connections.delete(playerId);
                        this.connectionHealth.delete(playerId);
                        
                        if (this.isHost && this.gameState.players.has(playerId)) {
                            this.gameState.players.delete(playerId);
                        }
                    });
                    
                    this.updatePlayersDisplay();
                    
                    if (staleConnections.length > 0) {
                        this.showToast(`Cleaned up ${staleConnections.length} inactive connection(s)`, 'info');
                    }
                }
            }
            
            broadcastGameState() {
                console.log('üì° Broadcasting game state');
                console.log('üìä Current players before broadcast:', this.gameState.players.size);
                console.log('üìã Players being broadcast:', Array.from(this.gameState.players.entries()));
                
                // CRITICAL FIX: Convert ALL Maps to Arrays for serialization
                // SECURITY FIX: Filter sensitive information during active gameplay
                const gameStateForBroadcast = {
                    currentRound: this.gameState.currentRound || 0,
                    totalRounds: this.gameState.totalRounds || 5,
                    phase: this.gameState.phase || 'lobby',
                    currentDrawer: this.gameState.currentDrawer || null,
                    // Only share currentPrompt during VOTING and RESULTS phases
                    currentPrompt: (this.gameState.phase === 'VOTING' || this.gameState.phase === 'RESULTS') ? 
                        (this.gameState.currentPrompt || null) : null,
                    timeLeft: this.gameState.timeLeft || 0,
                    players: Array.from(this.gameState.players.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                    // NEVER share all playerPrompts - this would reveal all answers
                    // Only individual players should know their own prompts
                    playerPrompts: []
                };
                
                console.log('üì§ Sending GAME_STATE_UPDATE with safe data to', this.connections.size, 'connections');
                console.log('üîç Safe gameState:', gameStateForBroadcast);
                
                const broadcastResult = this.broadcastMessage({
                    type: 'GAME_STATE_UPDATE',
                    gameState: gameStateForBroadcast
                });
                
                // Handle broadcast result for better reliability
                if (broadcastResult && !broadcastResult.success) {
                    console.warn('‚ö†Ô∏è Game state broadcast failed - no active connections');
                    this.showToast('Connection issues detected', 'warning');
                } else if (broadcastResult && broadcastResult.failedConnections > 0) {
                    console.warn(`‚ö†Ô∏è Game state broadcast partial failure: ${broadcastResult.failedConnections} failed connections`);
                    
                    // If we lost more than half the connections, show a warning
                    if (broadcastResult.failedConnections > broadcastResult.successfulSends) {
                        this.showToast('Multiple players disconnected', 'warning');
                    }
                }
            }
            
            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                document.getElementById('room-code').textContent = `Room: ${this.roomCode}`;
                
                // Add current player to game state (don't assume name yet)
                this.gameState.players.set(this.playerId, {
                    id: this.playerId,
                    name: this.playerName || (this.isHost ? 'Host' : 'Player'),
                    score: 0,
                    connected: true,
                    likes: 0
                });
                
                // Focus the name input for easy editing
                setTimeout(() => {
                    const nameInput = document.getElementById('player-name');
                    if (nameInput) {
                        nameInput.focus();
                        nameInput.placeholder = `Enter your name...`;
                    }
                }, 100);
                
                this.updatePlayersDisplay();
                
                // Host presence is now saved immediately in createRoom(), no need to duplicate here
            }
            
            updatePlayersDisplay() {
                console.log('üîÑ updatePlayersDisplay called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                    this.logDebugMessage('MAP_ERROR', 'Players Map corrupted, fixed', 'out');
                    return;
                }
                
                // Update debug panel with current state
                this.updateDebugPanel();
                
                console.log('üìä Current players in gameState:', this.gameState.players.size);
                const playersArray = Array.from(this.gameState.players.entries());
                console.log('üìã Players list:', playersArray);
                playersArray.forEach(([id, player], index) => {
                    console.log(`üë§ Player ${index + 1}: ID=${id}, Name=${player.name}, Connected=${player.connected}`);
                });
                console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                
                this.gameState.players.forEach((player, id) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'bg-gray-800 rounded-lg p-3 flex items-center justify-between';
                    playerDiv.innerHTML = `
                        <div class="flex items-center gap-3">
                            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                                ${player.name.charAt(0).toUpperCase()}
                            </div>
                            <span>${player.name}</span>
                            ${id === this.playerId ? '<span class="text-blue-400">(You)</span>' : ''}
                            ${this.isHost && id === this.playerId ? '<span class="text-yellow-400">(Host)</span>' : ''}
                        </div>
                        <div class="text-sm text-gray-400">
                            Score: ${player.score}
                        </div>
                    `;
                    playersList.appendChild(playerDiv);
                });
                
                this.updateStartButton();
            }
            
            updateStartButton() {
                console.log('üöÄ updateStartButton called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map in updateStartButton!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                }
                
                console.log('üìè gameState.players.size:', this.gameState.players.size);
                console.log('üó∫Ô∏è gameState.players Map:', this.gameState.players);
                console.log('üìù playerName:', this.playerName);
                console.log('üëë isHost:', this.isHost);
                
                const startButton = document.getElementById('start-game');
                const hasName = this.playerName && this.playerName.length > 0;
                const canStart = this.isHost && this.gameState.players.size >= 2 && hasName;
                
                startButton.disabled = !canStart;
                
                const waitingMessage = document.getElementById('waiting-message');
                if (this.gameState.players.size < 2) {
                    waitingMessage.textContent = `Waiting for more players... (need at least 2, have ${this.gameState.players.size})`;
                    console.log('üî¥ Not enough players:', this.gameState.players.size);
                } else if (!hasName) {
                    waitingMessage.textContent = 'Enter your name to continue';
                    console.log('üî¥ No player name');
                } else if (this.isHost) {
                    waitingMessage.textContent = 'Ready to start!';
                    console.log('üü¢ Ready to start!');
                } else {
                    waitingMessage.textContent = 'Waiting for host to start the game...';
                    console.log('üü° Waiting for host');
                }
            }
            
            shareGame() {
                // Generate correct share URL for GitHub Pages
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                const shareUrl = `${window.location.origin}${basePath}/${this.roomCode}`;
                const shareData = {
                    title: 'üé® Join our drawing game!',
                    text: `Game time! Tap to join ‚Üí`,
                    url: shareUrl
                };
                
                if (navigator.share) {
                    navigator.share(shareData).catch(console.error);
                } else {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        this.showToast('Link copied! Send to friends üì±', 'success');
                    }).catch(() => {
                        this.showToast('Share URL: ' + shareUrl, 'info');
                    });
                }
            }
            
            startGame() {
                if (!this.isHost || this.gameState.players.size < 2) return;
                
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.assignPrompts();
                this.broadcastGameState();
                this.broadcastMessage({ type: 'START_GAME' });
                this.handleStartGame();
            }
            
            handleStartGame() {
                this.showDrawingScreen();
                this.startDrawingTimer();
            }
            
            assignPrompts() {
                // Assign unique prompts to each player
                const prompts = this.getRandomPrompts(this.gameState.players.size);
                const playerIds = Array.from(this.gameState.players.keys());
                
                this.gameState.playerPrompts = new Map();
                playerIds.forEach((playerId, index) => {
                    this.gameState.playerPrompts.set(playerId, prompts[index]);
                });
            }
            
            getRandomPrompts(count) {
                const allPrompts = [
                    "Robot eating pizza", "Cat playing guitar", "Dinosaur on skateboard",
                    "Wizard making coffee", "Shark wearing hat", "Invisible man in mirror",
                    "Spaghetti tornado", "Crying birthday cake", "Dancing refrigerator", 
                    "Sneezing volcano", "Time-traveling sandwich", "Vampire dentist appointment",
                    "Yoga class for furniture", "Cow abducting aliens", "Angry broccoli army",
                    "Romantic dinner between phones", "Hamster business meeting", "Cactus beauty pageant",
                    "Penguin fire department", "Banana phone tech support", "Pirate scared of water",
                    "Grandma vs. ninja squirrels", "Battle of the condiments", "Escape from vegetable prison",
                    "Racing shopping carts downhill", "Dodgeball with planets", "Santa's summer vacation",
                    "Halloween costume for house", "Turkey plotting revenge", "New Year's Eve for clocks",
                    "Valentine's Day for robots", "Ninja fighting a pi√±ata", "Octopus bartender",
                    "Vampire accountant", "Cowboy surfing in space", "Grandma skateboarding in a volcano",
                    "The feeling of Monday", "WiFi signal as a person", "Procrastination monster",
                    "Sound of silence", "Upside-down gravity", "Sleepy ninja eating spaghetti",
                    "Angry dentist fighting a balloon", "Banana driving a car", "Pizza doing yoga",
                    "Dinosaur mixed with disco ball", "Submarine mixed with birthday cake"
                ];
                
                const shuffled = allPrompts.sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            showDrawingScreen() {
                this.showScreen('drawing-screen');
                const myPrompt = this.gameState.playerPrompts?.get(this.playerId) || 'Draw something fun!';
                document.getElementById('drawing-prompt').textContent = `Draw this: ${myPrompt}`;
                
                // Ensure canvas is properly sized for mobile
                setTimeout(() => {
                    this.resizeCanvas();
                    this.updateToolButtons();
                }, 100);
            }
            
            startDrawingTimer() {
                let timeLeft = this.gameConfig.timers.drawing;
                const timerElement = document.getElementById('drawing-timer');
                
                const timer = setInterval(() => {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (timeLeft <= 10) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.endDrawingPhase();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            endDrawingPhase() {
                if (this.isHost) {
                    this.gameState.phase = 'GUESSING';
                    this.selectRandomDrawing();
                    this.broadcastGameState();
                }
                this.showGuessingScreen();
            }
            
            selectRandomDrawing() {
                const playerIds = Array.from(this.gameState.players.keys());
                const randomIndex = Math.floor(Math.random() * playerIds.length);
                this.gameState.currentArtist = playerIds[randomIndex];
                this.gameState.currentPrompt = this.gameState.playerPrompts.get(this.gameState.currentArtist);
                
                // Capture canvas data (in real implementation, this would be sent from the artist)
                const canvas = document.getElementById('drawing-canvas');
                this.gameState.currentDrawing = canvas.toDataURL();
            }
            
            showGuessingScreen() {
                this.showScreen('guessing-screen');
                
                // Setup responsive guess canvas
                setTimeout(() => {
                    const guessCanvas = document.getElementById('guess-canvas');
                    this.setupCanvasSize(guessCanvas);
                    
                    const ctx = guessCanvas.getContext('2d');
                    const container = guessCanvas.parentElement;
                    const containerRect = container.getBoundingClientRect();
                    
                    if (this.gameState.currentDrawing) {
                        const img = new Image();
                        img.onload = () => {
                            ctx.clearRect(0, 0, containerRect.width, containerRect.height);
                            ctx.drawImage(img, 0, 0, containerRect.width, containerRect.height);
                        };
                        img.src = this.gameState.currentDrawing;
                    } else {
                        // Fallback - copy from source canvas if available
                        const sourceCanvas = document.getElementById('drawing-canvas');
                        if (sourceCanvas) {
                            ctx.clearRect(0, 0, containerRect.width, containerRect.height);
                            ctx.drawImage(sourceCanvas, 0, 0, containerRect.width, containerRect.height);
                        }
                    }
                    
                    const artistName = this.gameState.players.get(this.gameState.currentArtist)?.name || 'Someone';
                    document.getElementById('artist-name').textContent = `Drawn by ${artistName}`;
                    
                    this.startGuessingTimer();
                }, 100);
            }
            
            startGuessingTimer() {
                let timeLeft = this.gameConfig.timers.guessing;
                const timerElement = document.getElementById('guessing-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.submitGuess();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitGuess() {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();
                
                if (!guess) {
                    this.showToast('Please enter a guess!', 'warning');
                    return;
                }
                
                if (this.isHost) {
                    this.gameState.guesses.set(this.playerId, guess);
                    this.checkAllGuessesSubmitted();
                } else {
                    // Use enhanced sendToPlayer for better reliability
                    const sendResult = this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'GUESS_SUBMITTED',
                        playerId: this.playerId,
                        guess: guess
                    }, { waitForReady: true, retries: 2 });
                    
                    // Handle async result if needed
                    if (sendResult && typeof sendResult.then === 'function') {
                        sendResult.then(result => {
                            if (!result.success) {
                                console.warn('Failed to submit guess:', result);
                                this.showToast('Failed to submit guess - please try again', 'error');
                            }
                        });
                    }
                }
                
                guessInput.disabled = true;
                document.getElementById('submit-guess').disabled = true;
                this.showToast('Guess submitted!', 'success');
            }
            
            checkAllGuessesSubmitted() {
                if (this.gameState.guesses.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.startVotingPhase();
                }
            }
            
            startVotingPhase() {
                this.gameState.phase = 'VOTING';
                this.broadcastGameState();
                this.showVotingScreen();
            }
            
            showVotingScreen() {
                this.showScreen('voting-screen');
                
                // Setup responsive vote canvas
                setTimeout(() => {
                    const voteCanvas = document.getElementById('vote-canvas');
                    this.setupCanvasSize(voteCanvas);
                    
                    const ctx = voteCanvas.getContext('2d');
                    const container = voteCanvas.parentElement;
                    const containerRect = container.getBoundingClientRect();
                    
                    if (this.gameState.currentDrawing) {
                        const img = new Image();
                        img.onload = () => {
                            ctx.clearRect(0, 0, containerRect.width, containerRect.height);
                            ctx.drawImage(img, 0, 0, containerRect.width, containerRect.height);
                        };
                        img.src = this.gameState.currentDrawing;
                    }
                    
                    // Check if current player is the artist
                    if (this.playerId === this.gameState.currentArtist) {
                        this.displayLikingOptions();
                    } else {
                        this.displayVotingOptions();
                    }
                    
                    this.startVotingTimer();
                }, 100);
            }
            
            displayVotingOptions() {
                const votingOptions = document.getElementById('voting-options');
                votingOptions.innerHTML = '';
                
                // Collect all answers plus the real one
                const allOptions = Array.from(this.gameState.guesses.values());
                allOptions.push(this.gameState.currentPrompt);
                
                // Shuffle options
                const shuffledOptions = allOptions.sort(() => 0.5 - Math.random());
                
                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded-lg p-4 text-left transition-colors';
                    button.textContent = option;
                    button.addEventListener('click', () => this.submitVote(option));
                    votingOptions.appendChild(button);
                });
            }
            
            displayLikingOptions() {
                const votingOptions = document.getElementById('voting-options');
                votingOptions.innerHTML = '';
                
                // Show artist-specific message
                const artistMessage = document.createElement('div');
                artistMessage.className = 'text-center mb-4 p-4 bg-blue-600 rounded-lg';
                artistMessage.innerHTML = `
                    <h3 class="text-lg font-bold mb-2">üé® You're the Artist!</h3>
                    <p class="text-sm">You can't vote on your own drawing, but you can give "likes" to answers you find funny or creative!</p>
                `;
                votingOptions.appendChild(artistMessage);
                
                // Show only the guessed answers (not the real answer)
                const guessedAnswers = Array.from(this.gameState.guesses.entries());
                
                if (guessedAnswers.length === 0) {
                    const noAnswersMessage = document.createElement('div');
                    noAnswersMessage.className = 'text-center text-gray-400 p-4';
                    noAnswersMessage.textContent = 'No guesses submitted yet...';
                    votingOptions.appendChild(noAnswersMessage);
                    return;
                }
                
                guessedAnswers.forEach(([playerId, guess]) => {
                    const playerName = this.gameState.players.get(playerId)?.name || 'Unknown';
                    const likeButton = document.createElement('button');
                    likeButton.className = 'w-full bg-gray-800 hover:bg-purple-600 border border-gray-600 rounded-lg p-4 text-left transition-colors mb-2';
                    likeButton.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-semibold">"${guess}"</div>
                                <div class="text-sm text-gray-400">by ${playerName}</div>
                            </div>
                            <div class="text-2xl">üëç</div>
                        </div>
                    `;
                    likeButton.addEventListener('click', () => this.submitLike(playerId, guess));
                    votingOptions.appendChild(likeButton);
                });
            }
            
            startVotingTimer() {
                let timeLeft = this.gameConfig.timers.voting;
                const timerElement = document.getElementById('voting-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        // Auto-submit random vote if no vote made
                        if (!this.gameState.votes.has(this.playerId)) {
                            const options = Array.from(document.getElementById('voting-options').children);
                            const randomOption = options[Math.floor(Math.random() * options.length)];
                            this.submitVote(randomOption.textContent);
                        }
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitVote(vote) {
                if (this.isHost) {
                    this.gameState.votes.set(this.playerId, vote);
                    this.checkAllVotesSubmitted();
                } else {
                    // Use enhanced sendToPlayer for better reliability
                    const sendResult = this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'VOTE_SUBMITTED',
                        playerId: this.playerId,
                        vote: vote
                    }, { waitForReady: true, retries: 2 });
                    
                    // Handle async result if needed
                    if (sendResult && typeof sendResult.then === 'function') {
                        sendResult.then(result => {
                            if (!result.success) {
                                console.warn('Failed to submit vote:', result);
                                this.showToast('Failed to submit vote - please try again', 'error');
                            }
                        });
                    }
                }
                
                // Disable all voting buttons
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.textContent === vote) {
                        btn.classList.add('bg-blue-600');
                    }
                });
                
                this.showToast('Vote submitted!', 'success');
            }
            
            submitLike(targetPlayerId, guessText) {
                if (this.isHost) {
                    this.gameState.likes.set(this.playerId, { targetPlayerId, guessText });
                    this.checkAllVotesSubmitted(); // This function will be renamed to checkAllInteractionsSubmitted
                } else {
                    // Use enhanced sendToPlayer for better reliability
                    const sendResult = this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'LIKE_SUBMITTED',
                        playerId: this.playerId,
                        targetPlayerId: targetPlayerId,
                        guessText: guessText
                    }, { waitForReady: true, retries: 2 });
                    
                    // Handle async result if needed
                    if (sendResult && typeof sendResult.then === 'function') {
                        sendResult.then(result => {
                            if (!result.success) {
                                console.warn('Failed to submit like:', result);
                                this.showToast('Failed to submit like - please try again', 'error');
                            }
                        });
                    }
                }
                
                // Disable all like buttons and highlight the selected one
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.innerHTML.includes(guessText)) {
                        btn.classList.remove('hover:bg-purple-600');
                        btn.classList.add('bg-purple-600');
                    }
                });
                
                this.showToast('Like submitted!', 'success');
            }
            
            checkAllVotesSubmitted() {
                if (this.gameState.votes.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.calculateScores();
                    this.showResults();
                }
            }
            
            calculateScores() {
                // Award points based on voting results
                this.gameState.votes.forEach((vote, voterId) => {
                    // Points for correct guesses
                    if (vote === this.gameState.currentPrompt) {
                        const player = this.gameState.players.get(voterId);
                        if (player) {
                            player.score += 200;
                        }
                    }
                    
                    // Points for tricking others with fake answers
                    this.gameState.guesses.forEach((guess, guesserId) => {
                        if (vote === guess && voterId !== guesserId) {
                            const trickster = this.gameState.players.get(guesserId);
                            if (trickster) {
                                trickster.score += 50;
                            }
                        }
                    });
                });
                
                // Points for artist (per correct guess)
                let correctGuesses = 0;
                this.gameState.votes.forEach(vote => {
                    if (vote === this.gameState.currentPrompt) {
                        correctGuesses++;
                    }
                });
                
                const artist = this.gameState.players.get(this.gameState.currentArtist);
                if (artist) {
                    artist.score += correctGuesses * 100;
                }
                
                // Award likes to players who received them from the artist
                this.gameState.likes.forEach((likeData, artistId) => {
                    if (likeData && likeData.targetPlayerId) {
                        const likedPlayer = this.gameState.players.get(likeData.targetPlayerId);
                        if (likedPlayer) {
                            likedPlayer.likes += 1;
                            console.log(`üëç ${likedPlayer.name} received a like from the artist!`);
                        }
                    }
                });
            }
            
            showResults() {
                this.showScreen('results-screen');
                
                const resultsContent = document.getElementById('results-content');
                resultsContent.innerHTML = '';
                
                // Show the reveal
                const revealDiv = document.createElement('div');
                revealDiv.className = 'bg-gray-800 rounded-lg p-4 mb-4';
                revealDiv.innerHTML = `
                    <div class="text-center mb-4">
                        <div class="text-lg font-bold">The real answer was...</div>
                        <div class="text-2xl font-bold text-green-400 mt-2">"${this.gameState.currentPrompt}"</div>
                        <div class="text-sm text-gray-400 mt-1">Drawn by ${this.gameState.players.get(this.gameState.currentArtist)?.name}</div>
                    </div>
                `;
                
                // Show vote breakdown
                const voteBreakdown = document.createElement('div');
                voteBreakdown.className = 'space-y-2';
                
                const voteCounts = new Map();
                this.gameState.votes.forEach(vote => {
                    voteCounts.set(vote, (voteCounts.get(vote) || 0) + 1);
                });
                
                voteCounts.forEach((count, answer) => {
                    const isCorrect = answer === this.gameState.currentPrompt;
                    const submitter = Array.from(this.gameState.guesses.entries()).find(([id, guess]) => guess === answer)?.[0];
                    const submitterName = submitter ? this.gameState.players.get(submitter)?.name : 'Original';
                    
                    const voteDiv = document.createElement('div');
                    voteDiv.className = `p-3 rounded ${isCorrect ? 'bg-green-600' : 'bg-gray-700'}`;
                    voteDiv.innerHTML = `
                        <div class="font-bold">"${answer}"</div>
                        <div class="text-sm text-gray-300">by ${submitterName} ‚Ä¢ ${count} vote${count !== 1 ? 's' : ''}</div>
                    `;
                    voteBreakdown.appendChild(voteDiv);
                });
                
                revealDiv.appendChild(voteBreakdown);
                resultsContent.appendChild(revealDiv);
                
                // Show updated scores
                const scoresDiv = document.createElement('div');
                scoresDiv.className = 'bg-gray-800 rounded-lg p-4';
                scoresDiv.innerHTML = '<div class="text-lg font-bold mb-3">Scores:</div>';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'flex justify-between items-center py-2';
                    playerDiv.innerHTML = `
                        <span>${index + 1}. ${player.name}</span>
                        <span class="font-bold">${player.score}</span>
                    `;
                    scoresDiv.appendChild(playerDiv);
                });
                
                resultsContent.appendChild(scoresDiv);
                
                this.broadcastGameState();
            }
            
            nextRound() {
                if (this.gameState.currentRound >= this.gameState.totalRounds) {
                    this.showFinalResults();
                } else {
                    this.gameState.currentRound++;
                    this.gameState.phase = 'DRAWING';
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    
                    this.assignPrompts();
                    this.broadcastGameState();
                    this.handleStartGame();
                }
            }
            
            showFinalResults() {
                this.showScreen('final-scores-screen');
                
                const finalScoresContent = document.getElementById('final-scores-content');
                finalScoresContent.innerHTML = '';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `bg-gray-800 rounded-lg p-4 mb-3 ${index === 0 ? 'border-2 border-yellow-400' : ''}`;
                    
                    let medal = '';
                    if (index === 0) medal = 'üèÜ';
                    else if (index === 1) medal = 'ü•à';
                    else if (index === 2) medal = 'ü•â';
                    
                    playerDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">${medal}</span>
                                <div>
                                    <div class="font-bold text-lg">${player.name}</div>
                                    <div class="text-sm text-gray-400">${index === 0 ? 'Winner!' : `${index + 1}${this.getOrdinalSuffix(index + 1)} place`}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="text-2xl font-bold">${player.score}</div>
                                <div class="text-sm text-gray-400">${player.likes} üëç</div>
                            </div>
                        </div>
                    `;
                    finalScoresContent.appendChild(playerDiv);
                });
                
                // Add Most Liked Player section
                this.addMostLikedPlayerSection(finalScoresContent);
            }
            
            getOrdinalSuffix(num) {
                const j = num % 10;
                const k = num % 100;
                if (j == 1 && k != 11) return "st";
                if (j == 2 && k != 12) return "nd";
                if (j == 3 && k != 13) return "rd";
                return "th";
            }
            
            addMostLikedPlayerSection(container) {
                // Find the player with the most likes
                const playersWithLikes = Array.from(this.gameState.players.values())
                    .filter(player => player.likes > 0)
                    .sort((a, b) => b.likes - a.likes);
                
                if (playersWithLikes.length === 0) {
                    // No likes given during the game
                    return;
                }
                
                const mostLikedPlayer = playersWithLikes[0];
                const hasMultipleMostLiked = playersWithLikes.length > 1 && playersWithLikes[1].likes === mostLikedPlayer.likes;
                
                // Add separator
                const separatorDiv = document.createElement('div');
                separatorDiv.className = 'w-full border-t border-gray-600 my-6';
                container.appendChild(separatorDiv);
                
                // Add Most Liked Player section header
                const headerDiv = document.createElement('div');
                headerDiv.className = 'text-center mb-4';
                headerDiv.innerHTML = `
                    <h3 class="text-xl font-bold text-purple-400 mb-2">üëç Most Liked Player${hasMultipleMostLiked ? 's' : ''}</h3>
                    <p class="text-sm text-gray-400">For creativity and humor in their guesses!</p>
                `;
                container.appendChild(headerDiv);
                
                // Show all players tied for most likes
                const topLikesCount = mostLikedPlayer.likes;
                const topLikedPlayers = playersWithLikes.filter(player => player.likes === topLikesCount);
                
                topLikedPlayers.forEach((player, index) => {
                    const likedPlayerDiv = document.createElement('div');
                    likedPlayerDiv.className = 'bg-purple-600 bg-opacity-20 border-2 border-purple-400 rounded-lg p-4 mb-3';
                    
                    likedPlayerDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <span class="text-3xl">üëë</span>
                                <div>
                                    <div class="font-bold text-lg text-purple-300">${player.name}</div>
                                    <div class="text-sm text-purple-400">${hasMultipleMostLiked ? 'Co-' : ''}Most Liked Player!</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-bold text-purple-300">${player.likes}</div>
                                <div class="text-sm text-purple-400">likes received</div>
                            </div>
                        </div>
                    `;
                    container.appendChild(likedPlayerDiv);
                });
                
                // Add likes summary if there are multiple players with likes
                if (playersWithLikes.length > topLikedPlayers.length) {
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'text-center mt-4 text-sm text-gray-400';
                    const totalLikes = playersWithLikes.reduce((sum, player) => sum + player.likes, 0);
                    summaryDiv.textContent = `Total likes given in this game: ${totalLikes}`;
                    container.appendChild(summaryDiv);
                }
            }
            
            playAgain() {
                // Reset game state for new game with same players
                this.gameState.currentRound = 0;
                this.gameState.phase = 'LOBBY';
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                
                // Reset player scores
                this.gameState.players.forEach(player => {
                    player.score = 0;
                });
                
                this.broadcastGameState();
                this.showLobby();
            }
            
            newGame() {
                // Redirect to home page for completely new game
                window.location.href = '/';
            }
            
            broadcastDrawingData() {
                const canvas = document.getElementById('drawing-canvas');
                const dataURL = canvas.toDataURL();
                
                this.broadcastMessage({
                    type: 'DRAWING_UPDATE',
                    canvasData: dataURL
                });
            }
            
            updateCanvas(dataURL) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = dataURL;
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connection-status');
                statusElement.textContent = status;
                
                if (status.includes('error')) {
                    statusElement.className = 'text-sm mt-1 text-red-400';
                } else {
                    statusElement.className = 'text-sm mt-1 text-green-400';
                }
            }
            
            showScreen(screenId) {
                // Hide all screens
                document.querySelectorAll('[id$="-screen"]').forEach(screen => {
                    screen.classList.add('hidden');
                });
                
                // Show target screen
                document.getElementById(screenId).classList.remove('hidden');
            }
            
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast px-4 py-2 rounded shadow-lg ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    type === 'warning' ? 'bg-yellow-500' : 
                    'bg-blue-500'
                } text-white`;
                
                toast.classList.remove('hidden');
                
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 3000);
            }
            
            updateUI() {
                // Update UI based on current game state
                switch (this.gameState.phase) {
                    case 'LOBBY':
                        this.updatePlayersDisplay();
                        break;
                    case 'DRAWING':
                        // Drawing phase UI updates
                        break;
                    case 'GUESSING':
                        // Update guessing display
                        break;
                    case 'VOTING':
                        // Update voting display
                        break;
                }
            }
        }
        
        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DrawPartyGame();
        });
        
        // Handle page refresh/reconnection
        window.addEventListener('beforeunload', () => {
            if (window.game) {
                // Stop connection monitoring
                window.game.stopConnectionMonitoring();
                
                // Disconnect peer
                if (window.game.peer) {
                    window.game.peer.disconnect();
                }
            }
        });
        
        // Register Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Handle GitHub Pages path
                const swPath = window.location.hostname === 'astraldrift.github.io' ? '/draw-party-game/sw.js' : '/sw.js';
                navigator.serviceWorker.register(swPath)
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Listen for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available, could show update prompt
                                        console.log('New version available');
                                    }
                                });
                            }
                        });
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'RECONNECT_GAME') {
                        // Attempt to reconnect to game
                        if (window.game && window.game.roomCode) {
                            window.game.initializePeer();
                        }
                    }
                });
            });
        }
    </script>
</body>
</html>