<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Draw Party! üé®</title>
    <meta name="description" content="The easiest multiplayer drawing game - just text a link and play!">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS for P2P networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/draw-party-game/manifest.json">
    <meta name="theme-color" content="#1f2937">
    
    <!-- iOS PWA -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Draw Party">
    
    <style>
        /* Custom styles for canvas and animations */
        .canvas-container {
            touch-action: none;
            position: relative;
        }
        
        .drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            cursor: crosshair;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        .bounce {
            animation: bounce 0.6s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        /* Prevent zoom on double tap */
        * {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div id="app" class="min-h-screen flex flex-col">
        <!-- Loading Screen -->
        <div id="loading" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="text-6xl mb-4">üé®</div>
                <div class="text-2xl font-bold mb-2">Draw Party!</div>
                <div class="text-gray-400">Loading the fun...</div>
            </div>
        </div>
        
        <!-- Toast Container -->
        <div id="toast" class="toast hidden bg-green-500 text-white px-4 py-2 rounded shadow-lg"></div>
        
        <!-- Main App Container -->
        <div id="game-container" class="hidden flex-1 flex flex-col">
            <!-- Header -->
            <header class="bg-gray-800 p-4 text-center">
                <h1 class="text-2xl font-bold">üé® Draw Party!</h1>
                <div id="room-code" class="text-gray-400 mt-1"></div>
                <div id="connection-status" class="text-sm mt-1"></div>
            </header>
            
            <!-- Game Content -->
            <main class="flex-1 p-4">
                <!-- Welcome Screen -->
                <div id="welcome-screen" class="text-center max-w-md mx-auto">
                    <div class="text-6xl mb-6">üé®</div>
                    <h2 class="text-3xl font-bold mb-4">Welcome to Draw Party!</h2>
                    <p class="text-gray-400 mb-8">The easiest multiplayer drawing game ever - just share a link!</p>
                    
                    <div class="space-y-4">
                        <button id="create-room" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                            üéÆ Create New Game
                        </button>
                        <div class="text-gray-500">or</div>
                        <div class="flex gap-2">
                            <input id="join-code" type="text" placeholder="Enter room code" 
                                   class="flex-1 bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-center uppercase" 
                                   maxlength="4">
                            <button id="join-room" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                                Join
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Lobby Screen -->
                <div id="lobby-screen" class="hidden max-w-md mx-auto">
                    <div class="text-center mb-6">
                        <div class="text-4xl mb-2">üè†</div>
                        <h2 class="text-2xl font-bold mb-2">Game Lobby</h2>
                        <div class="bg-gray-800 rounded-lg p-4 mb-4">
                            <div class="text-sm text-gray-400">Room Code</div>
                            <div id="current-room-code" class="text-3xl font-mono font-bold"></div>
                        </div>
                        
                        <button id="share-game" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg mb-4">
                            üì± Share Game Link
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-bold mb-3">Players:</h3>
                        <div id="players-list" class="space-y-2"></div>
                        <div id="waiting-message" class="text-gray-400 text-center mt-4">
                            Waiting for more players... (need at least 3)
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <input id="player-name" type="text" placeholder="Enter your name" 
                               class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3">
                        <button id="start-game" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                            üé® Start Drawing!
                        </button>
                    </div>
                </div>
                
                <!-- Drawing Screen -->
                <div id="drawing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <div id="drawing-prompt" class="text-xl font-bold mb-2 bg-blue-600 rounded-lg p-4"></div>
                        <div id="drawing-timer" class="text-2xl font-mono"></div>
                    </div>
                    
                    <div class="canvas-container mx-auto mb-4" style="max-width: 400px;">
                        <canvas id="drawing-canvas" class="drawing-canvas w-full" width="400" height="300"></canvas>
                    </div>
                    
                    <div class="flex flex-wrap gap-2 justify-center mb-4">
                        <!-- Color palette -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2">
                            <button class="color-btn w-8 h-8 rounded-full bg-black border-2 border-white" data-color="#000000"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-red-500" data-color="#ef4444"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-blue-500" data-color="#3b82f6"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-green-500" data-color="#10b981"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-yellow-500" data-color="#f59e0b"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-purple-500" data-color="#8b5cf6"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-pink-500" data-color="#ec4899"></button>
                            <button class="color-btn w-8 h-8 rounded-full bg-orange-500" data-color="#f97316"></button>
                        </div>
                        
                        <!-- Tools -->
                        <div class="flex gap-1 bg-gray-800 rounded-lg p-2">
                            <button id="brush-small" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Small</button>
                            <button id="brush-medium" class="tool-btn bg-blue-600 hover:bg-blue-500 px-3 py-2 rounded text-sm">Medium</button>
                            <button id="brush-large" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Large</button>
                            <button id="eraser" class="tool-btn bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded text-sm">Eraser</button>
                            <button id="clear-canvas" class="tool-btn bg-red-600 hover:bg-red-500 px-3 py-2 rounded text-sm">Clear</button>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <div class="text-sm text-gray-400 mb-2">‚ö†Ô∏è No letters or words allowed!</div>
                        <div id="other-players-status" class="text-gray-400"></div>
                    </div>
                </div>
                
                <!-- Guessing Screen -->
                <div id="guessing-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">What do you think this is?</h2>
                        <div id="guessing-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400 mb-4">Write the real answer OR something funny to trick others!</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <canvas id="guess-canvas" class="w-full border rounded" width="400" height="300"></canvas>
                        <div class="text-center mt-2 text-sm text-gray-400" id="artist-name"></div>
                    </div>
                    
                    <div class="max-w-md mx-auto">
                        <input id="guess-input" type="text" placeholder="What is this drawing?" 
                               class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 mb-4">
                        <button id="submit-guess" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            Submit Answer
                        </button>
                    </div>
                </div>
                
                <!-- Voting Screen -->
                <div id="voting-screen" class="hidden">
                    <div class="text-center mb-4">
                        <h2 class="text-2xl font-bold mb-2">Which is the REAL answer?</h2>
                        <div id="voting-timer" class="text-xl font-mono mb-4"></div>
                        <div class="text-sm text-gray-400">Vote for what you think was the original prompt</div>
                    </div>
                    
                    <div class="mb-6 bg-gray-800 rounded-lg p-4">
                        <canvas id="vote-canvas" class="w-full border rounded" width="400" height="300"></canvas>
                    </div>
                    
                    <div id="voting-options" class="space-y-3 max-w-md mx-auto">
                        <!-- Voting options will be populated here -->
                    </div>
                </div>
                
                <!-- Results Screen -->
                <div id="results-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üéâ Round Results!</h2>
                    </div>
                    
                    <div id="results-content" class="max-w-md mx-auto">
                        <!-- Results will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6">
                        <button id="next-round" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            Next Round üé®
                        </button>
                    </div>
                </div>
                
                <!-- Final Scores Screen -->
                <div id="final-scores-screen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-3xl font-bold mb-4">üèÜ Final Results!</h2>
                    </div>
                    
                    <div id="final-scores-content" class="max-w-md mx-auto">
                        <!-- Final scores will be populated here -->
                    </div>
                    
                    <div class="text-center mt-6 space-y-4">
                        <button id="play-again" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">
                            üéÆ Play Again!
                        </button>
                        <button id="new-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">
                            üé® New Game
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Game Core - All functionality embedded
        class DrawPartyGame {
            constructor() {
                console.log('üé® Draw Party Game v1.5.0 - SERIALIZATION FIX LOADED!', new Date().toISOString());
                console.log('üîß If you see old behavior, clear browser cache or hard refresh (Ctrl+Shift+R)');
                
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.isLocalMode = false;
                this.playerId = this.generateId();
                this.playerName = '';
                this.roomCode = '';
                this.gameState = {
                    phase: 'LOBBY',
                    players: new Map(),
                    currentRound: 0,
                    totalRounds: 5,
                    currentArtist: null,
                    currentDrawing: null,
                    currentPrompt: '',
                    guesses: new Map(),
                    votes: new Map(),
                    scores: new Map()
                };
                
                // Drawing canvas state
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.currentSize = 3;
                this.currentTool = 'brush';
                
                this.init();
            }
            
            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }
            
            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let result = '';
                for (let i = 0; i < 4; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }
            
            init() {
                this.hideLoading();
                this.setupEventListeners();
                this.setupCanvas();
                this.checkForRoomInURL();
            }
            
            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('game-container').classList.remove('hidden');
                }, 1000);
            }
            
            checkForRoomInURL() {
                const path = window.location.pathname;
                
                // Extract room code from various URL formats:
                // localhost:3000/ABCD -> ABCD
                // astraldrift.github.io/draw-party-game/ABCD -> ABCD
                let roomCode = null;
                
                if (path.includes('/draw-party-game/')) {
                    // GitHub Pages format
                    const parts = path.split('/draw-party-game/');
                    if (parts[1] && parts[1].length === 4) {
                        roomCode = parts[1];
                    }
                } else {
                    // Localhost format
                    const parts = path.slice(1); // Remove leading /
                    if (parts.length === 4) {
                        roomCode = parts;
                    }
                }
                
                if (roomCode && roomCode.length === 4) {
                    console.log('üîó Found room code in URL:', roomCode);
                    document.getElementById('join-code').value = roomCode;
                    this.joinRoom(roomCode);
                }
            }
            
            setupEventListeners() {
                // Welcome screen
                document.getElementById('create-room').addEventListener('click', () => this.createRoom());
                document.getElementById('join-room').addEventListener('click', () => {
                    const code = document.getElementById('join-code').value.toUpperCase();
                    if (code.length === 4) this.joinRoom(code);
                });
                
                document.getElementById('join-code').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase();
                });
                
                // Lobby screen
                document.getElementById('share-game').addEventListener('click', () => this.shareGame());
                document.getElementById('start-game').addEventListener('click', () => this.startGame());
                document.getElementById('player-name').addEventListener('input', (e) => {
                    this.playerName = e.target.value.trim();
                    
                    // Update player in game state
                    if (this.gameState.players.has(this.playerId)) {
                        const player = this.gameState.players.get(this.playerId);
                        player.name = this.playerName || (this.isHost ? 'Host' : 'Player');
                        this.gameState.players.set(this.playerId, player);
                    } else {
                        this.gameState.players.set(this.playerId, {
                            id: this.playerId,
                            name: this.playerName || (this.isHost ? 'Host' : 'Player'),
                            score: 0,
                            connected: true
                        });
                    }
                    
                    // Broadcast to other players
                    if (this.broadcastLocal) {
                        this.broadcastLocal({
                            type: 'PLAYER_UPDATE',
                            playerId: this.playerId,
                            playerName: this.playerName || (this.isHost ? 'Host' : 'Player')
                        });
                    }
                    
                    this.updateStartButton();
                    this.updatePlayersDisplay();
                });
                
                // Drawing tools
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectColor(e.target.dataset.color));
                });
                
                document.getElementById('brush-small').addEventListener('click', () => this.selectBrush(1));
                document.getElementById('brush-medium').addEventListener('click', () => this.selectBrush(3));
                document.getElementById('brush-large').addEventListener('click', () => this.selectBrush(6));
                document.getElementById('eraser').addEventListener('click', () => this.selectEraser());
                document.getElementById('clear-canvas').addEventListener('click', () => this.clearCanvas());
                
                // Game actions
                document.getElementById('submit-guess').addEventListener('click', () => this.submitGuess());
                document.getElementById('next-round').addEventListener('click', () => this.nextRound());
                document.getElementById('play-again').addEventListener('click', () => this.playAgain());
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                
                // Enter key handlers
                document.getElementById('join-code').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('join-room').click();
                });
                document.getElementById('player-name').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('start-game').click();
                });
                document.getElementById('guess-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') document.getElementById('submit-guess').click();
                });
            }
            
            setupCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                
                // Touch events
                canvas.addEventListener('touchstart', (e) => this.startDrawing(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.draw(e), { passive: false });
                canvas.addEventListener('touchend', () => this.stopDrawing());
                
                // Mouse events  
                canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                canvas.addEventListener('mousemove', (e) => this.draw(e));
                canvas.addEventListener('mouseup', () => this.stopDrawing());
                canvas.addEventListener('mouseout', () => this.stopDrawing());
                
                // Prevent scrolling when drawing
                canvas.addEventListener('touchstart', (e) => e.preventDefault());
                canvas.addEventListener('touchmove', (e) => e.preventDefault());
            }
            
            getCanvasCoordinates(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            startDrawing(e) {
                if (this.gameState.phase !== 'DRAWING') return;
                
                this.isDrawing = true;
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                
                this.lastPos = pos;
            }
            
            draw(e) {
                if (!this.isDrawing || this.gameState.phase !== 'DRAWING') return;
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const pos = this.getCanvasCoordinates(e, canvas);
                
                ctx.lineWidth = this.currentSize;
                ctx.lineCap = 'round';
                ctx.strokeStyle = this.currentTool === 'eraser' ? '#FFFFFF' : this.currentColor;
                ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                
                ctx.beginPath();
                ctx.moveTo(this.lastPos.x, this.lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                
                this.lastPos = pos;
                
                // Broadcast drawing to other players if host
                if (this.isHost) {
                    this.broadcastDrawingData();
                }
            }
            
            stopDrawing() {
                this.isDrawing = false;
            }
            
            selectColor(color) {
                this.currentColor = color;
                this.currentTool = 'brush';
                this.updateToolButtons();
            }
            
            selectBrush(size) {
                this.currentSize = size;
                this.currentTool = 'brush';
                this.updateToolButtons();
            }
            
            selectEraser() {
                this.currentTool = 'eraser';
                this.currentSize = 10;
                this.updateToolButtons();
            }
            
            updateToolButtons() {
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('bg-blue-600'));
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('border-white'));
                
                if (this.currentTool === 'brush') {
                    const sizeMap = { 1: 'brush-small', 3: 'brush-medium', 6: 'brush-large' };
                    document.getElementById(sizeMap[this.currentSize])?.classList.add('bg-blue-600');
                    document.querySelector(`[data-color="${this.currentColor}"]`)?.classList.add('border-white');
                } else if (this.currentTool === 'eraser') {
                    document.getElementById('eraser').classList.add('bg-blue-600');
                }
            }
            
            clearCanvas() {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (this.isHost) {
                    this.broadcastDrawingData();
                }
            }
            
            createRoom() {
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                // Update URL for sharing
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                // Create peer with host ID so others can find us
                this.createHostPeer();
                this.showLobby();
            }
            
            createHostPeer() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üëë Creating host peer with ID:', hostId);
                
                this.peer = new Peer(hostId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Host peer opened with ID:', id);
                    console.log('üåê Host peer object:', this.peer);
                    this.updateConnectionStatus('Host ready - share room code!');
                    
                    // CRITICAL FIX: Host must add themselves to the players list
                    console.log('‚ûï Host adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true
                    });
                    
                    this.updatePlayersDisplay();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Host received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Host peer error:', err);
                    this.updateConnectionStatus('Host connection error');
                    this.setupLocalTesting();
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Host peer disconnected');
                });
            }
            
            joinRoom(code) {
                this.roomCode = code;
                
                // For cross-device multiplayer, we always start as player and try to connect to host
                // Only become host if no host exists
                this.isHost = false;
                
                // Update URL - handle GitHub Pages path
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                window.history.pushState({}, '', `${basePath}/${this.roomCode}`);
                
                this.initializePeer();
                this.showLobby();
            }
            
            initializePeer() {
                try {
                    // Local testing mode for same-device development
                    if (window.location.hostname === 'localhost' || 
                        window.location.hostname === '127.0.0.1' || 
                        window.location.protocol === 'file:') {
                        this.setupLocalTesting();
                        return;
                    }
                    
                    // For joinRoom, create player peer and try to connect to host
                    if (!this.isHost) {
                        this.createPlayerPeer();
                    }
                    // For createRoom, host peer is already created in createHostPeer()
                    
                } catch (error) {
                    // If PeerJS fails, fall back to local mode
                    this.updateConnectionStatus('Local mode fallback');
                    this.setupLocalTesting();
                }
            }
            
            createPlayerPeer() {
                console.log('üé≠ Creating player peer with ID:', this.playerId);
                
                this.peer = new Peer(this.playerId, {
                    secure: true,
                    debug: 1, // Enable PeerJS debugging
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    console.log('üéØ Player peer opened with ID:', id);
                    console.log('üåê Peer object:', this.peer);
                    this.updateConnectionStatus('Peer ready, connecting to host...');
                    
                    // Small delay to ensure peer is fully ready
                    setTimeout(() => {
                        this.connectToHost();
                    }, 500);
                });
                
                this.peer.on('error', (err) => {
                    console.log('‚ùå Player peer error:', err);
                    this.updateConnectionStatus('Peer connection failed');
                    this.setupLocalTesting();
                });
                
                this.peer.on('connection', (conn) => {
                    console.log('üìû Player received incoming connection from:', conn.peer);
                    this.handleConnection(conn);
                });
                
                this.peer.on('disconnected', () => {
                    console.log('üîå Player peer disconnected');
                });
            }
            
            setupLocalTesting() {
                if (this.isLocalMode) return;
                
                this.isLocalMode = true;
                
                // Clean up any existing peer connection
                if (this.peer) {
                    try { this.peer.destroy(); } catch (e) {}
                    this.peer = null;
                }
                
                this.updateConnectionStatus('Local mode');
                this.localConnections = new Map();
                
                setTimeout(() => {
                    this.updateConnectionStatus('Connected (Local)');
                    if (!this.isHost) {
                        this.connectToLocalHost();
                    }
                }, 500);
                
                this.setupLocalStorageSync();
            }
            
            setupLocalStorageSync() {
                // Use localStorage to sync between browser tabs for local testing
                const storageKey = `drawparty_${this.roomCode}`;
                
                // Listen for storage changes (from other tabs)
                window.addEventListener('storage', (e) => {
                    if (e.key === storageKey && e.newValue) {
                        const data = JSON.parse(e.newValue);
                        this.handleLocalMessage(data);
                    }
                });
                
                // Broadcast to localStorage
                this.broadcastLocal = (message) => {
                    const data = {
                        timestamp: Date.now(),
                        fromPlayer: this.playerId,
                        isHost: this.isHost,
                        message: message
                    };
                    localStorage.setItem(storageKey, JSON.stringify(data));
                };
                
                // Announce presence after a short delay to ensure setup is complete
                setTimeout(() => {
                    this.broadcastLocal({
                        type: 'PLAYER_JOIN',
                        playerId: this.playerId,
                        playerName: this.playerName || 'Player'
                    });
                }, 100);
            }
            
            handleLocalMessage(data) {
                // Don't process our own messages
                if (data.fromPlayer === this.playerId) return;
                
                this.handleMessage(data.message, data.fromPlayer);
                
                // If this is a new player joining, send them our current state
                if (data.message.type === 'PLAYER_JOIN' && this.isHost) {
                    setTimeout(() => {
                        this.broadcastGameState();
                    }, 200);
                }
            }
            
            connectToLocalHost() {
                // Simulate connecting to host in local mode
                setTimeout(() => {
                    console.log('Connected to local host');
                    this.localConnections.set('host', true);
                }, 200);
            }
            
            connectToHost() {
                const hostId = `${this.roomCode}_HOST`;
                console.log('üîå Attempting to connect to host:', hostId);
                
                // Increase timeout to 8 seconds for better connection reliability
                const connectionTimeout = setTimeout(() => {
                    console.log('‚è∞ Connection timeout - no host found, becoming host');
                    this.becomeHost();
                }, 8000);
                
                try {
                    console.log('üìû Creating connection to host...');
                    const conn = this.peer.connect(hostId);
                    
                    conn.on('open', () => {
                        console.log('‚úÖ Successfully connected to host!');
                        clearTimeout(connectionTimeout);
                        this.updateConnectionStatus('Connected to host');
                        this.handleConnection(conn);
                    });
                    
                    conn.on('error', (err) => {
                        console.log('‚ùå Connection error:', err);
                        clearTimeout(connectionTimeout);
                        this.becomeHost();
                    });
                    
                    conn.on('close', () => {
                        console.log('üîå Connection to host closed');
                    });
                    
                    // Add debugging for connection metadata
                    conn.on('data', (data) => {
                        console.log('üì• Data from host:', data);
                    });
                    
                } catch (error) {
                    console.log('üí• Exception connecting to host:', error);
                    clearTimeout(connectionTimeout);
                    this.becomeHost();
                }
            }
            
            becomeHost() {
                if (this.isHost) return; // Already host
                
                this.isHost = true;
                this.updateConnectionStatus('Became host (no existing host found)');
                
                // Update our peer ID to be the host
                if (this.peer) {
                    this.peer.destroy();
                }
                
                // Recreate peer with host ID
                this.peer = new Peer(`${this.roomCode}_HOST`, {
                    secure: true,
                    debug: 0,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    console.log('üéØ becomeHost peer opened');
                    this.updateConnectionStatus('Host ready');
                    
                    // CRITICAL FIX: Host must add themselves to the players list when they become host
                    console.log('‚ûï becomeHost adding themselves to players list');
                    this.gameState.players.set(this.playerId, {
                        id: this.playerId,
                        name: this.playerName || 'Host',
                        score: 0,
                        connected: true
                    });
                });
                
                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });
                
                this.updatePlayersDisplay();
            }
            
            handleConnection(conn) {
                conn.on('open', () => {
                    console.log('üîó Connection established with:', conn.peer);
                    console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                    this.connections.set(conn.peer, conn);
                    
                    if (this.isHost) {
                        console.log('üì° Host sending ROOM_JOINED to:', conn.peer);
                        this.sendToPlayer(conn.peer, { type: 'ROOM_JOINED', roomCode: this.roomCode });
                        
                        // CRITICAL: Host should also immediately send current game state to new player
                        console.log('üì° Host also sending current game state to new player');
                        this.broadcastGameState();
                    } else {
                        console.log('üì° Player sending PLAYER_JOIN to host:', conn.peer);
                        this.sendToPlayer(conn.peer, { type: 'PLAYER_JOIN', playerId: this.playerId, playerName: this.playerName });
                    }
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer);
                });
                
                conn.on('close', () => {
                    console.log('Connection closed');
                    this.connections.delete(conn.peer);
                    this.updatePlayersDisplay();
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                });
            }
            
            handleMessage(message, fromPeer) {
                console.log('üì® Received message:', message.type, 'from:', fromPeer);
                console.log('üì® Message details:', message);
                
                switch (message.type) {
                    case 'PLAYER_JOIN':
                        console.log('üéØ Handling PLAYER_JOIN. I am host?', this.isHost);
                        if (this.isHost) {
                            console.log('‚ûï Host adding player to gameState:', message.playerId, message.playerName);
                            this.gameState.players.set(message.playerId, {
                                id: message.playerId,
                                name: message.playerName || 'Player',
                                score: 0,
                                connected: true
                            });
                            console.log('üì° Host broadcasting game state after adding player');
                            this.broadcastGameState();
                        } else {
                            console.log('üë§ Non-host received PLAYER_JOIN, ignoring');
                        }
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'PLAYER_UPDATE':
                        if (this.gameState.players.has(message.playerId)) {
                            const player = this.gameState.players.get(message.playerId);
                            player.name = message.playerName || 'Player';
                            this.gameState.players.set(message.playerId, player);
                        }
                        this.updatePlayersDisplay();
                        if (this.isHost) {
                            this.broadcastGameState();
                        }
                        break;
                        
                    case 'HOST_PRESENCE':
                        // Host presence detected, no action needed
                        break;
                        
                    case 'GAME_STATE_UPDATE':
                        console.log('üì• Received GAME_STATE_UPDATE:', message.gameState);
                        console.log('üîç Before update - players.size:', this.gameState.players.size);
                        
                        // CRITICAL FIX: Rebuild ALL Maps from arrays
                        if (message.gameState.players && Array.isArray(message.gameState.players)) {
                            console.log('üîÑ Converting players array to Map:', message.gameState.players);
                            this.gameState.players.clear();
                            message.gameState.players.forEach(([id, player]) => {
                                console.log('‚ûï Adding player from game state:', id, player);
                                this.gameState.players.set(id, player);
                            });
                            console.log('‚úÖ Players Map rebuilt - size:', this.gameState.players.size);
                        }
                        
                        // Rebuild other Maps from arrays
                        if (message.gameState.guesses && Array.isArray(message.gameState.guesses)) {
                            this.gameState.guesses.clear();
                            message.gameState.guesses.forEach(([id, guess]) => this.gameState.guesses.set(id, guess));
                        }
                        
                        if (message.gameState.votes && Array.isArray(message.gameState.votes)) {
                            this.gameState.votes.clear();
                            message.gameState.votes.forEach(([id, vote]) => this.gameState.votes.set(id, vote));
                        }
                        
                        if (message.gameState.scores && Array.isArray(message.gameState.scores)) {
                            this.gameState.scores.clear();
                            message.gameState.scores.forEach(([id, score]) => this.gameState.scores.set(id, score));
                        }
                        
                        if (message.gameState.playerPrompts && Array.isArray(message.gameState.playerPrompts)) {
                            if (!this.gameState.playerPrompts) this.gameState.playerPrompts = new Map();
                            this.gameState.playerPrompts.clear();
                            message.gameState.playerPrompts.forEach(([id, prompt]) => this.gameState.playerPrompts.set(id, prompt));
                        }
                        
                        // Update scalar properties only
                        const { players, guesses, votes, scores, playerPrompts, ...scalarState } = message.gameState;
                        Object.assign(this.gameState, scalarState);
                        
                        console.log('üìä Final gameState players.size:', this.gameState.players.size);
                        this.updateUI();
                        this.updatePlayersDisplay();
                        break;
                        
                    case 'START_GAME':
                        this.handleStartGame();
                        break;
                        
                    case 'DRAWING_UPDATE':
                        this.updateCanvas(message.canvasData);
                        break;
                        
                    case 'GUESS_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.guesses.set(message.playerId, message.guess);
                            this.checkAllGuessesSubmitted();
                        }
                        break;
                        
                    case 'VOTE_SUBMITTED':
                        if (this.isHost) {
                            this.gameState.votes.set(message.playerId, message.vote);
                            this.checkAllVotesSubmitted();
                        }
                        break;
                }
            }
            
            sendToPlayer(playerId, message) {
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    this.broadcastLocal(message);
                    return;
                }
                
                const conn = this.connections.get(playerId);
                if (conn && conn.open) {
                    conn.send(message);
                }
            }
            
            broadcastMessage(message) {
                // For local testing, use localStorage
                if (this.broadcastLocal) {
                    this.broadcastLocal(message);
                    return;
                }
                
                this.connections.forEach((conn, playerId) => {
                    if (conn.open) {
                        conn.send(message);
                    }
                });
            }
            
            broadcastGameState() {
                console.log('üì° Broadcasting game state');
                console.log('üìä Current players before broadcast:', this.gameState.players.size);
                console.log('üìã Players being broadcast:', Array.from(this.gameState.players.entries()));
                
                // CRITICAL FIX: Convert ALL Maps to Arrays for serialization
                const gameStateForBroadcast = {
                    currentRound: this.gameState.currentRound || 0,
                    totalRounds: this.gameState.totalRounds || 5,
                    phase: this.gameState.phase || 'lobby',
                    currentDrawer: this.gameState.currentDrawer || null,
                    currentPrompt: this.gameState.currentPrompt || null,
                    timeLeft: this.gameState.timeLeft || 0,
                    players: Array.from(this.gameState.players.entries()),
                    guesses: Array.from(this.gameState.guesses.entries()),
                    votes: Array.from(this.gameState.votes.entries()),
                    scores: Array.from(this.gameState.scores.entries()),
                    playerPrompts: this.gameState.playerPrompts ? Array.from(this.gameState.playerPrompts.entries()) : []
                };
                
                console.log('üì§ Sending GAME_STATE_UPDATE with safe data to', this.connections.size, 'connections');
                console.log('üîç Safe gameState:', gameStateForBroadcast);
                
                this.broadcastMessage({
                    type: 'GAME_STATE_UPDATE',
                    gameState: gameStateForBroadcast
                });
            }
            
            showLobby() {
                this.showScreen('lobby-screen');
                document.getElementById('current-room-code').textContent = this.roomCode;
                document.getElementById('room-code').textContent = `Room: ${this.roomCode}`;
                
                // Add current player to game state (don't assume name yet)
                this.gameState.players.set(this.playerId, {
                    id: this.playerId,
                    name: this.playerName || (this.isHost ? 'Host' : 'Player'),
                    score: 0,
                    connected: true
                });
                
                // Focus the name input for easy editing
                setTimeout(() => {
                    const nameInput = document.getElementById('player-name');
                    if (nameInput) {
                        nameInput.focus();
                        nameInput.placeholder = `Enter your name...`;
                    }
                }, 100);
                
                this.updatePlayersDisplay();
                
                // Host presence is now saved immediately in createRoom(), no need to duplicate here
            }
            
            updatePlayersDisplay() {
                console.log('üîÑ updatePlayersDisplay called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                    return;
                }
                
                console.log('üìä Current players in gameState:', this.gameState.players.size);
                const playersArray = Array.from(this.gameState.players.entries());
                console.log('üìã Players list:', playersArray);
                playersArray.forEach(([id, player], index) => {
                    console.log(`üë§ Player ${index + 1}: ID=${id}, Name=${player.name}, Connected=${player.connected}`);
                });
                console.log('üé≠ I am:', this.playerId, 'Host?', this.isHost);
                
                const playersList = document.getElementById('players-list');
                playersList.innerHTML = '';
                
                this.gameState.players.forEach((player, id) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'bg-gray-800 rounded-lg p-3 flex items-center justify-between';
                    playerDiv.innerHTML = `
                        <div class="flex items-center gap-3">
                            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                                ${player.name.charAt(0).toUpperCase()}
                            </div>
                            <span>${player.name}</span>
                            ${id === this.playerId ? '<span class="text-blue-400">(You)</span>' : ''}
                            ${this.isHost && id === this.playerId ? '<span class="text-yellow-400">(Host)</span>' : ''}
                        </div>
                        <div class="text-sm text-gray-400">
                            Score: ${player.score}
                        </div>
                    `;
                    playersList.appendChild(playerDiv);
                });
                
                this.updateStartButton();
            }
            
            updateStartButton() {
                console.log('üöÄ updateStartButton called');
                
                // CRITICAL: Add Map validation
                if (!(this.gameState.players instanceof Map)) {
                    console.error('‚ùå CRITICAL: gameState.players is not a Map in updateStartButton!', typeof this.gameState.players, this.gameState.players);
                    console.log('üîß Attempting to fix by creating new Map');
                    this.gameState.players = new Map();
                }
                
                console.log('üìè gameState.players.size:', this.gameState.players.size);
                console.log('üó∫Ô∏è gameState.players Map:', this.gameState.players);
                console.log('üìù playerName:', this.playerName);
                console.log('üëë isHost:', this.isHost);
                
                const startButton = document.getElementById('start-game');
                const hasName = this.playerName && this.playerName.length > 0;
                const canStart = this.isHost && this.gameState.players.size >= 2 && hasName;
                
                startButton.disabled = !canStart;
                
                const waitingMessage = document.getElementById('waiting-message');
                if (this.gameState.players.size < 2) {
                    waitingMessage.textContent = `Waiting for more players... (need at least 2, have ${this.gameState.players.size})`;
                    console.log('üî¥ Not enough players:', this.gameState.players.size);
                } else if (!hasName) {
                    waitingMessage.textContent = 'Enter your name to continue';
                    console.log('üî¥ No player name');
                } else if (this.isHost) {
                    waitingMessage.textContent = 'Ready to start!';
                    console.log('üü¢ Ready to start!');
                } else {
                    waitingMessage.textContent = 'Waiting for host to start the game...';
                    console.log('üü° Waiting for host');
                }
            }
            
            shareGame() {
                // Generate correct share URL for GitHub Pages
                const basePath = window.location.pathname.includes('/draw-party-game') ? '/draw-party-game' : '';
                const shareUrl = `${window.location.origin}${basePath}/${this.roomCode}`;
                const shareData = {
                    title: 'üé® Join our drawing game!',
                    text: `Game time! Tap to join ‚Üí`,
                    url: shareUrl
                };
                
                if (navigator.share) {
                    navigator.share(shareData).catch(console.error);
                } else {
                    navigator.clipboard.writeText(shareUrl).then(() => {
                        this.showToast('Link copied! Send to friends üì±', 'success');
                    }).catch(() => {
                        this.showToast('Share URL: ' + shareUrl, 'info');
                    });
                }
            }
            
            startGame() {
                if (!this.isHost || this.gameState.players.size < 3) return;
                
                this.gameState.phase = 'DRAWING';
                this.gameState.currentRound = 1;
                this.assignPrompts();
                this.broadcastGameState();
                this.broadcastMessage({ type: 'START_GAME' });
                this.handleStartGame();
            }
            
            handleStartGame() {
                this.showDrawingScreen();
                this.startDrawingTimer();
            }
            
            assignPrompts() {
                // Assign unique prompts to each player
                const prompts = this.getRandomPrompts(this.gameState.players.size);
                const playerIds = Array.from(this.gameState.players.keys());
                
                this.gameState.playerPrompts = new Map();
                playerIds.forEach((playerId, index) => {
                    this.gameState.playerPrompts.set(playerId, prompts[index]);
                });
            }
            
            getRandomPrompts(count) {
                const allPrompts = [
                    "Robot eating pizza", "Cat playing guitar", "Dinosaur on skateboard",
                    "Wizard making coffee", "Shark wearing hat", "Invisible man in mirror",
                    "Spaghetti tornado", "Crying birthday cake", "Dancing refrigerator", 
                    "Sneezing volcano", "Time-traveling sandwich", "Vampire dentist appointment",
                    "Yoga class for furniture", "Cow abducting aliens", "Angry broccoli army",
                    "Romantic dinner between phones", "Hamster business meeting", "Cactus beauty pageant",
                    "Penguin fire department", "Banana phone tech support", "Pirate scared of water",
                    "Grandma vs. ninja squirrels", "Battle of the condiments", "Escape from vegetable prison",
                    "Racing shopping carts downhill", "Dodgeball with planets", "Santa's summer vacation",
                    "Halloween costume for house", "Turkey plotting revenge", "New Year's Eve for clocks",
                    "Valentine's Day for robots", "Ninja fighting a pi√±ata", "Octopus bartender",
                    "Vampire accountant", "Cowboy surfing in space", "Grandma skateboarding in a volcano",
                    "The feeling of Monday", "WiFi signal as a person", "Procrastination monster",
                    "Sound of silence", "Upside-down gravity", "Sleepy ninja eating spaghetti",
                    "Angry dentist fighting a balloon", "Banana driving a car", "Pizza doing yoga",
                    "Dinosaur mixed with disco ball", "Submarine mixed with birthday cake"
                ];
                
                const shuffled = allPrompts.sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            showDrawingScreen() {
                this.showScreen('drawing-screen');
                const myPrompt = this.gameState.playerPrompts?.get(this.playerId) || 'Draw something fun!';
                document.getElementById('drawing-prompt').textContent = `Draw this: ${myPrompt}`;
                
                // Clear and prepare canvas
                this.clearCanvas();
                this.updateToolButtons();
            }
            
            startDrawingTimer() {
                let timeLeft = 60;
                const timerElement = document.getElementById('drawing-timer');
                
                const timer = setInterval(() => {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (timeLeft <= 10) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.endDrawingPhase();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            endDrawingPhase() {
                if (this.isHost) {
                    this.gameState.phase = 'GUESSING';
                    this.selectRandomDrawing();
                    this.broadcastGameState();
                }
                this.showGuessingScreen();
            }
            
            selectRandomDrawing() {
                const playerIds = Array.from(this.gameState.players.keys());
                const randomIndex = Math.floor(Math.random() * playerIds.length);
                this.gameState.currentArtist = playerIds[randomIndex];
                this.gameState.currentPrompt = this.gameState.playerPrompts.get(this.gameState.currentArtist);
                
                // Capture canvas data (in real implementation, this would be sent from the artist)
                const canvas = document.getElementById('drawing-canvas');
                this.gameState.currentDrawing = canvas.toDataURL();
            }
            
            showGuessingScreen() {
                this.showScreen('guessing-screen');
                
                // Copy drawing to guess canvas
                const sourceCanvas = document.getElementById('drawing-canvas');
                const guessCanvas = document.getElementById('guess-canvas');
                const ctx = guessCanvas.getContext('2d');
                
                if (this.gameState.currentDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = this.gameState.currentDrawing;
                } else {
                    ctx.drawImage(sourceCanvas, 0, 0);
                }
                
                const artistName = this.gameState.players.get(this.gameState.currentArtist)?.name || 'Someone';
                document.getElementById('artist-name').textContent = `Drawn by ${artistName}`;
                
                this.startGuessingTimer();
            }
            
            startGuessingTimer() {
                let timeLeft = 30;
                const timerElement = document.getElementById('guessing-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        this.submitGuess();
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitGuess() {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();
                
                if (!guess) {
                    this.showToast('Please enter a guess!', 'warning');
                    return;
                }
                
                if (this.isHost) {
                    this.gameState.guesses.set(this.playerId, guess);
                    this.checkAllGuessesSubmitted();
                } else {
                    this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'GUESS_SUBMITTED',
                        playerId: this.playerId,
                        guess: guess
                    });
                }
                
                guessInput.disabled = true;
                document.getElementById('submit-guess').disabled = true;
                this.showToast('Guess submitted!', 'success');
            }
            
            checkAllGuessesSubmitted() {
                if (this.gameState.guesses.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.startVotingPhase();
                }
            }
            
            startVotingPhase() {
                this.gameState.phase = 'VOTING';
                this.broadcastGameState();
                this.showVotingScreen();
            }
            
            showVotingScreen() {
                this.showScreen('voting-screen');
                
                // Copy drawing to vote canvas
                const voteCanvas = document.getElementById('vote-canvas');
                const ctx = voteCanvas.getContext('2d');
                
                if (this.gameState.currentDrawing) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, voteCanvas.width, voteCanvas.height);
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = this.gameState.currentDrawing;
                }
                
                this.displayVotingOptions();
                this.startVotingTimer();
            }
            
            displayVotingOptions() {
                const votingOptions = document.getElementById('voting-options');
                votingOptions.innerHTML = '';
                
                // Collect all answers plus the real one
                const allOptions = Array.from(this.gameState.guesses.values());
                allOptions.push(this.gameState.currentPrompt);
                
                // Shuffle options
                const shuffledOptions = allOptions.sort(() => 0.5 - Math.random());
                
                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.className = 'w-full bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded-lg p-4 text-left transition-colors';
                    button.textContent = option;
                    button.addEventListener('click', () => this.submitVote(option));
                    votingOptions.appendChild(button);
                });
            }
            
            startVotingTimer() {
                let timeLeft = 20;
                const timerElement = document.getElementById('voting-timer');
                
                const timer = setInterval(() => {
                    timerElement.textContent = `‚è∞ ${timeLeft}s`;
                    
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        // Auto-submit random vote if no vote made
                        if (!this.gameState.votes.has(this.playerId)) {
                            const options = Array.from(document.getElementById('voting-options').children);
                            const randomOption = options[Math.floor(Math.random() * options.length)];
                            this.submitVote(randomOption.textContent);
                        }
                    }
                    
                    timeLeft--;
                }, 1000);
            }
            
            submitVote(vote) {
                if (this.isHost) {
                    this.gameState.votes.set(this.playerId, vote);
                    this.checkAllVotesSubmitted();
                } else {
                    this.sendToPlayer(`${this.roomCode}_HOST`, {
                        type: 'VOTE_SUBMITTED',
                        playerId: this.playerId,
                        vote: vote
                    });
                }
                
                // Disable all voting buttons
                document.querySelectorAll('#voting-options button').forEach(btn => {
                    btn.disabled = true;
                    if (btn.textContent === vote) {
                        btn.classList.add('bg-blue-600');
                    }
                });
                
                this.showToast('Vote submitted!', 'success');
            }
            
            checkAllVotesSubmitted() {
                if (this.gameState.votes.size >= this.gameState.players.size - 1) { // -1 for artist
                    this.calculateScores();
                    this.showResults();
                }
            }
            
            calculateScores() {
                // Award points based on voting results
                this.gameState.votes.forEach((vote, voterId) => {
                    // Points for correct guesses
                    if (vote === this.gameState.currentPrompt) {
                        const player = this.gameState.players.get(voterId);
                        if (player) {
                            player.score += 200;
                        }
                    }
                    
                    // Points for tricking others with fake answers
                    this.gameState.guesses.forEach((guess, guesserId) => {
                        if (vote === guess && voterId !== guesserId) {
                            const trickster = this.gameState.players.get(guesserId);
                            if (trickster) {
                                trickster.score += 50;
                            }
                        }
                    });
                });
                
                // Points for artist (per correct guess)
                let correctGuesses = 0;
                this.gameState.votes.forEach(vote => {
                    if (vote === this.gameState.currentPrompt) {
                        correctGuesses++;
                    }
                });
                
                const artist = this.gameState.players.get(this.gameState.currentArtist);
                if (artist) {
                    artist.score += correctGuesses * 100;
                }
            }
            
            showResults() {
                this.showScreen('results-screen');
                
                const resultsContent = document.getElementById('results-content');
                resultsContent.innerHTML = '';
                
                // Show the reveal
                const revealDiv = document.createElement('div');
                revealDiv.className = 'bg-gray-800 rounded-lg p-4 mb-4';
                revealDiv.innerHTML = `
                    <div class="text-center mb-4">
                        <div class="text-lg font-bold">The real answer was...</div>
                        <div class="text-2xl font-bold text-green-400 mt-2">"${this.gameState.currentPrompt}"</div>
                        <div class="text-sm text-gray-400 mt-1">Drawn by ${this.gameState.players.get(this.gameState.currentArtist)?.name}</div>
                    </div>
                `;
                
                // Show vote breakdown
                const voteBreakdown = document.createElement('div');
                voteBreakdown.className = 'space-y-2';
                
                const voteCounts = new Map();
                this.gameState.votes.forEach(vote => {
                    voteCounts.set(vote, (voteCounts.get(vote) || 0) + 1);
                });
                
                voteCounts.forEach((count, answer) => {
                    const isCorrect = answer === this.gameState.currentPrompt;
                    const submitter = Array.from(this.gameState.guesses.entries()).find(([id, guess]) => guess === answer)?.[0];
                    const submitterName = submitter ? this.gameState.players.get(submitter)?.name : 'Original';
                    
                    const voteDiv = document.createElement('div');
                    voteDiv.className = `p-3 rounded ${isCorrect ? 'bg-green-600' : 'bg-gray-700'}`;
                    voteDiv.innerHTML = `
                        <div class="font-bold">"${answer}"</div>
                        <div class="text-sm text-gray-300">by ${submitterName} ‚Ä¢ ${count} vote${count !== 1 ? 's' : ''}</div>
                    `;
                    voteBreakdown.appendChild(voteDiv);
                });
                
                revealDiv.appendChild(voteBreakdown);
                resultsContent.appendChild(revealDiv);
                
                // Show updated scores
                const scoresDiv = document.createElement('div');
                scoresDiv.className = 'bg-gray-800 rounded-lg p-4';
                scoresDiv.innerHTML = '<div class="text-lg font-bold mb-3">Scores:</div>';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'flex justify-between items-center py-2';
                    playerDiv.innerHTML = `
                        <span>${index + 1}. ${player.name}</span>
                        <span class="font-bold">${player.score}</span>
                    `;
                    scoresDiv.appendChild(playerDiv);
                });
                
                resultsContent.appendChild(scoresDiv);
                
                this.broadcastGameState();
            }
            
            nextRound() {
                if (this.gameState.currentRound >= this.gameState.totalRounds) {
                    this.showFinalResults();
                } else {
                    this.gameState.currentRound++;
                    this.gameState.phase = 'DRAWING';
                    this.gameState.guesses.clear();
                    this.gameState.votes.clear();
                    
                    this.assignPrompts();
                    this.broadcastGameState();
                    this.handleStartGame();
                }
            }
            
            showFinalResults() {
                this.showScreen('final-scores-screen');
                
                const finalScoresContent = document.getElementById('final-scores-content');
                finalScoresContent.innerHTML = '';
                
                const sortedPlayers = Array.from(this.gameState.players.values()).sort((a, b) => b.score - a.score);
                
                sortedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `bg-gray-800 rounded-lg p-4 mb-3 ${index === 0 ? 'border-2 border-yellow-400' : ''}`;
                    
                    let medal = '';
                    if (index === 0) medal = 'üèÜ';
                    else if (index === 1) medal = 'ü•à';
                    else if (index === 2) medal = 'ü•â';
                    
                    playerDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">${medal}</span>
                                <div>
                                    <div class="font-bold text-lg">${player.name}</div>
                                    <div class="text-sm text-gray-400">${index === 0 ? 'Winner!' : `${index + 1}${this.getOrdinalSuffix(index + 1)} place`}</div>
                                </div>
                            </div>
                            <div class="text-2xl font-bold">${player.score}</div>
                        </div>
                    `;
                    finalScoresContent.appendChild(playerDiv);
                });
            }
            
            getOrdinalSuffix(num) {
                const j = num % 10;
                const k = num % 100;
                if (j == 1 && k != 11) return "st";
                if (j == 2 && k != 12) return "nd";
                if (j == 3 && k != 13) return "rd";
                return "th";
            }
            
            playAgain() {
                // Reset game state for new game with same players
                this.gameState.currentRound = 0;
                this.gameState.phase = 'LOBBY';
                this.gameState.guesses.clear();
                this.gameState.votes.clear();
                
                // Reset player scores
                this.gameState.players.forEach(player => {
                    player.score = 0;
                });
                
                this.broadcastGameState();
                this.showLobby();
            }
            
            newGame() {
                // Redirect to home page for completely new game
                window.location.href = '/';
            }
            
            broadcastDrawingData() {
                const canvas = document.getElementById('drawing-canvas');
                const dataURL = canvas.toDataURL();
                
                this.broadcastMessage({
                    type: 'DRAWING_UPDATE',
                    canvasData: dataURL
                });
            }
            
            updateCanvas(dataURL) {
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = dataURL;
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connection-status');
                statusElement.textContent = status;
                
                if (status.includes('error')) {
                    statusElement.className = 'text-sm mt-1 text-red-400';
                } else {
                    statusElement.className = 'text-sm mt-1 text-green-400';
                }
            }
            
            showScreen(screenId) {
                // Hide all screens
                document.querySelectorAll('[id$="-screen"]').forEach(screen => {
                    screen.classList.add('hidden');
                });
                
                // Show target screen
                document.getElementById(screenId).classList.remove('hidden');
            }
            
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast px-4 py-2 rounded shadow-lg ${
                    type === 'success' ? 'bg-green-500' : 
                    type === 'error' ? 'bg-red-500' : 
                    type === 'warning' ? 'bg-yellow-500' : 
                    'bg-blue-500'
                } text-white`;
                
                toast.classList.remove('hidden');
                
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 3000);
            }
            
            updateUI() {
                // Update UI based on current game state
                switch (this.gameState.phase) {
                    case 'LOBBY':
                        this.updatePlayersDisplay();
                        break;
                    case 'DRAWING':
                        // Drawing phase UI updates
                        break;
                    case 'GUESSING':
                        // Update guessing display
                        break;
                    case 'VOTING':
                        // Update voting display
                        break;
                }
            }
        }
        
        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DrawPartyGame();
        });
        
        // Handle page refresh/reconnection
        window.addEventListener('beforeunload', () => {
            if (window.game && window.game.peer) {
                window.game.peer.disconnect();
            }
        });
        
        // Register Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Handle GitHub Pages path
                const swPath = window.location.hostname === 'astraldrift.github.io' ? '/draw-party-game/sw.js' : '/sw.js';
                navigator.serviceWorker.register(swPath)
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Listen for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available, could show update prompt
                                        console.log('New version available');
                                    }
                                });
                            }
                        });
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'RECONNECT_GAME') {
                        // Attempt to reconnect to game
                        if (window.game && window.game.roomCode) {
                            window.game.initializePeer();
                        }
                    }
                });
            });
        }
    </script>
</body>
</html>